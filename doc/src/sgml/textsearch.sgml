<!-- doc/src/sgml/textsearch.sgml -->

<chapter id="textsearch">
<!--
 <title>Full Text Search</title>
-->
 <title>全文検索</title>

  <indexterm zone="textsearch">
   <primary>full text search</primary>
  </indexterm>

  <indexterm zone="textsearch">
   <primary>text search</primary>
  </indexterm>

 <sect1 id="textsearch-intro">
<!--
  <title>Introduction</title>
-->

  <title>導入</title>
  <para>
<!--
   Full Text Searching (or just <firstterm>text search</firstterm>) provides
   the capability to identify natural-language <firstterm>documents</> that
   satisfy a <firstterm>query</firstterm>, and optionally to sort them by
   relevance to the query.  The most common type of search
   is to find all documents containing given <firstterm>query terms</firstterm>
   and return them in order of their <firstterm>similarity</firstterm> to the
   query.  Notions of <varname>query</varname> and
   <varname>similarity</varname> are very flexible and depend on the specific
   application. The simplest search considers <varname>query</varname> as a
   set of words and <varname>similarity</varname> as the frequency of query
   words in the document.
-->
全文検索(または単に<firstterm>テキスト検索</firstterm>)は、<firstterm>問合わせ</firstterm>を満たす自然言語の文書を識別し、更には問合わせとの関連性の順に並び替えることができます。
もっとも一般的な検索は、与えられた<firstterm>検索語</firstterm>を含む文書を探し、<varname>問合わせ</varname>との<firstterm>類似性</firstterm>の順に返す、というものです。
<varname>問合わせ</varname>と<varname>類似性</varname>の記法は非常に柔軟で、特定の用途に適合できます。
もっとも単純な検索では、<varname>問合わせ</varname>は単語の集合として、<varname>類似性</varname>は文書中の問合わせ対象の単語の頻度として扱います。
  </para>

  <para>
<!--
   Textual search operators have existed in databases for years.
   <productname>PostgreSQL</productname> has
   <literal>~</literal>, <literal>~*</literal>, <literal>LIKE</literal>, and
   <literal>ILIKE</literal> operators for textual data types, but they lack
   many essential properties required by modern information systems:
-->
テキスト検索演算子は、データベースシステムに長年存在していました。<productname>PostgreSQL</productname>は、テキストデータ型用に、<literal>~</literal>,<literal>~*</literal>, <literal>LIKE</literal>,<literal>ILIKE</literal>の各演算子を持っています。しかし、近代的な情報システムに必要な以下の本質的な特徴を欠いています。
  </para>

  <itemizedlist  spacing="compact" mark="bullet">
   <listitem>
    <para>
<!--
     There is no linguistic support, even for English.  Regular expressions
     are not sufficient because they cannot easily handle derived words, e.g.,
     <literal>satisfies</literal> and <literal>satisfy</literal>. You might
     miss documents that contain <literal>satisfies</literal>, although you
     probably would like to find them when searching for
     <literal>satisfy</literal>. It is possible to use <literal>OR</literal>
     to search for multiple derived forms, but this is tedious and error-prone
     (some words can have several thousand derivatives).
-->
英語にさえ、言語学的なサポートがありません。
派生語、たとえば<literal>satisfies</literal>に対して<literal>satisfy</literal>を容易に扱えないため、正規表現は十分ではありません。
<literal>satisfy</literal>を探すときは、たぶんあなたは<literal>satisfies</literal>も探したいでしょうが、それらを含む文書は探せないかもしれません。
<literal>OR</literal>を使えば複数の派生語を検索することができますが、退屈で間違いやすいです（ある種の単語は数千の派生語を持つことがあります）。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     They provide no ordering (ranking) of search results, which makes them
     ineffective when thousands of matching documents are found.
-->
検索結果を順序付け(順位付け)することができません。その結果、数千の合致する文書が見つかったような場合に非効率的です。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     They tend to be slow because there is no index support, so they must
     process all documents for every search.
-->
インデックスをサポートしないので毎回検索時にすべての文書を処理しなければならず、遅いです。
    </para>
   </listitem>
  </itemizedlist>

  <para>
<!--
   Full text indexing allows documents to be <emphasis>preprocessed</emphasis>
   and an index saved for later rapid searching. Preprocessing includes:
-->
全文検索のインデックス付けでは、文書を<emphasis>前もって処理しておき</emphasis>、後で素早く検索するために、インデックスを保存しておくことができます。前処理には以下があります。
  </para>

  <itemizedlist  mark="none">
   <listitem>
    <para>
<!--
     <emphasis>Parsing documents into <firstterm>tokens</></emphasis>. It is
     useful to identify various classes of tokens, e.g., numbers, words,
     complex words, email addresses, so that they can be processed
     differently.  In principle token classes depend on the specific
     application, but for most purposes it is adequate to use a predefined
     set of classes.
     <productname>PostgreSQL</productname> uses a <firstterm>parser</> to
     perform this step.  A standard parser is provided, and custom parsers
     can be created for specific needs.
-->
<emphasis>文書から<firstterm>トークン</>を解析します</emphasis>。
トークンを色々なクラス、たとえば数、単語、複合単語、電子メールアドレスに分けて識別することが有効です。そうすれば、扱いを変えることができます。
原則として、トークンのクラスは、特定の用途に依存します。しかし、ほとんどの目的には、あらかじめ定義されたクラスの集合を使うのが適当です。
<productname>PostgreSQL</productname>は、<firstterm>パーサ</>を使ってこの処理段階を実行します。
標準搭載のパーサが提供されますが、特別な用途にはカスタム仕様のパーサを作ることもできます。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     <emphasis>Converting tokens into <firstterm>lexemes</></emphasis>.
     A lexeme is a string, just like a token, but it has been
     <firstterm>normalized</> so that different forms of the same word
     are made alike.  For example, normalization almost always includes
     folding upper-case letters to lower-case, and often involves removal
     of suffixes (such as <literal>s</> or <literal>es</> in English).
     This allows searches to find variant forms of the
     same word, without tediously entering all the possible variants.
     Also, this step typically eliminates <firstterm>stop words</>, which
     are words that are so common that they are useless for searching.
     (In short, then, tokens are raw fragments of the document text, while
     lexemes are words that are believed useful for indexing and searching.)
     <productname>PostgreSQL</productname> uses <firstterm>dictionaries</> to
     perform this step.  Various standard dictionaries are provided, and
     custom ones can be created for specific needs.
-->
<emphasis>トークンを<firstterm>語彙素(lexemes)</>に変換します</emphasis>。
語彙素はトークンと同じ文字列ですが、違う形態の同じ単語が同じになるように <firstterm>正規化</>されています。
たとえば、正規化においてはほぼ常に大文字を小文字に変換し、(英語の<literal>s</>または<literal>es</>のような)接尾辞を取り除くことが多いです。
これにより、可能性のあるすべての変種を地道に入力すること無く、同じ単語の変化形を検索できます。
また、このステップでは、あまりにありふれていて、検索の役に立たない<firstterm>ストップワード</>を取り除くことが多いです。
(つまり、トークンは文書テキストの未加工の断片そのものであり、語彙素はインデックス付けや検索に有用と思われる単語です。)
<productname>PostgreSQL</productname>は、<firstterm>辞書</>を使ってこのステップを実行します。
いろいろな標準辞書が提供されています。特定の用途向けにカスタム辞書を作ることもできます。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     <emphasis>Storing preprocessed documents optimized for
     searching</emphasis>.  For example, each document can be represented
     as a sorted array of normalized lexemes. Along with the lexemes it is
     often desirable to store positional information to use for
     <firstterm>proximity ranking</firstterm>, so that a document that
     contains a more <quote>dense</> region of query words is
     assigned a higher rank than one with scattered query words.
-->
<emphasis>検索に最適化された前処理済の文書を保存します</emphasis>。
たとえば、個々の文書は、正規化された語彙素の整列済の配列として表現されます。
語彙素とともに、<firstterm>適合性ランキング</firstterm>用に、位置情報を格納しておくことがしばしば望まれます。そうすることにより、問合わせの語を<quote>高密度</>に含んでいる文書を、まばらに含む文書よりも高くランクづけすることができます。
    </para>
   </listitem>
  </itemizedlist>

  <para>
<!--
   Dictionaries allow fine-grained control over how tokens are normalized.
   With appropriate dictionaries, you can:
-->
辞書を使ってトークンの正規化を細かく制御できます。
適当な辞書を用意すれば次のようなことができます。
  </para>

  <itemizedlist  spacing="compact" mark="bullet">
   <listitem>
    <para>
<!--
     Define stop words that should not be indexed.
-->
インデックスしたくないストップワードの定義
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Map synonyms to a single word using <application>Ispell</>.
-->
<application>Ispell</>を使って、同義語を単一の単語に関連づける
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Map phrases to a single word using a thesaurus.
-->
類語辞書(thesaurus)を使って、成句を単一の単語に関連づける
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Map different variations of a word to a canonical form using
     an <application>Ispell</> dictionary.
-->
<application>Ispell</>辞書を使って、単語の変種を正規の単語に関連づける
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Map different variations of a word to a canonical form using
     <application>Snowball</> stemmer rules.
-->
<application>Snowball</>語幹規則を使って、単語の変種を正規の単語に関連づける
    </para>
   </listitem>
  </itemizedlist>

  <para>
<!--
   A data type <type>tsvector</type> is provided for storing preprocessed
   documents, along with a type <type>tsquery</type> for representing processed
   queries (<xref linkend="datatype-textsearch">).  There are many
   functions and operators available for these data types
   (<xref linkend="functions-textsearch">), the most important of which is
   the match operator <literal>@@</literal>, which we introduce in
   <xref linkend="textsearch-matching">.  Full text searches can be accelerated
   using indexes (<xref linkend="textsearch-indexes">).
-->
前処理した文書を格納するために、データ型<type>tsvector</type>が提供されています。また、処理済問合わせを表現するために<type>tsquery</type>型も提供されています(<xref linkend="datatype-textsearch">)。これらのデータ型のために、多数の関数と演算子が利用できますが(<xref linkend="functions-textsearch">)、もっとも重要なのは、<xref linkend="textsearch-matching">で紹介している<literal>@@</literal>演算子です。全文検索はインデックス(<xref linkend="textsearch-indexes">)を使って高速化できます。
  </para>


  <sect2 id="textsearch-document">
<!--
   <title>What Is a Document?</title>
-->
   <title>文書とは何か?</title>

   <indexterm zone="textsearch-document">
    <primary>document</primary>
    <secondary>text search</secondary>
   </indexterm>

   <para>
<!--
    A <firstterm>document</> is the unit of searching in a full text search
    system; for example, a magazine article or email message.  The text search
    engine must be able to parse documents and store associations of lexemes
    (key words) with their parent document. Later, these associations are
    used to search for documents that contain query words.
-->
<firstterm>文書</>は全文検索システムにおける検索の単位です。
たとえば、雑誌記事やメールのメッセージです。
テキスト検索エンジンは、文書をパースし、語彙素(キーワード)とそれが含まれる親文書の関連を格納できなければなりません。
後で、この関連を使って問合わせ語を含む文書を検索するのに使います。
   </para>

   <para>
<!--
    For searches within <productname>PostgreSQL</productname>,
    a document is normally a textual field within a row of a database table,
    or possibly a combination (concatenation) of such fields, perhaps stored
    in several tables or obtained dynamically. In other words, a document can
    be constructed from different parts for indexing and it might not be
    stored anywhere as a whole. For example:
-->
<productname>PostgreSQL</productname>での検索においては、ドキュメントはデータベースのテーブルの行内のテキストフィールドか、あるいはそのようなフィールドの組み合わせ(結合)でもよいです。そうしたフィールドはおそらく複数のテーブルに格納されていたり、動的に獲得されるものであったりします。
言い換えると、文書はインデックス付けのために複数の異なる部分から構成されても良く、それらが全体としてはひとまとまりに格納されていなくても良いのです。例を示します。

<programlisting>
SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body AS document
FROM messages
WHERE mid = 12;

SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body AS document
FROM messages m, docs d
WHERE mid = did AND mid = 12;
</programlisting>
   </para>

   <note>
    <para>
<!--
     Actually, in these example queries, <function>coalesce</function>
     should be used to prevent a single <literal>NULL</literal> attribute from
     causing a <literal>NULL</literal> result for the whole document.
-->
実際には、これらの例の問合わせでは、<function>coalesce</function>を使って、一部NULLが含まれているためにドキュメント全体がNULLになってしまうのを防ぐべきです。
    </para>
   </note>

   <para>
<!--
    Another possibility is to store the documents as simple text files in the
    file system. In this case, the database can be used to store the full text
    index and to execute searches, and some unique identifier can be used to
    retrieve the document from the file system.  However, retrieving files
    from outside the database requires superuser permissions or special
    function support, so this is usually less convenient than keeping all
    the data inside <productname>PostgreSQL</productname>.  Also, keeping
    everything inside the database allows easy access
    to document metadata to assist in indexing and display.
-->
別な方法としては、ファイルシステム上に文書を単純なテキストファイルとして格納することです。この場合、データベースは、フルテキストインデックスを格納し、検索を実行するために使うことができます。ファイルシステムから文書を取り出すためには、何かのユニークな識別子を使います。しかし、データベースの外にあるファイルを取り出すには、スーパユーザの許可か、特殊な関数のサポートが必要です。そういうわけでたいていの場合は<productname>PostgreSQL</productname>の中にすべてのデータを保持するのよりも不便です。また、すべてのデータをデータベースに保持することにより、文書のインデックス付けと表示の際に文書のメタデータにアクセスすることが容易になります。
   </para>

   <para>
<!--
    For text search purposes, each document must be reduced to the
    preprocessed <type>tsvector</> format.  Searching and ranking
    are performed entirely on the <type>tsvector</> representation
    of a document &mdash; the original text need only be retrieved
    when the document has been selected for display to a user.
    We therefore often speak of the <type>tsvector</> as being the
    document, but of course it is only a compact representation of
    the full document.
-->
テキスト検索という目的のため、各々の文書は前処理されて<type>tsvector</>形式に変換しておかなければなりません。検索と順位付けはすべて<type>tsvector</>表現の文書上で行われます。検索とランキングは文書の<type>tsvector</>表現上で実行されます &mdash; オリジナル文書は、ユーザに表示のため選択された場合にのみ取り出される必要があります。というわけで、ここでは<type>tsvector</>を文書と見なすことがよくあります。といっても、<type>tsvector</>は完全な文書の縮小表現でしかありません。
   </para>
  </sect2>

  <sect2 id="textsearch-matching">
<!--
   <title>Basic Text Matching</title>
-->
   <title>基本的なテキスト照合</title>

   <para>
<!--
    Full text searching in <productname>PostgreSQL</productname> is based on
    the match operator <literal>@@</literal>, which returns
    <literal>true</literal> if a <type>tsvector</type>
    (document) matches a <type>tsquery</type> (query).
    It doesn't matter which data type is written first:
-->
<productname>PostgreSQL</productname>における全文検索は、<type>tsvector</type>(文書)が、<type>tsquery</type>(問合わせ)に一致したら真を返す照合演算子<literal>@@</literal>に基づいています。どちらのデータ型を先に書いても構いません。

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat &amp; rat'::tsquery;
 ?column?
----------
 t

SELECT 'fat &amp; cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector;
 ?column?
----------
 f
</programlisting>
   </para>

   <para>
<!--
    As the above example suggests, a <type>tsquery</type> is not just raw
    text, any more than a <type>tsvector</type> is.  A <type>tsquery</type>
    contains search terms, which must be already-normalized lexemes, and
    may combine multiple terms using AND, OR, and NOT operators.
    (For details see <xref linkend="datatype-textsearch">.)  There are
    functions <function>to_tsquery</> and <function>plainto_tsquery</>
    that are helpful in converting user-written text into a proper
    <type>tsquery</type>, for example by normalizing words appearing in
    the text.  Similarly, <function>to_tsvector</> is used to parse and
    normalize a document string.  So in practice a text search match would
    look more like this:
-->
上記の例でわかるように、<type>tsquery</type>は、<type>tsvector</type>と違って、単なるテキストではありません。<type>tsquery</type>は正規化済の語彙素である検索表現を含み、AND, OR, NOT演算子を使って複数の表現を組み合わせても構いません。
(詳細は<xref linkend="datatype-textsearch">を見てください。)
たとえば、テキスト中の単語を正規化することにより、ユーザが入力したテキストを適切な<type>tsquery</type>に変換する<function>to_tsquery</>と<function>plainto_tsquery</>という関数があります。同様に、文書文字列をパースして正規化するために<function>to_tsvector</>が利用できます。
というわけで、実際にはテキスト検索照合はこんな感じになります。

<programlisting>
SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat &amp; rat');
 ?column? 
----------
 t
</programlisting>

<!--
    Observe that this match would not succeed if written as
-->
この照合は、もしつぎのように書くとうまくいかないことに注意してください。

<programlisting>
SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat &amp; rat');
 ?column? 
----------
 f
</programlisting>

<!--
    since here no normalization of the word <literal>rats</> will occur.
    The elements of a <type>tsvector</> are lexemes, which are assumed
    already normalized, so <literal>rats</> does not match <literal>rat</>.
-->
というのも、単語<literal>rats</>に対して正規化が行われないからです。
<type>tsvector</>の要素は、すでに正規化されている語彙素であることになっているので、<literal>rats</>は<literal>rat</>に一致しません。
   </para>

   <para>
<!--
    The <literal>@@</literal> operator also
    supports <type>text</type> input, allowing explicit conversion of a text
    string to <type>tsvector</type> or <type>tsquery</> to be skipped
    in simple cases.  The variants available are:
-->
また、<literal>@@</literal>演算子は、<type>text</type>を入力として受付けるので、簡単に使うときには、明示的にテキスト文字列を<type>tsvector</type>または<type>tsquery</>に変換することを省略できます。応用として以下のものがあります。

<programlisting>
tsvector @@ tsquery
tsquery  @@ tsvector
text @@ tsquery
text @@ text
</programlisting>
   </para>

   <para>
<!--
    The first two of these we saw already.
    The form <type>text</type> <literal>@@</literal> <type>tsquery</type>
    is equivalent to <literal>to_tsvector(x) @@ y</literal>.
    The form <type>text</type> <literal>@@</literal> <type>text</type>
    is equivalent to <literal>to_tsvector(x) @@ plainto_tsquery(y)</literal>.
-->
最初の2つについてはすでに説明しました。
<type>text</type> <literal>@@</literal> <type>tsquery</type>という形式は、<literal>to_tsvector(x) @@ y</literal>と同じです。
<type>text</type> <literal>@@</literal> <type>text</type>という形式は、<literal>to_tsvector(x) @@plainto_tsquery(y)</literal>と同じです。
   </para>
  </sect2>

  <sect2 id="textsearch-intro-configurations">
<!--
   <title>Configurations</title>
-->
   <title>設定</title>

   <para>
<!--
    The above are all simple text search examples.  As mentioned before, full
    text search functionality includes the ability to do many more things:
    skip indexing certain words (stop words), process synonyms, and use
    sophisticated parsing, e.g., parse based on more than just white space.
    This functionality is controlled by <firstterm>text search
    configurations</>.  <productname>PostgreSQL</> comes with predefined
    configurations for many languages, and you can easily create your own
    configurations.  (<application>psql</>'s <command>\dF</> command
    shows all available configurations.)
-->
今までのはすべて単純なテキスト検索の例でした。
すでに述べたように、全文検索機能を使えば、もっと色々なことができます。
インデックス付けの際に特定の単語をスキップ(ストップワード)、同義語(synonym)処理、賢いパース処理、すなわち、単に空白区切りに基づくパース処理以上のものです。
この機能は<firstterm>テキスト検索設定</>で制御します。
<productname>PostgreSQL</>には、多くの言語用の設定があらかじめ組み込まれていますが、ユーザ設定を容易に作ることもできます。
(<application>psql</>の<command>\dF</>コマンドで、利用できる設定を表示できます。)
   </para>

   <para>
<!--
    During installation an appropriate configuration is selected and
    <xref linkend="guc-default-text-search-config"> is set accordingly
    in <filename>postgresql.conf</>.  If you are using the same text search
    configuration for the entire cluster you can use the value in
    <filename>postgresql.conf</>.  To use different configurations
    throughout the cluster but the same configuration within any one database,
    use <command>ALTER DATABASE ... SET</>.  Otherwise, you can set
    <varname>default_text_search_config</varname> in each session.
-->
インストールの際には、適当な設定が選ばれ、<xref linkend="guc-default-text-search-config">が<filename>postgresql.conf</>中にセットされます。クラスタ全体で同じ設定を使用する場合は<filename>postgresql.conf</>の設定値を利用できます。クラスタの設定とは異なるが、あるデータベースの中で同じ設定を使う場合には、<command>ALTER DATABASE ... SET</>を利用します。さもなければ、セッション単位で<varname>default_text_search_config</varname>を設定できます。
   </para>

   <para>
<!--
    Each text search function that depends on a configuration has an optional
    <type>regconfig</> argument, so that the configuration to use can be
    specified explicitly.  <varname>default_text_search_config</varname>
    is used only when this argument is omitted.
-->
設定に依存するテキスト検索関数は、オプションで<type>regconfig</>引数を持っており、使用する設定を明示的に指定できます。<varname>default_text_search_config</varname>は、この引数が省略されたときだけ使用されます。
   </para>

   <para>
<!--
    To make it easier to build custom text search configurations, a
    configuration is built up from simpler database objects.
    <productname>PostgreSQL</>'s text search facility provides
    four types of configuration-related database objects:
-->
カスタムテキスト検索設定を作り易くするため、設定はより単純なデータベースオブジェクトから作られます。<productname>PostgreSQL</>のテキスト検索機能は、4つの設定関連のデータベースオブジェクトを提供しています。
   </para>

  <itemizedlist  spacing="compact" mark="bullet">
   <listitem>
    <para>
<!--
     <firstterm>Text search parsers</> break documents into tokens
     and classify each token (for example, as words or numbers).
-->
<firstterm>テキスト検索パーサ</>は、文書をトークンに分解し、トークンを分類します(たとえば、単語とか数のように)。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     <firstterm>Text search dictionaries</> convert tokens to normalized
     form and reject stop words.
-->
<firstterm>テキスト検索辞書</>はトークンを正規化された形式に変換し、ストップワードを排除します。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     <firstterm>Text search templates</> provide the functions underlying
     dictionaries.  (A dictionary simply specifies a template and a set
     of parameters for the template.)
-->
<firstterm>テキスト検索テンプレート</>は、現在の辞書が利用する関数を提供します(辞書は、単にテンプレートと、その引数の集合を指定するだけです)。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     <firstterm>Text search configurations</> select a parser and a set
     of dictionaries to use to normalize the tokens produced by the parser.
-->
<firstterm>テキスト検索設定</>は、パーサと使用する辞書の集合を選択し、パーサが生成したトークンを正規化します。
    </para>
   </listitem>
  </itemizedlist>

   <para>
<!--
    Text search parsers and templates are built from low-level C functions;
    therefore it requires C programming ability to develop new ones, and
    superuser privileges to install one into a database.  (There are examples
    of add-on parsers and templates in the <filename>contrib/</> area of the
    <productname>PostgreSQL</> distribution.)  Since dictionaries and
    configurations just parameterize and connect together some underlying
    parsers and templates, no special privilege is needed to create a new
    dictionary or configuration.  Examples of creating custom dictionaries and
    configurations appear later in this chapter.
-->
テキスト検索パーサとテンプレートは、低レベルのC関数で作ります。したがって、新しく開発するためにはCのプログラミング能力と、データベースにインストールするためのスーパユーザ権限が必要になります。(<productname>PostgreSQL</>の配布物の<filename>contrib/</>には、追加パーサとテンプレートの例があります)。辞書と設定は、単に配下のパーサとテンプレートのパラメータを設定し、両者を結び付けるだけなので、新しい辞書と設定を作るために特別な権限は必要ありません。この章の後でカスタム辞書と設定を作る例が登場します。
   </para>

  </sect2>

 </sect1>

 <sect1 id="textsearch-tables">
<!--
  <title>Tables and Indexes</title>
-->
  <title>テーブルとインデックス</title>

  <para>
<!--
   The examples in the previous section illustrated full text matching using
   simple constant strings.  This section shows how to search table data,
   optionally using indexes.
-->
前の節の例では、単純な文字列定数を使った全文検索照合を説明しました。この節では、テーブルのデータを検索する方法、そしてインデックスを使う方法を示します。
  </para>

  <sect2 id="textsearch-tables-search">
<!--
   <title>Searching a Table</title>
-->
   <title>テーブルを検索する</title>

   <para>
<!--
    It is possible to do a full text search without an index.  A simple query
    to print the <structname>title</> of each row that contains the word
    <literal>friend</> in its <structfield>body</> field is:
-->
インデックスがなくても全文検索をすることは可能です。<structfield>body</>フィールド中の<literal>friend</>という単語を含む行の<structname>title</>を印刷する単純な問合わせは次のようになります。

<programlisting>
SELECT title
FROM pgweb
WHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');
</programlisting>

<!--
    This will also find related words such as <literal>friends</>
    and <literal>friendly</>, since all these are reduced to the same
    normalized lexeme.
-->
同時に、これは、<literal>friends</>、<literal>friendly</>のように、関連する単語を見つけ出します。これらはすべて同じ正規化された語彙素に帰結するからです。
   </para>

   <para>
<!--
    The query above specifies that the <literal>english</> configuration
    is to be used to parse and normalize the strings.  Alternatively we
    could omit the configuration parameters:
-->
上の問合わせは<literal>english</>設定を使って文字列をパースして正規化することを指定しています。別の方法としては、設定パラメータを省略することができます。

<programlisting>
SELECT title
FROM pgweb
WHERE to_tsvector(body) @@ to_tsquery('friend');
</programlisting>

<!--
    This query will use the configuration set by <xref
    linkend="guc-default-text-search-config">.
-->
この問い合わせは<xref linkend="guc-default-text-search-config">で設定された設定を使用します。
   </para>

   <para>
<!--
    A more complex example is to
    select the ten most recent documents that contain <literal>create</> and
    <literal>table</> in the <structname>title</> or <structname>body</>:
-->
もっと複雑な例として、<literal>create</>と<literal>table</>を<structname>title</>または<structname>body</>に含む文書のうち新しい順に10個選ぶというものを示します。

<programlisting>
SELECT title
FROM pgweb
WHERE to_tsvector(title || ' ' || body) @@ to_tsquery('create &amp; table')
ORDER BY last_mod_date DESC
LIMIT 10;
</programlisting>

<!--
    For clarity we omitted the <function>coalesce</function> function calls
    which would be needed to find rows that contain <literal>NULL</literal>
    in one of the two fields.
-->
細かいことですが、この例では、二つのうち一つのフィールドに<literal>NULL</literal>を含む行を探すために必要な<function>coalesce</function>関数の呼び出しを省略しています。
   </para>

   <para>
<!--
    Although these queries will work without an index, most applications
    will find this approach too slow, except perhaps for occasional ad-hoc
    searches.  Practical use of text searching usually requires creating
    an index.
-->
これらの問合わせはインデックスなしでも動きますが、たまに実行する一時的な問合わせ用を除くと、たいていの用途には遅すぎます。
実用上は、インデックスを作成することが必要なのが普通です。
   </para>

  </sect2>

  <sect2 id="textsearch-tables-index">
<!--
   <title>Creating Indexes</title>
-->
   <title>インデックスの作成</title>

   <para>
<!--
    We can create a <acronym>GIN</acronym> index (<xref
    linkend="textsearch-indexes">) to speed up text searches:
-->
テキスト検索を高速化するために、<acronym>GIN</acronym>インデックス(<xref linkend="textsearch-indexes">)を作ることができます。

<programlisting>
CREATE INDEX pgweb_idx ON pgweb USING gin(to_tsvector('english', body));
</programlisting>

<!--
    Notice that the 2-argument version of <function>to_tsvector</function> is
    used.  Only text search functions that specify a configuration name can
    be used in expression indexes (<xref linkend="indexes-expressional">).
    This is because the index contents must be unaffected by <xref
    linkend="guc-default-text-search-config">.  If they were affected, the
    index contents might be inconsistent because different entries could
    contain <type>tsvector</>s that were created with different text search
    configurations, and there would be no way to guess which was which.  It
    would be impossible to dump and restore such an index correctly.
-->
2引数バージョンの<function>to_tsvector</function>を使っていることに注意してください。設定名を指定するテキスト検索関数だけが、式インデックス(<xref linkend="indexes-expressional">)で使えます。これは、インデックス内容が、<xref linkend="guc-default-text-search-config">の影響を受けないためです。もし影響を受けるとすると、異なるテキスト検索設定で作られた<type>tsvector</>を持つエントリの間でインデックス内容が首尾一貫しなくなるからです。そして、どのエントリがどのようにして作られたのか、推測する方法はないでしょう。そのようなインデックスを正しくダンプ、リストアするのは不可能でしょう。
   </para>

   <para>
<!--
    Because the two-argument version of <function>to_tsvector</function> was
    used in the index above, only a query reference that uses the 2-argument
    version of <function>to_tsvector</function> with the same configuration
    name will use that index.  That is, <literal>WHERE
    to_tsvector('english', body) @@ 'a &amp; b'</> can use the index,
    but <literal>WHERE to_tsvector(body) @@ 'a &amp; b'</> cannot.
    This ensures that an index will be used only with the same configuration
    used to create the index entries.
-->
上記のインデックスでは、2引数バージョンの<function>to_tsvector</function>が使われているので、同じ設定名の2引数バージョンの<function>to_tsvector</function>を使う問合わせ参照だけがそのインデックスを使います。すなわち、<literal>WHERE to_tsvector('english', body) @@ 'a &amp; b'</>はインデックスが使えますが、<literal>WHERE to_tsvector(body) @@ 'a &amp; b'</>は使えません。これにより、インデックスエントリを作ったときの設定と、同じ設定のときだけインデックスが使われることが保証されます。
   </para>

  <para>
<!--
    It is possible to set up more complex expression indexes wherein the
    configuration name is specified by another column, e.g.:
-->
他の列によって設定名が指定されたより複雑な式インデックスを作ることができます。例えば、

<programlisting>
CREATE INDEX pgweb_idx ON pgweb USING gin(to_tsvector(config_name, body));
</programlisting>

<!--
    where <literal>config_name</> is a column in the <literal>pgweb</>
    table.  This allows mixed configurations in the same index while
    recording which configuration was used for each index entry.  This
    would be useful, for example, if the document collection contained
    documents in different languages.  Again,
    queries that are meant to use the index must be phrased to match, e.g.,
    <literal>WHERE to_tsvector(config_name, body) @@ 'a &amp; b'</>.
-->
ここで、<literal>config_name</>は<literal>pgweb</>テーブルの列です。
これによって、各々のインデックスエントリで使用された設定を記録しつつ、同じインデックスの中で異なる設定を混在させることができます。
これは、例えば文書の集まりが異なる言語の文書を含む場合に有用です。
繰り返しになりますが、インデックスを使うよう考慮されている問合わせは、合致するように書かれなければなりません。例えば、<literal>WHERE to_tsvector(config_name, body) @@ 'a &amp; b'</>。
   </para>

   <para>
<!--
    Indexes can even concatenate columns:
-->
インデックスには、列を連結することさえできます。

<programlisting>
CREATE INDEX pgweb_idx ON pgweb USING gin(to_tsvector('english', title || ' ' || body));
</programlisting>
   </para>

   <para>
<!--
    Another approach is to create a separate <type>tsvector</> column
    to hold the output of <function>to_tsvector</>.  This example is a
    concatenation of <literal>title</literal> and <literal>body</literal>,
    using <function>coalesce</> to ensure that one field will still be
    indexed when the other is <literal>NULL</>:
-->
別の方法として、<function>to_tsvector</>の出力を保持する別の<type>tsvector</>列を作る方法があります。この例では、<literal>title</literal>と<literal>body</literal>を連結、<function>coalesce</>を使って、一つのフィールドが<literal>NULL</>であっても他のフィールドがインデックス付けされることを保証しています。

<programlisting>
ALTER TABLE pgweb ADD COLUMN textsearchable_index_col tsvector;
UPDATE pgweb SET textsearchable_index_col =
     to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''));
</programlisting>

<!--
    Then we create a <acronym>GIN</acronym> index to speed up the search:
-->
そして、<acronym>GIN</acronym>インデックスを作って検索速度を上げます。

<programlisting>
CREATE INDEX textsearch_idx ON pgweb USING gin(textsearchable_index_col);
</programlisting>

<!--
    Now we are ready to perform a fast full text search:
-->
これで、高速全文検索を実行する準備ができました。

<programlisting>
SELECT title
FROM pgweb
WHERE textsearchable_index_col @@ to_tsquery('create &amp; table')
ORDER BY last_mod_date DESC
LIMIT 10;
</programlisting>
   </para>

   <para>
<!--
    When using a separate column to store the <type>tsvector</>
    representation,
    it is necessary to create a trigger to keep the <type>tsvector</>
    column current anytime <literal>title</> or <literal>body</> changes.
    <xref linkend="textsearch-update-triggers"> explains how to do that.
-->
<type>tsvector</>形式を保存するために別の列を使う場合、<literal>title</>あるいは<literal>body</>が変更されたら<type>tsvector</>列を最新の状態にいつでも維持するためにトリガを作る必要があります。<xref linkend="textsearch-update-triggers">にその方法が説明されています。
   </para>

   <para>
<!--
    One advantage of the separate-column approach over an expression index
    is that it is not necessary to explicitly specify the text search
    configuration in queries in order to make use of the index.  As shown
    in the example above, the query can depend on
    <varname>default_text_search_config</>.  Another advantage is that
    searches will be faster, since it will not be necessary to redo the
    <function>to_tsvector</> calls to verify index matches.  (This is more
    important when using a GiST index than a GIN index; see <xref
    linkend="textsearch-indexes">.)  The expression-index approach is
    simpler to set up, however, and it requires less disk space since the
    <type>tsvector</> representation is not stored explicitly.
-->
別列方式が式インデックスに勝る点の一つは、インデックスを使うために問合わせの中でテキスト検索設定を明示的に指定する必要がないことです。上の例で示したように、問合わせは<varname>default_text_search_config</>に依存できます。もう一つの利点は、インデックスの合致を検証するために<function>to_tsvector</>を再実行する必要がないのでより高速だという事です。(この点はGINインデックスを使うときよりも、GiSTインデックスを使う場合に重要です。<xref linkend="textsearch-indexes">参照。)しかしながら、式インデックス方式はセットアップがより容易で、<type>tsvector</>表現を明示的に保存する必要がないので、ディスクスペースの消費が少ないです。
   </para>

  </sect2>

 </sect1>

 <sect1 id="textsearch-controls">
<!--
  <title>Controlling Text Search</title>
-->
  <title>テキスト検索の制御</title>

  <para>
<!--
   To implement full text searching there must be a function to create a
   <type>tsvector</type> from a document and a <type>tsquery</type> from a
   user query. Also, we need to return results in a useful order, so we need
   a function that compares documents with respect to their relevance to
   the query. It's also important to be able to display the results nicely.
   <productname>PostgreSQL</productname> provides support for all of these
   functions.
-->
全文検索を実装するためには、文書から<type>tsvector</type>を、そしてユーザの問合わせから<type>tsquery</type>を作成する関数が存在しなければなりません。また、結果を意味のある順で返す必要があります。そこで、問合わせとの関連性で文書を比較する関数も必要になってきます。結果を体裁良く表示できることも重要です。<productname>PostgreSQL</productname>はこれらすべての機能を提供しています。
  </para>

  <sect2 id="textsearch-parsing-documents">
<!--
   <title>Parsing Documents</title>
-->
   <title>文書のパース</title>

   <para>
<!--
    <productname>PostgreSQL</productname> provides the
    function <function>to_tsvector</function> for converting a document to
    the <type>tsvector</type> data type.
-->
<productname>PostgreSQL</productname>は、文書を<type>tsvector</type>データ型に変換する<function>to_tsvector</function>関数を提供しています。
   </para>

   <indexterm>
    <primary>to_tsvector</primary>
   </indexterm>

<synopsis>
to_tsvector(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>) returns <type>tsvector</>
</synopsis>

   <para>
<!--
    <function>to_tsvector</function> parses a textual document into tokens,
    reduces the tokens to lexemes, and returns a <type>tsvector</type> which
    lists the lexemes together with their positions in the document.
    The document is processed according to the specified or default
    text search configuration.
    Here is a simple example:
-->
<function>to_tsvector</function>は、テキスト文書をパースしてトークンにし、トークンを語彙素に変換、文書中の位置とともに語彙素をリストとして持つ<type>tsvector</type>を返します。文書は、指定したものか、あるいはデフォルトのテキスト検索設定にしたがって処理されます。単純な例を示します。

<screen>
SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat rats');
                  to_tsvector
-----------------------------------------------------
 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4
</screen>
   </para>

   <para>
<!--
    In the example above we see that the resulting <type>tsvector</type> does not
    contain the words <literal>a</literal>, <literal>on</literal>, or
    <literal>it</literal>, the word <literal>rats</literal> became
    <literal>rat</literal>, and the punctuation sign <literal>-</literal> was
    ignored.
-->
上に示す例では、結果の<type>tsvector</type>で、<literal>a</literal>、<literal>on</literal>、<literal>it</literal>という単語が含まれないこと、<literal>rats</literal>という単語が<literal>rat</literal>になっていること、句読点記号<literal>-</literal>が無視されていることがわかります。
   </para>

   <para>
<!--
    The <function>to_tsvector</function> function internally calls a parser
    which breaks the document text into tokens and assigns a type to
    each token.  For each token, a list of
    dictionaries (<xref linkend="textsearch-dictionaries">) is consulted,
    where the list can vary depending on the token type.  The first dictionary
    that <firstterm>recognizes</> the token emits one or more normalized
    <firstterm>lexemes</firstterm> to represent the token.  For example,
    <literal>rats</literal> became <literal>rat</literal> because one of the
    dictionaries recognized that the word <literal>rats</literal> is a plural
    form of <literal>rat</literal>.  Some words are recognized as
    <firstterm>stop words</> (<xref linkend="textsearch-stopwords">), which
    causes them to be ignored since they occur too frequently to be useful in
    searching.  In our example these are
    <literal>a</literal>, <literal>on</literal>, and <literal>it</literal>.
    If no dictionary in the list recognizes the token then it is also ignored.
    In this example that happened to the punctuation sign <literal>-</literal>
    because there are in fact no dictionaries assigned for its token type
    (<literal>Space symbols</literal>), meaning space tokens will never be
    indexed. The choices of parser, dictionaries and which types of tokens to
    index are determined by the selected text search configuration (<xref
    linkend="textsearch-configuration">).  It is possible to have
    many different configurations in the same database, and predefined
    configurations are available for various languages. In our example
    we used the default configuration <literal>english</literal> for the
    English language.
-->
<function>to_tsvector</function>関数は、文書をトークンに分解して、そのトークンに型を割り当てるパーサを内部的に呼び出しています。それぞれのトークンに対して辞書(<xref linkend="textsearch-dictionaries">)のリストが検索されます。ここで、辞書のリストはトークンの型によって異なります。最初の辞書は、トークンを<firstterm>認識</>し、トークンを表現する一つ以上の正規化された<firstterm>語彙素</firstterm>を出力します。例えば、ある辞書は<literal>rats</literal>は<literal>rat</literal>の複数形であることを認識しているので、<literal>rats</literal>は<literal>rat</literal>になります。
ある単語は<firstterm>ストップワード</>(<xref linkend="textsearch-stopwords">)として認識されます。これは、あまりにも多く出現し検索の役に立たないため、無視されるものです。
先の例では、<literal>a</literal>、<literal>on</literal>、および<literal>it</literal>がそれです。
もしリスト中の辞書のどれもがトークンを認識しなければ、そのトークンは無視されます。先の例では、句読点の<literal>-</literal>がそうです。なぜなら、実際にはそのトークン型(<literal>Space symbols</literal>)に対して辞書が割り当てられておらず、空白トークンは決してインデックス付けされないことを意味します。パーサ、辞書、そしてどのトークンがインデックス付けされるかという選択は、テキスト検索設定(<xref linkend="textsearch-configuration">)によって決められます。同じデータベース中に多くの異なった設定を持つことができ、多くの言語用に定義済の設定が用意されています。先の例では、英語用として、デフォルトの<literal>english</literal>設定を使っています。
   </para>

   <para>
<!--
    The function <function>setweight</function> can be used to label the
    entries of a <type>tsvector</type> with a given <firstterm>weight</>,
    where a weight is one of the letters <literal>A</>, <literal>B</>,
    <literal>C</>, or <literal>D</>.
    This is typically used to mark entries coming from
    different parts of a document, such as title versus body.  Later, this
    information can be used for ranking of search results.
-->
関数<function>setweight</function>を使って<type>tsvector</type>のエントリに与えられた<firstterm>重み</>のラベルを与えることができます。ここで重みは、<literal>A</>, <literal>B</>, <literal>C</>, <literal>D</>のどれかの文字です。重みの典型的な使い方は、文書の各部分がどこから来たのかをマークすることです。たとえば、タイトルから来たのか、本文から来たのかなど。後でこの情報は検索結果のランキングに利用できます。
   </para>

   <para>
<!--
    Because <function>to_tsvector</function>(<literal>NULL</literal>) will
    return <literal>NULL</literal>, it is recommended to use
    <function>coalesce</function> whenever a field might be null.
    Here is the recommended method for creating
    a <type>tsvector</type> from a structured document:
-->
<function>to_tsvector</function>(<literal>NULL</literal>)は<literal>NULL</literal>を返すので、NULLになる可能性のある列に対しては<function>coalesce</function>を使うことをお勧めします。構造化された文書から<type>tsvector</type>を作るための推奨できる方法を示します。

<programlisting>
UPDATE tt SET ti =
    setweight(to_tsvector(coalesce(title,'')), 'A')    ||
    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||
    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||
    setweight(to_tsvector(coalesce(body,'')), 'D');
</programlisting>

<!--
    Here we have used <function>setweight</function> to label the source
    of each lexeme in the finished <type>tsvector</type>, and then merged
    the labeled <type>tsvector</type> values using the <type>tsvector</>
    concatenation operator <literal>||</>.  (<xref
    linkend="textsearch-manipulate-tsvector"> gives details about these
    operations.)
-->
ここでは、完成した<type>tsvector</type>の語彙素に対して、ラベル付けのために<function>setweight</function>を使っています。そして、<type>tsvector</>の連結演算子<literal>||</>を使って、ラベルづけされた<type>tsvector</type>の値をマージします。(詳細は<xref linkend="textsearch-manipulate-tsvector">を参照してください。)
   </para>

  </sect2>

  <sect2 id="textsearch-parsing-queries">
<!--
   <title>Parsing Queries</title>
-->
   <title>問合わせのパース</title>

   <para>
<!--
    <productname>PostgreSQL</productname> provides the
    functions <function>to_tsquery</function> and
    <function>plainto_tsquery</function> for converting a query to
    the <type>tsquery</type> data type.  <function>to_tsquery</function>
    offers access to more features than <function>plainto_tsquery</function>,
    but is less forgiving about its input.
-->
<productname>PostgreSQL</productname>は、問合わせを<type>tsquery</type>に変換する<function>to_tsquery</function>関数と<function>plainto_tsquery</function>関数を提供しています。<function>to_tsquery</function>は、<function>plainto_tsquery</function>よりも多くの機能を提供していますが、入力のチェックはより厳格です。
   </para>

   <indexterm>
    <primary>to_tsquery</primary>
   </indexterm>

<synopsis>
to_tsquery(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">querytext</replaceable> <type>text</>) returns <type>tsquery</>
</synopsis>

   <para>
<!--
    <function>to_tsquery</function> creates a <type>tsquery</> value from
    <replaceable>querytext</replaceable>, which must consist of single tokens
    separated by the Boolean operators <literal>&amp;</literal> (AND),
    <literal>|</literal> (OR) and <literal>!</literal> (NOT).  These operators
    can be grouped using parentheses.  In other words, the input to
    <function>to_tsquery</function> must already follow the general rules for
    <type>tsquery</> input, as described in <xref
    linkend="datatype-textsearch">.  The difference is that while basic
    <type>tsquery</> input takes the tokens at face value,
    <function>to_tsquery</function> normalizes each token to a lexeme using
    the specified or default configuration, and discards any tokens that are
    stop words according to the configuration.  For example:
-->
<function>to_tsquery</function>は、<replaceable>querytext</replaceable>から<type>tsquery</>としての値を生成します。<replaceable>querytext</replaceable>は、論理演算子<literal>&amp;</literal> (AND), <literal>|</literal> (OR)、<literal>!</literal> (NOT)で区切られる単一のトークンから構成されなければなりません。これらの演算子は括弧でグループ化できます。言い換えると、<function>to_tsquery</function>の入力は、<xref linkend="datatype-textsearch">で述べられている一般規則にしたがっていなければなりません。違いは、基本的な<type>tsquery</>の入力はトークンの表面的な値を受け取るのに対し、<function>to_tsquery</function>は指定した、あるいはデフォルトの設定を使ってトークンを語彙素へと正規化し、設定にしたがって、ストップワードであるようなトークンを破棄します。例を示します。

<screen>
SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');
  to_tsquery   
---------------
 'fat' &amp; 'rat'
</screen>

<!--
    As in basic <type>tsquery</> input, weight(s) can be attached to each
    lexeme to restrict it to match only <type>tsvector</> lexemes of those
    weight(s).  For example:
-->
基本的な<type>tsquery</>の入力では、各々の語彙素に重みを付加することにより、同じ重みを持つ<type>tsvector</>の語彙素のみに照合するようにすることができます。例を示します。

<screen>
SELECT to_tsquery('english', 'Fat | Rats:AB');
    to_tsquery    
------------------
 'fat' | 'rat':AB
</screen>

<!--
    Also, <literal>*</> can be attached to a lexeme to specify prefix matching:
-->
また、明示的な前方一致検索のため、<literal>*</>を語彙素に与えることもできます。

<screen>
SELECT to_tsquery('supern:*A &amp; star:A*B');
        to_tsquery        
--------------------------
 'supern':*A &amp; 'star':*AB
</screen>

<!--
    Such a lexeme will match any word in a <type>tsvector</> that begins
    with the given string.
-->
このような語彙素は、与えられた文字列で始まる<type>tsvector</>中のどんな単語にも照合するでしょう。
   </para>

   <para>
<!--
    <function>to_tsquery</function> can also accept single-quoted
    phrases.  This is primarily useful when the configuration includes a
    thesaurus dictionary that may trigger on such phrases.
    In the example below, a thesaurus contains the rule <literal>supernovae
    stars : sn</literal>:
-->
<function>to_tsquery</function>は、単一引用符で囲まれた語句を受け付けることもできます。これは主に、設定の中にそういった語句を持つ同義語辞書を含んでいるときに有用です。以下の例では、ある同義語の中に<literal>supernovae stars : sn</literal>という規則が含まれています。

<screen>
SELECT to_tsquery('''supernovae stars'' &amp; !crab');
  to_tsquery
---------------
 'sn' &amp; !'crab'
</screen>

<!--
    Without quotes, <function>to_tsquery</function> will generate a syntax
    error for tokens that are not separated by an AND or OR operator.
-->
引用符がない場合は、<function>to_tsquery</function>は、ANDあるいはOR演算子で区切られていないトークンに対して構文エラーを引き起こします。
   </para>

   <indexterm>
    <primary>plainto_tsquery</primary>
   </indexterm>

<synopsis>
plainto_tsquery(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">querytext</replaceable> <type>text</>) returns <type>tsquery</>
</synopsis>

   <para>
<!--
    <function>plainto_tsquery</> transforms unformatted text
    <replaceable>querytext</replaceable> to <type>tsquery</type>.
    The text is parsed and normalized much as for <function>to_tsvector</>,
    then the <literal>&amp;</literal> (AND) Boolean operator is inserted
    between surviving words.
-->
<function>plainto_tsquery</>は整形されていないテキスト<replaceable>querytext</replaceable>を、<type>tsquery</type>に変換します。テキストはパースされ、<function>to_tsvector</>としてできる限り正規化されます。そして、<literal>&amp;</literal> (AND) 論理演算子が存続した単語の間に挿入されます。
   </para>

   <para>
<!--
    Example:
-->
例：

<screen>
SELECT plainto_tsquery('english', 'The Fat Rats');
 plainto_tsquery 
-----------------
 'fat' &amp; 'rat'
</screen>

<!--
    Note that <function>plainto_tsquery</> cannot
    recognize Boolean operators, weight labels, or prefix-match labels
    in its input:
-->
<function>plainto_tsquery</>は、入力中の論理演算子も、重さラベルも、前方一致ラベルも認識できないことに注意してください。

<screen>
SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');
   plainto_tsquery   
---------------------
 'fat' &amp; 'rat' &amp; 'c'
</screen>

<!--
    Here, all the input punctuation was discarded as being space symbols.
-->
ここでは、入力中のすべての句読点がスペース記号に変換された結果、破棄されています。
   </para>

  </sect2>

  <sect2 id="textsearch-ranking">
<!--
   <title>Ranking Search Results</title>
-->
   <title>検索結果のランキング</title>

   <para>
<!--
    Ranking attempts to measure how relevant documents are to a particular
    query, so that when there are many matches the most relevant ones can be
    shown first.  <productname>PostgreSQL</productname> provides two
    predefined ranking functions, which take into account lexical, proximity,
    and structural information; that is, they consider how often the query
    terms appear in the document, how close together the terms are in the
    document, and how important is the part of the document where they occur.
    However, the concept of relevancy is vague and very application-specific.
    Different applications might require additional information for ranking,
    e.g., document modification time.  The built-in ranking functions are only
    examples.  You can write your own ranking functions and/or combine their
    results with additional factors to fit your specific needs.
-->
ランキングはある問合わせに対して、どの程度文書が関連しているかを計測しようとするものです。合致している文書が多数あるとき、もっとも関連している文書が最初に表示されるようにするためです。
<productname>PostgreSQL</productname>は、2つの定義済ランキング関数を提供しています。それらは、辞書情報、近接度情報、構造的情報を加味します。すなわち、問合わせの用語がどの位の頻度で文書に出現するか、文書中でどの程度それらの用語が近接しているか、どの用語が含まれる文書部位がどの程度重要なのかを考慮します。
しかし、関連度という概念は曖昧で、用途に強く依存します。
異なる用途は、ランキングのために追加の情報を必要とするかも知れません。たとえば、文書の更新時刻など。
組み込みのランキング関数は例に過ぎません。
利用者の目的に応じて、自分用のランキング関数を作ったり、その結果を追加の情報と組み合わせることができます。
   </para>

   <para>
<!--
    The two ranking functions currently available are:
-->
今のところ、二種類のランキング関数が利用可能です。

    <variablelist>

     <varlistentry>

      <term>
       <indexterm>
        <primary>ts_rank</primary>
       </indexterm>

       <literal>ts_rank(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>) returns <type>float4</></literal>
      </term>

      <listitem>
       <para>
<!--
        Ranks vectors based on the frequency of their matching lexemes.
-->
それらの語彙素にマッチした頻度に基づくベクトルのランク。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>

      <term>
      <indexterm>
       <primary>ts_rank_cd</primary>
      </indexterm>

       <literal>ts_rank_cd(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>) returns <type>float4</></literal>
      </term>

      <listitem>
       <para>
<!--
        This function computes the <firstterm>cover density</firstterm>
        ranking for the given document vector and query, as described in
        Clarke, Cormack, and Tudhope's "Relevance Ranking for One to Three
        Term Queries" in the journal "Information Processing and Management",
        1999.  Cover density is similar to <function>ts_rank</> ranking
        except that the proximity of matching lexemes to each other is
        taken into consideration.
-->
この関数は、1999年の"Information Processing and Management"ジャーナルに掲載されたClarke, Cormack, Tudhopeの"Relevance Ranking for One to Three Term Queries"で述べられている方法で、与えられた文書ベクトルと問合わせの<firstterm>被覆密度(cover density)</firstterm>ランクを計算します。
被覆密度は互いにマッチする語彙素の近接度を考慮に入れる点を除いて<function>ts_rank</>のランク付けと似ています。
       </para>

       <para>
<!--
        This function requires lexeme positional information to perform
        its calculation.  Therefore, it ignores any <quote>stripped</>
        lexemes in the <type>tsvector</>.  If there are no unstripped
        lexemes in the input, the result will be zero.  (See <xref
        linkend="textsearch-manipulate-tsvector"> for more information
        about the <function>strip</> function and positional information
        in <type>tsvector</>s.)
-->
この関数は、計算を実行するために語彙素の位置情報を必要とします。
ですから、<type>tsvector</>内の<quote>剥き出しの</>語彙素は無視します。
入力に剥き出しでない語彙素がなければ、 結果は0です。
(<function>strip</>関数と<type>tsvector</>内の位置情報についてのより詳しい情報は<xref linkend="textsearch-manipulate-tsvector">を参照してください。)
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

   </para>

   <para>
<!--
    For both these functions,
    the optional <replaceable class="PARAMETER">weights</replaceable>
    argument offers the ability to weigh word instances more or less
    heavily depending on how they are labeled.  The weight arrays specify
    how heavily to weigh each category of word, in the order:
-->
これらの関数では、単語がどの程度ラベル付けに依存するかを、単語ごとに指定する機能が<replaceable class="PARAMETER">weights</replaceable>オプションパラメータによって提供されています。
重み配列で、それぞれのカテゴリの単語がどの程度重み付けするかを指定します。その順は以下のようになっています。

<synopsis>
{D-weight, C-weight, B-weight, A-weight}
</synopsis>

<!--
    If no <replaceable class="PARAMETER">weights</replaceable> are provided,
    then these defaults are used:
-->
<replaceable class="PARAMETER">weights</replaceable>を与えない場合は、次のデフォルト値が使われます。

<programlisting>
{0.1, 0.2, 0.4, 1.0}
</programlisting>

<!--
    Typically weights are used to mark words from special areas of the
    document, like the title or an initial abstract, so they can be
    treated with more or less importance than words in the document body.
-->
重みの典型的な使い方は、文書のタイトルやアブストラクトのような特定の場所にある単語をマーク付けするような使い方です。そうすることにより、文書の本体に比べてそこにある単語がより重要なのか、そうでないのか、扱いを変えることができます。
   </para>

   <para>
<!--
    Since a longer document has a greater chance of containing a query term
    it is reasonable to take into account document size, e.g., a hundred-word
    document with five instances of a search word is probably more relevant
    than a thousand-word document with five instances.  Both ranking functions
    take an integer <replaceable>normalization</replaceable> option that
    specifies whether and how a document's length should impact its rank.
    The integer option controls several behaviors, so it is a bit mask:
    you can specify one or more behaviors using
    <literal>|</literal> (for example, <literal>2|4</literal>).
-->
文書が長ければ、それだけ問合わせ用語を含む確率が高くなるため、文書のサイズを考慮にいれることは理にかなっています。たとえば、5つの検索語を含む100語の文書は、たぶん5つの検索語を含む1000語の文書よりも関連性が高いでしょう。ランキング関数には、どちらも整数型の<replaceable>正規化</replaceable>オプションがあります。これは、文書の長さがランクに影響を与えるのかどうか、与えるとすればどの程度か、ということを指定します。この整数オプションは、いくつかの挙動を制御するので、ビットマスクになっています。複数の挙動を<literal>|</literal>で指定できます(例：<literal>2|4</literal>)。

    <itemizedlist  spacing="compact" mark="bullet">
     <listitem>
      <para>
<!--
       0 (the default) ignores the document length
-->
0(デフォルト):文書の長さを無視します
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       1 divides the rank by 1 + the logarithm of the document length
-->
1:ランクを(1 + log(文書の長さ))で割ります
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       2 divides the rank by the document length
-->
2:ランクを文書の長さで割ります
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       4 divides the rank by the mean harmonic distance between extents
       (this is implemented only by <function>ts_rank_cd</>)
-->
4:ランクをエクステントの間の調和平均距離で割ります(これは<function>ts_rank_cd</>のみで実装されています)
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       8 divides the rank by the number of unique words in document
-->
8: ランクを文書中の一意の単語の数で割ります
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       16 divides the rank by 1 + the logarithm of the number
       of unique words in document
-->
16: ランクをlog(文書中の一意の単語の数)+1 で割ります
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       32 divides the rank by itself + 1
-->
32: ランクをランク自身+1 で割ります
      </para>
     </listitem>
    </itemizedlist>

<!--
    If more than one flag bit is specified, the transformations are
    applied in the order listed.
-->
2以上のフラグビットが指定された場合には、変換は上記に列挙された順に行われます。
   </para>

   <para>
<!--
    It is important to note that the ranking functions do not use any global
    information, so it is impossible to produce a fair normalization to 1% or
    100% as sometimes desired.  Normalization option 32
    (<literal>rank/(rank+1)</literal>) can be applied to scale all ranks
    into the range zero to one, but of course this is just a cosmetic change;
    it will not affect the ordering of the search results.
-->
これは重要なことですが、ランキング関数はグローバル情報を一切使わないので、時には必要になる1%から100%までの均一な正規化はできません。正規化オプション32(<literal>rank/(rank+1)</literal>)を適用することにより、すべてのランクを0から1に分布させることができます。しかし、もちろんこれは表面的な変更に過ぎません。検索結果のならび順に影響を与えるものではありません。
   </para>

   <para>
<!--
    Here is an example that selects only the ten highest-ranked matches:
-->
マッチする順位の高い10位までを選ぶ例を示します。

<screen>
SELECT title, ts_rank_cd(textsearch, query) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |   rank
-----------------------------------------------+----------
 Neutrinos in the Sun                          |      3.1
 The Sudbury Neutrino Detector                 |      2.4
 A MACHO View of Galactic Dark Matter          |  2.01317
 Hot Gas and Dark Matter                       |  1.91171
 The Virgo Cluster: Hot Plasma and Dark Matter |  1.90953
 Rafting for Solar Neutrinos                   |      1.9
 NGC 4650A: Strange Galaxy and Dark Matter     |  1.85774
 Hot Gas and Dark Matter                       |   1.6123
 Ice Fishing for Cosmic Neutrinos              |      1.6
 Weak Lensing Distorts the Universe            | 0.818218
</screen>

<!--
    This is the same example using normalized ranking:
-->
同じ例を正規化ランキングを使ったものを示します。

<screen>
SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE  query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |        rank
-----------------------------------------------+-------------------
 Neutrinos in the Sun                          | 0.756097569485493
 The Sudbury Neutrino Detector                 | 0.705882361190954
 A MACHO View of Galactic Dark Matter          | 0.668123210574724
 Hot Gas and Dark Matter                       |  0.65655958650282
 The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973
 Rafting for Solar Neutrinos                   | 0.655172410958162
 NGC 4650A: Strange Galaxy and Dark Matter     | 0.650072921219637
 Hot Gas and Dark Matter                       | 0.617195790024749
 Ice Fishing for Cosmic Neutrinos              | 0.615384618911517
 Weak Lensing Distorts the Universe            | 0.450010798361481
</screen>
   </para>

   <para>
<!--
    Ranking can be expensive since it requires consulting the
    <type>tsvector</type> of each matching document, which can be I/O bound and
    therefore slow. Unfortunately, it is almost impossible to avoid since
    practical queries often result in large numbers of matches.
-->
ランキングは、I/Oに結び付けられていて遅い可能性のある、一致する各文書の<type>tsvector</type>へのアクセスが必要なので、高価な処理であるかもしれません。
不幸なことに、実際の問合わせでは往々にして大量の検索結果が生じるため、これはほとんど不可避であると言えます。
   </para>

  </sect2>

  <sect2 id="textsearch-headline">
<!--
   <title>Highlighting Results</title>
-->
   <title>結果の強調</title>

   <para>
<!--
    To present search results it is ideal to show a part of each document and
    how it is related to the query. Usually, search engines show fragments of
    the document with marked search terms.  <productname>PostgreSQL</>
    provides a function <function>ts_headline</function> that
    implements this functionality.
-->
検索結果を表示する際には、文書の該当部分を表示し、どの程度問合わせと関連しているかを示すのが望ましいです。<productname>PostgreSQL</>はこの機能を実装した<function>ts_headline</function>関数を提供しています。
   </para>

   <indexterm>
    <primary>ts_headline</primary>
   </indexterm>

<synopsis>
ts_headline(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">options</replaceable> <type>text</> </optional>) returns <type>text</>
</synopsis>

   <para>
<!--
    <function>ts_headline</function> accepts a document along
    with a query, and returns an excerpt from
    the document in which terms from the query are highlighted.  The
    configuration to be used to parse the document can be specified by
    <replaceable>config</replaceable>; if <replaceable>config</replaceable>
    is omitted, the
    <varname>default_text_search_config</varname> configuration is used.
-->
<function>ts_headline</function>は、問合わせと一緒に文書を受け取り、問合わせが注目した文書中の語句を抜粋して返します。文書をパースするのに使われる設定を<replaceable>config</replaceable>で指定することができます。<replaceable>config</replaceable>が省略された場合は、<varname>default_text_search_config</varname>設定が使われます。
   </para>

   <para>
<!--
    If an <replaceable>options</replaceable> string is specified it must
    consist of a comma-separated list of one or more
    <replaceable>option</><literal>=</><replaceable>value</> pairs.
    The available options are:
-->
<replaceable>options</replaceable>文字列を指定する場合は、一つ以上の<replaceable>option</><literal>=</><replaceable>value</>のペアをカンマで区切ったものでなければなりません。

    <itemizedlist  spacing="compact" mark="bullet">
     <listitem>
      <para>
<!--
       <literal>StartSel</>, <literal>StopSel</literal>: the strings with
       which to delimit query words appearing in the document, to distinguish
       them from other excerpted words.  You must double-quote these strings
       if they contain spaces or commas.
-->
<literal>StartSel</>, <literal>StopSel</literal>: 文書中に現れる問合わせ単語を区切るこの文字列は、他の抜粋される単語と区別されます。これらの文字列が空白やカンマを含んでいる場合は、二重引用符で囲う必要があります。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>MaxWords</>, <literal>MinWords</literal>: these numbers
       determine the longest and shortest headlines to output.
-->
<literal>MaxWords</>, <literal>MinWords</literal>: この数字を使って見出しの最大の長さと最小の長さを指定します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>ShortWord</literal>: words of this length or less will be
       dropped at the start and end of a headline. The default
       value of three eliminates common English articles.
-->
<literal>ShortWord</literal>: この長さか、それ以下の長さの単語は、見出しの最初と最後から削除されます。デフォルト値の3は、常用される英語の冠詞を取り除きます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>HighlightAll</literal>: Boolean flag;  if
       <literal>true</literal> the whole document will be used as the
       headline, ignoring the preceding three parameters.
-->
<literal>HighlightAll</literal>: 論理値フラグ; <literal>true</literal>なら文書全体が見出しの様にハイライトされ、前の3つのパラメータは無視されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>MaxFragments</literal>: maximum number of text excerpts
       or fragments to display.  The default value of zero selects a
       non-fragment-oriented headline generation method.  A value greater than
       zero selects fragment-based headline generation.  This method
       finds text fragments with as many query words as possible and
       stretches those fragments around the query words.  As a result
       query words are close to the middle of each fragment and have words on
       each side. Each fragment will be of at most <literal>MaxWords</> and
       words of length <literal>ShortWord</> or less are dropped at the start
       and end of each fragment. If not all query words are found in the
       document, then a single fragment of the first <literal>MinWords</>
       in the document will be displayed.
-->
<literal>MaxFragments</literal>:表示するテキスト引用句、もしくは断片の最大数です。デフォルト値の0は断片化を起こさない見出しの生成の選択となります。0より大きい場合は断片化を基本とした見出しの生成の選択となります。この方法は、可能な限り多くの検索単語でテキスト断片を探し出し、検索単語周辺のそれらのテキスト断片を広げます。結果として、検索単語が各断片の中央部分近くに位置し、両端に単語を持つことになります。各断片は最大で<literal>MaxWords</>と同数の単語を持ち、<literal>ShortWord</>より少ないサイズの単語を断片の両端に持ちません。もし全ての検索単語を文書から見つけられなかった場合は、文書中の最初の<literal>MinWords</>分の単語数から成る一つの断片が表示されるでしょう。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>FragmentDelimiter</literal>: When more than one fragment is
       displayed, the fragments will be separated by this string.
-->
<literal>FragmentDelimiter</literal>: 複数の断片が表示される時、その断片はこの文字で区切られます。
      </para>
     </listitem>
    </itemizedlist>

<!--
    Any unspecified options receive these defaults:
-->
指定されなかったオプションの値は以下のデフォルトになります。

<programlisting>
StartSel=&lt;b&gt;, StopSel=&lt;/b&gt;,
MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,
MaxFragments=0, FragmentDelimiter=" ... "
</programlisting>
   </para>

   <para>
<!--
    For example:
-->
例を示します。

<screen>
SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('query &amp; similarity'));
                        ts_headline                         
------------------------------------------------------------
 containing given &lt;b&gt;query&lt;/b&gt; terms
 and return them in order of their &lt;b&gt;similarity&lt;/b&gt; to the
 &lt;b&gt;query&lt;/b&gt;.

SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('query &amp; similarity'),
  'StartSel = &lt;, StopSel = &gt;');
                      ts_headline                      
-------------------------------------------------------
 containing given &lt;query&gt; terms
 and return them in order of their &lt;similarity&gt; to the
 &lt;query&gt;.
</screen>
   </para>

   <para>
<!--
    <function>ts_headline</> uses the original document, not a
    <type>tsvector</type> summary, so it can be slow and should be used with
    care.  A typical mistake is to call <function>ts_headline</function> for
    <emphasis>every</emphasis> matching document when only ten documents are
    to be shown. <acronym>SQL</acronym> subqueries can help; here is an
    example:
-->
<function>ts_headline</>は、<type>tsvector</type>の要約ではなく、元の文書を使います。ですので遅い可能性があり、注意深く使用する必要があります。よくある間違いは、たった10個の文書を表示しようとしているのに、<emphasis>すべての</emphasis>合致した文書に<function>ts_headline</function>を適用することです。<acronym>SQL</acronym>の副問合わせがこのときに役に立ちます。例を示します。

<programlisting>
SELECT id, ts_headline(body, q), rank
FROM (SELECT id, body, q, ts_rank_cd(ti, q) AS rank
      FROM apod, to_tsquery('stars') q
      WHERE ti @@ q
      ORDER BY rank DESC
      LIMIT 10) AS foo;
</programlisting>
   </para>

  </sect2>

 </sect1>

 <sect1 id="textsearch-features">
<!--
  <title>Additional Features</title>
-->
  <title>追加機能</title>

  <para>
<!--
   This section describes additional functions and operators that are
   useful in connection with text search.
-->
この節では、全文検索に関連する便利な追加の関数と演算子を説明します。
  </para>

  <sect2 id="textsearch-manipulate-tsvector">
<!--
   <title>Manipulating Documents</title>
-->
   <title>文書の操作</title>

   <para>
<!--
    <xref linkend="textsearch-parsing-documents"> showed how raw textual
    documents can be converted into <type>tsvector</> values.
    <productname>PostgreSQL</productname> also provides functions and
    operators that can be used to manipulate documents that are already
    in <type>tsvector</> form.
-->
<xref linkend="textsearch-parsing-documents">に、もとのテキスト形式の文書がどのようにして<type>tsvector</>に変換されるのか書いてあります。また、<productname>PostgreSQL</productname>では<type>tsvector</>形式に変換済の文書を操作する関数と演算子が提供されています。
   </para>

   <variablelist>

    <varlistentry>

     <term>
     <indexterm>
      <primary>tsvector concatenation</primary>
     </indexterm>

      <literal><type>tsvector</> || <type>tsvector</></literal>
     </term>

     <listitem>
      <para>
<!--
       The <type>tsvector</> concatenation operator
       returns a vector which combines the lexemes and positional information
       of the two vectors given as arguments.  Positions and weight labels
       are retained during the concatenation.
       Positions appearing in the right-hand vector are offset by the largest
       position mentioned in the left-hand vector, so that the result is
       nearly equivalent to the result of performing <function>to_tsvector</>
       on the concatenation of the two original document strings.  (The
       equivalence is not exact, because any stop-words removed from the
       end of the left-hand argument will not affect the result, whereas
       they would have affected the positions of the lexemes in the
       right-hand argument if textual concatenation were used.)
-->
<type>tsvector</>の結合演算子で、2つのベクトルの語彙素と位置情報を合成し、<type>tsvector</>を返します。右辺のベクトルの位置は左辺のベクトルの一番大きな位置情報のオフセットになります。その結果、この関数の結果は、元の文書を結合したものに<function>to_tsvector</>を適用したものとほぼ同じになります(まったく同じと言うわけではありません。左辺の引数の最後の位置にあるストップワードは取り除かれるのに対し、テキストの結合が行われた場合は、その影響が右辺の引数にある語彙素位置に影響を与えるからです)。
      </para>

      <para>
<!--
       One advantage of using concatenation in the vector form, rather than
       concatenating text before applying <function>to_tsvector</>, is that
       you can use different configurations to parse different sections
       of the document.  Also, because the <function>setweight</> function
       marks all lexemes of the given vector the same way, it is necessary
       to parse the text and do <function>setweight</> before concatenating
       if you want to label different parts of the document with different
       weights.
-->
<function>to_tsvector</>を適用する前のテキストを結合するよりも、ベクトルを結合することの利点の一つは、文書の異なる部分をパースするために、異なる設定を使うことができることです。なお、<function>setweight</>関数は与えられたベクトルのすべての語彙素を同じ方法でマーク付けするため、もしも文書に異なる部分に別の重み付けを行いたいなら、結合する前に文書をパースして<function>setweight</>を適用することが必要です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>

     <term>
     <indexterm>
      <primary>setweight</primary>
     </indexterm>

      <literal>setweight(<replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">weight</replaceable> <type>"char"</>) returns <type>tsvector</></literal>
     </term>

     <listitem>
      <para>
<!--
       <function>setweight</> returns a copy of the input vector in which every
       position has been labeled with the given <replaceable>weight</>, either
       <literal>A</literal>, <literal>B</literal>, <literal>C</literal>, or
       <literal>D</literal>.  (<literal>D</literal> is the default for new
       vectors and as such is not displayed on output.)  These labels are
       retained when vectors are concatenated, allowing words from different
       parts of a document to be weighted differently by ranking functions.
-->
<function>setweight</>は、<literal>A</literal>, <literal>B</literal>, <literal>C</literal>, <literal>D</literal>のいずれかの与えられた<replaceable>weight</>を入力のベクトル中の位置にラベル付けし、そのコピーを返します。
(<literal>D</literal>は新しいベクトルのデフォルトで、出力する際には表示されません。)
これらのラベルはベクトルが結合される際に保存されるので、ランキング関数によって文書中の異なる部分の語を別々に重み付けできます。
      </para>

      <para>
<!--
       Note that weight labels apply to <emphasis>positions</>, not
       <emphasis>lexemes</>.  If the input vector has been stripped of
       positions then <function>setweight</> does nothing.
-->
なお、重み付けラベルは<emphasis>語彙素</>ではなく<emphasis>位置</>に与えられることに注意してください。
入力のベクトルから位置が削除されていると、<function>setweight</>は何もしません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
     <indexterm>
      <primary>length(tsvector)</primary>
     </indexterm>

      <literal>length(<replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>) returns <type>integer</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of lexemes stored in the vector.
-->
ベクトル中に格納されている語彙素の数を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>

     <term>
     <indexterm>
      <primary>strip</primary>
     </indexterm>

      <literal>strip(<replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>) returns <type>tsvector</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns a vector which lists the same lexemes as the given vector, but
       which lacks any position or weight information.  While the returned
       vector is much less useful than an unstripped vector for relevance
       ranking, it will usually be much smaller.
-->
位置、重みの情報がないことを除けば入力のベクトルと同じ語彙素のリストを持つベクトルを返します。返却されたベクトルは、情報を削除されていないベクトルに比べてランキングに関しては、ずっと有用性が低くなりますが、通常非常に小さくなります。
      </para>
     </listitem>

    </varlistentry>

   </variablelist>

  </sect2>

  <sect2 id="textsearch-manipulate-tsquery">
<!--
   <title>Manipulating Queries</title>
-->
   <title>問合わせを操作する</title>

   <para>
<!--
    <xref linkend="textsearch-parsing-queries"> showed how raw textual
    queries can be converted into <type>tsquery</> values.
    <productname>PostgreSQL</productname> also provides functions and
    operators that can be used to manipulate queries that are already
    in <type>tsquery</> form.
-->
<xref linkend="textsearch-parsing-queries">は、元のテキストがいかにして<type>tsquery</>値に変換されるかを解説しています。また<productname>PostgreSQL</productname>は、<type>tsquery</>形式に変換済の問合わせを操作するために使用できる関数と演算子を提供しています。
   </para>

   <variablelist>

    <varlistentry>

     <term>
      <literal><type>tsquery</> &amp;&amp; <type>tsquery</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns the AND-combination of the two given queries.
-->
2つの問合わせをANDで結合したものを返します。
      </para>
     </listitem>

    </varlistentry>

    <varlistentry>

     <term>
      <literal><type>tsquery</> || <type>tsquery</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns the OR-combination of the two given queries.
-->
2つの問合わせをORで結合したものを返します。
      </para>
     </listitem>

    </varlistentry>

    <varlistentry>

     <term>
      <literal>!! <type>tsquery</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns the negation (NOT) of the given query.
-->
与えられた問合わせの否定を返します。
      </para>
     </listitem>

    </varlistentry>

    <varlistentry>

     <term>
     <indexterm>
      <primary>numnode</primary>
     </indexterm>

      <literal>numnode(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>) returns <type>integer</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of nodes (lexemes plus operators) in a
       <type>tsquery</>. This function is useful
       to determine if the <replaceable>query</replaceable> is meaningful
       (returns &gt; 0), or contains only stop words (returns 0).
       Examples:
-->
<type>tsquery</>中のノード(語彙素と演算子)の数を返します。この関数は、<replaceable>問合わせ</replaceable>が意味のあるものか(返却値 &gt; 0)、ストップワードだけを含んでいるか(返却値 0)を判断するのに役に立ちます。例を示します。

<screen>
SELECT numnode(plainto_tsquery('the any'));
NOTICE:  query contains only stopword(s) or doesn't contain lexeme(s), ignored
 numnode
---------
       0

SELECT numnode('foo &amp; bar'::tsquery);
 numnode
---------
       3
</screen>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>

     <term>
     <indexterm>
      <primary>querytree</primary>
     </indexterm>

      <literal>querytree(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>) returns <type>text</></literal>
     </term>

     <listitem>
      <para>
<!--
       Returns the portion of a <type>tsquery</> that can be used for
       searching an index.  This function is useful for detecting
       unindexable queries, for example those containing only stop words
       or only negated terms.  For example:
-->
インデックス検索の際に使用できる<type>tsquery</>の部分を返します。この関数は、たとえばストップワードのみ、あるいは否定語だけのように、インデックス検索できない問合わせを検出するのに役立ちます。例を示します。

<screen>
SELECT querytree(to_tsquery('!defined'));
 querytree
-----------

</screen>
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

   <sect3 id="textsearch-query-rewriting">
<!--
    <title>Query Rewriting</title>
-->
    <title>問合わせの書き換え</title>

    <indexterm zone="textsearch-query-rewriting">
     <primary>ts_rewrite</primary>
    </indexterm>

    <para>
<!--
     The <function>ts_rewrite</function> family of functions search a
     given <type>tsquery</> for occurrences of a target
     subquery, and replace each occurrence with a
     substitute subquery.  In essence this operation is a
     <type>tsquery</>-specific version of substring replacement.
     A target and substitute combination can be
     thought of as a <firstterm>query rewrite rule</>.  A collection
     of such rewrite rules can be a powerful search aid.
     For example, you can expand the search using synonyms
     (e.g., <literal>new york</>, <literal>big apple</>, <literal>nyc</>,
     <literal>gotham</>) or narrow the search to direct the user to some hot
     topic.  There is some overlap in functionality between this feature
     and thesaurus dictionaries (<xref linkend="textsearch-thesaurus">).
     However, you can modify a set of rewrite rules on-the-fly without
     reindexing, whereas updating a thesaurus requires reindexing to be
     effective.
-->
<function>ts_rewrite</function>ファミリー関数は、与えられた<type>tsquery</>から目的の副問合わせ部分を探し、それを代わりの副問い合わせに置き換えます。本質的には、この操作は、部分文字列置き換えの<type>tsquery</>版です。置き換え候補と置き換え内容の組は、<firstterm>問合わせ書き換えルール</>であると考えることができます。そのような書き換えルールの集合は、強力な検索ツールとなり得ます。たとえば、同義語(たとえば<literal>new york</>, <literal>big apple</>, <literal>nyc</>, <literal>gotham</>)を使って問合わせをより広範囲にしたり、逆によりホットな話題にユーザを導くために問合わせを狭い範囲に絞ったりすることができます。この機能と、同義語辞書(<xref linkend="textsearch-thesaurus">)の間には、機能的な重複があります。しかし、再インデックス付けすることなしに、その場で書き換えルールを変更できるのに対し、同義語辞書の更新が有効になるためには、再インデックス付けを行わなければなりません。
    </para>

    <variablelist>

     <varlistentry>

      <term>
       <literal>ts_rewrite (<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">target</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">substitute</replaceable> <type>tsquery</>) returns <type>tsquery</></literal>
      </term>

      <listitem>
       <para>
<!--
        This form of <function>ts_rewrite</> simply applies a single
        rewrite rule: <replaceable class="PARAMETER">target</replaceable>
        is replaced by <replaceable class="PARAMETER">substitute</replaceable>
        wherever it appears in <replaceable
        class="PARAMETER">query</replaceable>.  For example:
-->
この形式の <function>ts_rewrite</> は、単純に単一の書き換えルールを適用します。<replaceable class="PARAMETER">query</replaceable>中に表れる<replaceable class="PARAMETER">target</replaceable>は、<replaceable class="PARAMETER">substitute</replaceable>ですべて置き換えられます。例を示します。

<screen>
SELECT ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'c'::tsquery);
 ts_rewrite
------------
 'b' &amp; 'c'
</screen>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>

      <term>
       <literal>ts_rewrite (<replaceable class="PARAMETER">query</> <type>tsquery</>, <replaceable class="PARAMETER">select</> <type>text</>) returns <type>tsquery</></literal>
      </term>

      <listitem>
       <para>
<!--
        This form of <function>ts_rewrite</> accepts a starting
        <replaceable>query</> and a SQL <replaceable>select</> command, which
        is given as a text string.  The <replaceable>select</> must yield two
        columns of <type>tsquery</> type.  For each row of the
        <replaceable>select</> result, occurrences of the first column value
        (the target) are replaced by the second column value (the substitute)
        within the current <replaceable>query</> value.  For example:
-->
この形式の<function>ts_rewrite</>は、開始<replaceable>問合わせ</>と、テキスト文字列で与えられるSQLの<replaceable>SELECT</>コマンドを受け取ります。<replaceable>SELECT</>は、<type>tsquery</>型の2つの列を出力しなければなりません。現在の<replaceable>問合わせ</>は、<replaceable>SELECT</>のそれぞれの結果行中の最初の列の結果(ターゲット)が、2番目の列の結果(置き換え値)に、置き換えられます。例を示します。

<screen>
CREATE TABLE aliases (t tsquery PRIMARY KEY, s tsquery);
INSERT INTO aliases VALUES('a', 'c');

SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases');
 ts_rewrite
------------
 'b' &amp; 'c'
</screen>
       </para>

       <para>
<!--
        Note that when multiple rewrite rules are applied in this way,
        the order of application can be important; so in practice you will
        want the source query to <literal>ORDER BY</> some ordering key.
-->
なお、複数の書き換えルールを適用する際は、適用する順番が重要です。ですから、実際には並び替えのキーを適用する<literal>ORDER BY</>を問合わせに入れておくのがよいでしょう。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    <para>
<!--
     Let's consider a real-life astronomical example. We'll expand query
     <literal>supernovae</literal> using table-driven rewriting rules:
-->
天文学上の実際的な例を考えてみます。テーブル駆動の書き換えルールを使って、<literal>supernovae</literal>を展開します。

<screen>
CREATE TABLE aliases (t tsquery primary key, s tsquery);
INSERT INTO aliases VALUES(to_tsquery('supernovae'), to_tsquery('supernovae|sn'));

SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM aliases');
           ts_rewrite            
---------------------------------
 'crab' &amp; ( 'supernova' | 'sn' )
</screen>

<!--
     We can change the rewriting rules just by updating the table:
-->
テーブルを更新するだけで、書き換えルールを変更することができます。

<screen>
UPDATE aliases
SET s = to_tsquery('supernovae|sn &amp; !nebulae')
WHERE t = to_tsquery('supernovae');

SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM aliases');
                 ts_rewrite                  
---------------------------------------------
 'crab' &amp; ( 'supernova' | 'sn' &amp; !'nebula' )
</screen>
    </para>

    <para>
<!--
     Rewriting can be slow when there are many rewriting rules, since it
     checks every rule for a possible match. To filter out obvious non-candidate
     rules we can use the containment operators for the <type>tsquery</type>
     type. In the example below, we select only those rules which might match
     the original query:
-->
書き換えルールが多くなると、書き換えが遅くなる可能性があります。なぜなら、書き換えの対象になるものを求めて、すべてのルールをチェックするからです。明らかに使われないルールを取り除くために、<type>tsquery</type>の包含演算子を使うことができます。以下の例では、元の問合わせにマッチするルールだけを選ぶことができます。

<screen>
SELECT ts_rewrite('a &amp; b'::tsquery,
                  'SELECT t,s FROM aliases WHERE ''a &amp; b''::tsquery @&gt; t');
 ts_rewrite
------------
 'b' &amp; 'c'
</screen>
    </para>

   </sect3>

  </sect2>

  <sect2 id="textsearch-update-triggers">
<!--
   <title>Triggers for Automatic Updates</title>
-->
   <title>自動更新のためのトリガ</title>

   <indexterm>
<!--
    <primary>trigger</primary>
    <secondary>for updating a derived tsvector column</secondary>
-->
    <primary>トリガ</primary>
    <secondary>tsvectorから派生した列を更新する</secondary>
   </indexterm>

   <para>
<!--
    When using a separate column to store the <type>tsvector</> representation
    of your documents, it is necessary to create a trigger to update the
    <type>tsvector</> column when the document content columns change.
    Two built-in trigger functions are available for this, or you can write
    your own.
-->
<type>tsvector</>形式の文書を格納するために別の列を使う場合、文書の内容を格納した列が変更されたときに<type>tsvector</>を格納した列を更新するトリガを作っておく必要があります。この目的のために、2つの組み込み関数を利用できます。自分で関数を書くこともできます。
   </para>

<synopsis>
tsvector_update_trigger(<replaceable class="PARAMETER">tsvector_column_name</replaceable>, <replaceable class="PARAMETER">config_name</replaceable>, <replaceable class="PARAMETER">text_column_name</replaceable> <optional>, ... </optional>)
tsvector_update_trigger_column(<replaceable class="PARAMETER">tsvector_column_name</replaceable>, <replaceable class="PARAMETER">config_column_name</replaceable>, <replaceable class="PARAMETER">text_column_name</replaceable> <optional>, ... </optional>)
</synopsis>

   <para>
<!--
    These trigger functions automatically compute a <type>tsvector</>
    column from one or more textual columns, under the control of
    parameters specified in the <command>CREATE TRIGGER</> command.
    An example of their use is:
-->
これらのトリガ関数は、1つ以上のテキスト列から、<command>CREATE TRIGGER</>コマンドで指定されたパラメータの制御により、<type>tsvector</>列を自動的に計算します。使い方の例を示します。

<screen>
CREATE TABLE messages (
    title       text,
    body        text,
    tsv         tsvector
);

CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
ON messages FOR EACH ROW EXECUTE PROCEDURE
tsvector_update_trigger(tsv, 'pg_catalog.english', title, body);

INSERT INTO messages VALUES('title here', 'the body text is here');

SELECT * FROM messages;
   title    |         body          |            tsv             
------------+-----------------------+----------------------------
 title here | the body text is here | 'bodi':4 'text':5 'titl':1

SELECT title, body FROM messages WHERE tsv @@ to_tsquery('title &amp; body');
   title    |         body          
------------+-----------------------
 title here | the body text is here
</screen>

<!--
    Having created this trigger, any change in <structfield>title</> or
    <structfield>body</> will automatically be reflected into
    <structfield>tsv</>, without the application having to worry about it.
-->
このトリガを作っておくことにより、 <structfield>title</> または<structfield>body</>への変更は、アプリケーションで考慮しなくても自動的に<structfield>tsv</>に反映されます。
   </para>

   <para>
<!--
    The first trigger argument must be the name of the <type>tsvector</>
    column to be updated.  The second argument specifies the text search
    configuration to be used to perform the conversion.  For
    <function>tsvector_update_trigger</>, the configuration name is simply
    given as the second trigger argument.  It must be schema-qualified as
    shown above, so that the trigger behavior will not change with changes
    in <varname>search_path</>.  For
    <function>tsvector_update_trigger_column</>, the second trigger argument
    is the name of another table column, which must be of type
    <type>regconfig</>.  This allows a per-row selection of configuration
    to be made.  The remaining argument(s) are the names of textual columns
    (of type <type>text</>, <type>varchar</>, or <type>char</>).  These
    will be included in the document in the order given.  NULL values will
    be skipped (but the other columns will still be indexed).
-->
トリガの最初の引数は更新対象の<type>tsvector</>の列名でなければなりません。2番目の引数は、変換を実行する際に使用されるテキスト検索の設定です。<function>tsvector_update_trigger</>では、設定の名前は単に2番目のトリガ引数で与えられます。上で示すように、スキーマ修飾されていなければなりません。<varname>search_path</>の変更がトリガの振る舞いに影響を与えないためです。<function>tsvector_update_trigger_column</>では、2番目のトリガ引数は別のテーブル列の列名です。この列の型は<type>regconfig</>でなければなりません。この方法により、設定を行単位で変えることができます。残りの引数はテキスト型(<type>text</>, <type>varchar</>, <type>char</>のいずれか)の列の名前です。与えられた順に、文書中に取り込まれます。NULL値はスキップされます(ただし、それ以外の列はインデックス付けされます)。
   </para>

   <para>
<!--
    A limitation of these built-in triggers is that they treat all the
    input columns alike.  To process columns differently &mdash; for
    example, to weight title differently from body &mdash; it is necessary
    to write a custom trigger.  Here is an example using
    <application>PL/pgSQL</application> as the trigger language:
-->
これらの組み込みトリガの制限事項として、すべての列を同じようにしか扱えないというものがあります。それぞれの列を違うように扱うには &mdash; たとえば本文とタイトルの重みを変えるとか &mdash;、カスタムトリガを書く必要があります。トリガ言語として<application>PL/pgSQL</application>を使った例を示します。

<programlisting>
CREATE FUNCTION messages_trigger() RETURNS trigger AS $$
begin
  new.tsv :=
     setweight(to_tsvector('pg_catalog.english', coalesce(new.title,'')), 'A') ||
     setweight(to_tsvector('pg_catalog.english', coalesce(new.body,'')), 'D');
  return new;
end
$$ LANGUAGE plpgsql;

CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
    ON messages FOR EACH ROW EXECUTE PROCEDURE messages_trigger();
</programlisting>
   </para>

   <para>
<!--
    Keep in mind that it is important to specify the configuration name
    explicitly when creating <type>tsvector</> values inside triggers,
    so that the column's contents will not be affected by changes to
    <varname>default_text_search_config</>.  Failure to do this is likely to
    lead to problems such as search results changing after a dump and reload.
-->
<type>tsvector</>値をトリガ内で作るときには、設定名を明示的に与えることが重要であることを銘記しておいてください。そうすれば、<varname>default_text_search_config</>が変更されても列の内容は影響を受けません。これを怠ると、ダンプしてリロードすると検索結果が変わってしまうような問題が起きる可能性があります。
   </para>

  </sect2>

  <sect2 id="textsearch-statistics">
<!--
   <title>Gathering Document Statistics</title>
-->
   <title>文書の統計情報の収集</title>

   <indexterm>
    <primary>ts_stat</primary>
   </indexterm>

   <para>
<!--
    The function <function>ts_stat</> is useful for checking your
    configuration and for finding stop-word candidates.
-->
<function>ts_stat</>関数は、設定をチェックしたり、ストップワードの候補を探すのに役立ちます。
   </para>

<synopsis>
ts_stat(<replaceable class="PARAMETER">sqlquery</replaceable> <type>text</>, <optional> <replaceable class="PARAMETER">weights</replaceable> <type>text</>, </optional>
        OUT <replaceable class="PARAMETER">word</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">ndoc</replaceable> <type>integer</>,
        OUT <replaceable class="PARAMETER">nentry</replaceable> <type>integer</>) returns <type>setof record</>
</synopsis>

   <para>
<!--
    <replaceable>sqlquery</replaceable> is a text value containing an SQL
    query which must return a single <type>tsvector</type> column.
    <function>ts_stat</> executes the query and returns statistics about
    each distinct lexeme (word) contained in the <type>tsvector</type>
    data.  The columns returned are
-->
<replaceable>sqlquery</replaceable>は単一の<type>tsvector</type>列を返すSQL問合わせのテキスト値です。<function>ts_stat</>は問合わせを実行し、<type>tsvector</type>データに含まれる語彙素(単語)各々の統計情報を返します。返却される列は以下のものです。

    <itemizedlist  spacing="compact" mark="bullet">
     <listitem>
      <para>
<!--
       <replaceable>word</> <type>text</> &mdash; the value of a lexeme
-->
<replaceable>word</> <type>text</> &mdash; 語彙素の値
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>ndoc</> <type>integer</> &mdash; number of documents
       (<type>tsvector</>s) the word occurred in
-->
<replaceable>ndoc</> <type>integer</> &mdash; 単語が含まれる文書(<type>tsvector</>)の数
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>nentry</> <type>integer</> &mdash; total number of
       occurrences of the word
-->
<replaceable>nentry</> <type>integer</> &mdash; 含まれる単語の数
      </para>
     </listitem>
    </itemizedlist>

<!--
    If <replaceable>weights</replaceable> is supplied, only occurrences
    having one of those weights are counted.
-->
<replaceable>weights</replaceable>が与えられていたら、その重みを持つものだけがカウントされます。
   </para>

   <para>
<!--
    For example, to find the ten most frequent words in a document collection:
-->
たとえば、文書中もっとも頻繁に現れる単語の上位10位を探すには以下のようにします。

<programlisting>
SELECT * FROM ts_stat('SELECT vector FROM apod')
ORDER BY nentry DESC, ndoc DESC, word
LIMIT 10;
</programlisting>

<!--
    The same, but counting only word occurrences with weight <literal>A</>
    or <literal>B</>:
-->
同じ例で、重みが<literal>A</>か<literal>B</>の単語だけをカウントするには、以下のようにします。

<programlisting>
SELECT * FROM ts_stat('SELECT vector FROM apod', 'ab')
ORDER BY nentry DESC, ndoc DESC, word
LIMIT 10;
</programlisting>
   </para>

  </sect2>

 </sect1>

 <sect1 id="textsearch-parsers">
<!--
  <title>Parsers</title>
-->
  <title>パーサ</title>

  <para>
<!--
   Text search parsers are responsible for splitting raw document text
   into <firstterm>tokens</> and identifying each token's type, where
   the set of possible types is defined by the parser itself.
   Note that a parser does not modify the text at all &mdash; it simply
   identifies plausible word boundaries.  Because of this limited scope,
   there is less need for application-specific custom parsers than there is
   for custom dictionaries.  At present <productname>PostgreSQL</productname>
   provides just one built-in parser, which has been found to be useful for a
   wide range of applications.
-->
テキスト検索パーサは、もとの文書テキストを分割して<firstterm>トークン</>に変換し、それぞれのトークンの型を識別子する役割を持っています。ここで、可能な型の集合は、パーサ自身が定義します。パーサは文書をまったく変更しないことに注意してください &mdash; それは、単に可能な単語の境界を識別するだけです。このような制限があるため、カスタム辞書を作るのに比べ、用途限定のカスタムパーサを作る必要性は少ないです。今のところ、<productname>PostgreSQL</productname>はたった一つの組み込みパーサを提供しています。これは広い範囲の用途に対して有用であると考えられています。
  </para>

  <para>
<!--
   The built-in parser is named <literal>pg_catalog.default</>.
   It recognizes 23 token types, shown in <xref linkend="textsearch-default-parser">.
-->
組み込みのパーサは<literal>pg_catalog.default</>というものです。<xref linkend="textsearch-default-parser">に示す23のトークンを理解します。
  </para>

  <table id="textsearch-default-parser">
<!--
   <title>Default Parser's Token Types</title>
-->
   <title>デフォルトパーサのトークン型</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Alias</entry>
      <entry>Description</entry>
      <entry>Example</entry>
-->
      <entry>別名</entry>
      <entry>説明</entry>
      <entry>例</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>asciiword</></entry>
<!--
      <entry>Word, all ASCII letters</entry>
-->
      <entry>単語、すべてのASCII文字</entry>
      <entry><literal>elephant</literal></entry>
     </row>
     <row>
      <entry><literal>word</></entry>
<!--
      <entry>Word, all letters</entry>
-->
      <entry>単語、すべての文字</entry>
      <entry><literal>ma&ntilde;ana</literal></entry>
     </row>
     <row>
      <entry><literal>numword</></entry>
<!--
      <entry>Word, letters and digits</entry>
-->
      <entry>単語、文字、数字</entry>
      <entry><literal>beta1</literal></entry>
     </row>
     <row>
      <entry><literal>asciihword</></entry>
<!--
      <entry>Hyphenated word, all ASCII</entry>
-->
      <entry>ハイフンでつながれた単語、すべてのASCII</entry>
      <entry><literal>up-to-date</literal></entry>
     </row>
     <row>
      <entry><literal>hword</></entry>
<!--
      <entry>Hyphenated word, all letters</entry>
-->
      <entry>ハイフンでつながれた単語、すべての文字</entry>
      <entry><literal>l&oacute;gico-matem&aacute;tica</literal></entry>
     </row>
     <row>
      <entry><literal>numhword</></entry>
<!--
      <entry>Hyphenated word, letters and digits</entry>
-->
      <entry>ハイフンでつながれた単語、すべての文字、数字</entry>
      <entry><literal>postgresql-beta1</literal></entry>
     </row>
     <row>
      <entry><literal>hword_asciipart</></entry>
<!--
      <entry>Hyphenated word part, all ASCII</entry>
      <entry><literal>postgresql</literal> in the context <literal>postgresql-beta1</literal></entry>
-->
      <entry>ハイフンでつながれた単語の一部、すべての ASCII</entry>
      <entry><literal>postgresql-beta1</literal>の<literal>postgresql</literal></entry>
     </row>
     <row>
      <entry><literal>hword_part</></entry>
<!--
      <entry>Hyphenated word part, all letters</entry>
      <entry><literal>l&oacute;gico</literal> or <literal>matem&aacute;tica</literal>
       in the context <literal>l&oacute;gico-matem&aacute;tica</literal></entry>
-->
      <entry>ハイフンでつながれた単語の一部、すべての文字</entry>
      <entry><literal>l&oacute;gico-matem&aacute;tica</literal>の<literal>l&oacute;gico</literal>または<literal>matem&aacute;tica</literal></entry>
     </row>
     <row>
      <entry><literal>hword_numpart</></entry>
<!--
      <entry>Hyphenated word part, letters and digits</entry>
      <entry><literal>beta1</literal> in the context
       <literal>postgresql-beta1</literal></entry>
-->
      <entry>ハイフンでつながれた単語の文字+数字の部分</entry>
      <entry><literal>postgresql-beta1</literal>の<literal>beta1</literal></entry>
     </row>
     <row>
      <entry><literal>email</></entry>
<!--
      <entry>Email address</entry>
-->
      <entry>電子メールアドレス</entry>
      <entry><literal>foo@example.com</literal></entry>
     </row>
     <row>
      <entry><literal>protocol</></entry>
<!--
      <entry>Protocol head</entry>
-->
      <entry>プロトコルヘッダー</entry>
      <entry><literal>http://</literal></entry>
     </row>
     <row>
      <entry><literal>url</></entry>
      <entry>URL</entry>
      <entry><literal>example.com/stuff/index.html</literal></entry>
     </row>
     <row>
      <entry><literal>host</></entry>
<!--
      <entry>Host</entry>
-->
      <entry>ホスト名</entry>
      <entry><literal>example.com</literal></entry>
     </row>
     <row>
      <entry><literal>url_path</></entry>
<!--
      <entry>URL path</entry>
      <entry><literal>/stuff/index.html</literal>, in the context of a URL</entry>
-->
      <entry>URL中のパス名</entry>
      <entry>URL中の<literal>/stuff/index.html</literal></entry>
     </row>
     <row>
      <entry><literal>file</></entry>
<!--
      <entry>File or path name</entry>
      <entry><literal>/usr/local/foo.txt</literal>, if not within a URL</entry>
-->
      <entry>ファイルまたはパス名</entry>
      <entry>URL中でない<literal>/usr/local/foo.txt</literal></entry>
     </row>
     <row>
      <entry><literal>sfloat</></entry>
<!--
      <entry>Scientific notation</entry>
-->
      <entry>科学技術表記</entry>
      <entry><literal>-1.234e56</literal></entry>
     </row>
     <row>
      <entry><literal>float</></entry>
<!--
      <entry>Decimal notation</entry>
-->
      <entry>10進表記</entry>
      <entry><literal>-1.234</literal></entry>
     </row>
     <row>
      <entry><literal>int</></entry>
<!--
      <entry>Signed integer</entry>
-->
      <entry>符号付き整数</entry>
      <entry><literal>-1234</literal></entry>
     </row>
     <row>
      <entry><literal>uint</></entry>
<!--
      <entry>Unsigned integer</entry>
-->
      <entry>符号なし整数</entry>
      <entry><literal>1234</literal></entry>
     </row>
     <row>
      <entry><literal>version</></entry>
<!--
      <entry>Version number</entry>
-->
      <entry>バージョン番号</entry>
      <entry><literal>8.3.0</literal></entry>
     </row>
     <row>
      <entry><literal>tag</></entry>
<!--
      <entry>XML tag</entry>
-->
      <entry>XMLタグ</entry>
      <entry><literal>&lt;a href="dictionaries.html"&gt;</literal></entry>
     </row>
     <row>
      <entry><literal>entity</></entry>
<!--
      <entry>XML entity</entry>
-->
      <entry>XMLエンティティ</entry>
      <entry><literal>&amp;amp;</literal></entry>
     </row>
     <row>
      <entry><literal>blank</></entry>
<!--
      <entry>Space symbols</entry>
      <entry>(any whitespace or punctuation not otherwise recognized)</entry>
-->
      <entry>空白記号</entry>
      <entry>(他のものに解釈できない空白または句読点)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
<!--
    The parser's notion of a <quote>letter</> is determined by the database's
    locale setting, specifically <varname>lc_ctype</>.  Words containing
    only the basic ASCII letters are reported as a separate token type,
    since it is sometimes useful to distinguish them.  In most European
    languages, token types <literal>word</> and <literal>asciiword</>
    should be treated alike.
-->
パーサにとっての<quote>文字</>は、データベースのロケールの設定、特に<varname>lc_ctype</>によって決まります。基本的なASCIIのみを含む単語は、別のトークン型として報告されます。ときには、それらを他と区別することが有用だからです。ヨーロッパのたいていの言語では、<literal>word</> と <literal>asciiword</>は、同じように扱われます。
   </para>

   <para>
<!--
    <literal>email</> does not support all valid email characters as
    defined by RFC 5322.  Specifically, the only non-alphanumeric
    characters supported for email user names are period, dash, and
    underscore.
-->
<literal>email</>はRFC5322で定義されたすべての有効なメールアドレス文字をサポートしません。メールアドレスのユーザ名としてサポートされる英数字以外の文字はピリオド、ダッシュ、アンダースコアのみです。
   </para>
  </note>

  <para>
<!--
   It is possible for the parser to produce overlapping tokens from the same
   piece of text.  As an example, a hyphenated word will be reported both
   as the entire word and as each component:
-->
パーサがテキストの同じ部分から重複したトークンを生成することはあり得ます。たとえば、ハイフン付の単語は、単語全体と、各部分の両方を報告します。例を示します。

<screen>
SELECT alias, description, token FROM ts_debug('foo-bar-beta1');
      alias      |               description                |     token     
-----------------+------------------------------------------+---------------
 numhword        | Hyphenated word, letters and digits      | foo-bar-beta1
 hword_asciipart | Hyphenated word part, all ASCII          | foo
 blank           | Space symbols                            | -
 hword_asciipart | Hyphenated word part, all ASCII          | bar
 blank           | Space symbols                            | -
 hword_numpart   | Hyphenated word part, letters and digits | beta1
</screen>

<!--
   This behavior is desirable since it allows searches to work for both
   the whole compound word and for components.  Here is another
   instructive example:
-->
この挙動は好ましいのものです。単語全体と、各々の部分の両方に対して検索ができるからです。初歩的な別の例を示します。

<screen>
SELECT alias, description, token FROM ts_debug('http://example.com/stuff/index.html');
  alias   |  description  |            token             
----------+---------------+------------------------------
 protocol | Protocol head | http://
 url      | URL           | example.com/stuff/index.html
 host     | Host          | example.com
 url_path | URL path      | /stuff/index.html
</screen>
  </para>

 </sect1>

 <sect1 id="textsearch-dictionaries">
<!--
  <title>Dictionaries</title>
-->
  <title>辞書</title>

  <para>
<!--
   Dictionaries are used to eliminate words that should not be considered in a
   search (<firstterm>stop words</>), and to <firstterm>normalize</> words so
   that different derived forms of the same word will match.  A successfully
   normalized word is called a <firstterm>lexeme</>.  Aside from
   improving search quality, normalization and removal of stop words reduce the
   size of the <type>tsvector</type> representation of a document, thereby
   improving performance.  Normalization does not always have linguistic meaning
   and usually depends on application semantics.
-->
辞書は、検索の対象とならない単語(<firstterm>ストップワード</>)を削除するために使われます。また、同じ単語から派生した異なる形態の単語が照合するようにするために、単語を<firstterm>正規化</>するためにも使われます。検索の品質を向上するという面以外にも、正規化とストップワードの削除は、<type>tsvector</type>表現の文書のサイズを小さくし、結果として性能を向上させます。正規化は常に言語学的な意味を持つとは限らず、通常は用途の意味論に依存します。
  </para>

  <para>
<!--
   Some examples of normalization:
-->
   正規化の例を示します。

   <itemizedlist  spacing="compact" mark="bullet">

    <listitem>
     <para>
<!--
      Linguistic - Ispell dictionaries try to reduce input words to a
      normalized form; stemmer dictionaries remove word endings
-->
言語学的 - Ispell辞書は入力された単語を正規化された形式に変換しようとします。語幹辞書は単語の終了部を削除します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <acronym>URL</acronym> locations can be canonicalized to make
      equivalent URLs match:
-->
以下のような<acronym>URL</acronym>が同一のURLに一致するように正規化することができます。

      <itemizedlist  spacing="compact" mark="bullet">
       <listitem>
        <para>
         http://www.pgsql.ru/db/mw/index.html
        </para>
       </listitem>
       <listitem>
        <para>
         http://www.pgsql.ru/db/mw/
        </para>
       </listitem>
       <listitem>
        <para>
         http://www.pgsql.ru/db/../db/mw/index.html
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Color names can be replaced by their hexadecimal values, e.g.,
-->
色の名前は、16進値に変換できます。例：
      <literal>red, green, blue, magenta -> FF0000, 00FF00, 0000FF, FF00FF</literal>
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      If indexing numbers, we can
      remove some fractional digits to reduce the range of possible
      numbers, so for example <emphasis>3.14</emphasis>159265359,
      <emphasis>3.14</emphasis>15926, <emphasis>3.14</emphasis> will be the same
      after normalization if only two digits are kept after the decimal point.
-->
数をインデックス付けする際には、可能な範囲を縮小するために、端数を削除することができます。たとえば、もし正規化後に小数点未満2桁を保持するならば、<emphasis>3.14</emphasis>15926, <emphasis>3.14</emphasis>は同じことになります。
     </para>
    </listitem>
   </itemizedlist>

  </para>

  <para>
<!--
   A dictionary is a program that accepts a token as
   input and returns:
-->
辞書は、トークンを入力し、以下を返すプログラムです。   
   <itemizedlist  spacing="compact" mark="bullet">
    <listitem>
     <para>
<!--
      an array of lexemes if the input token is known to the dictionary
      (notice that one token can produce more than one lexeme)
-->
入力が辞書に登録されていれば語彙素の配列(一つのトークンが一つ以上の語彙素を生成する可能性があることに注意してください)
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      a single lexeme with the <literal>TSL_FILTER</> flag set, to replace
      the original token with a new token to be passed to subsequent
      dictionaries (a dictionary that does this is called a
      <firstterm>filtering dictionary</>)
-->
元々のトークンを新規のトークンに置き換え、それに続く辞書にその新規トークン渡す場合は、<literal>TSL_FILTER</>フラグセットを伴う単一の語彙素(このような置き換え機能をもつ辞書は<firstterm>フィルタリング辞書</>と呼ばれます)
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      an empty array if the dictionary knows the token, but it is a stop word
-->
辞書が入力を認識しないが、ストップワードであることは認識する場合は空の配列
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>NULL</literal> if the dictionary does not recognize the input token
-->
辞書が入力トークンを認識しない場合は<literal>NULL</literal>
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname> provides predefined dictionaries for
   many languages.  There are also several predefined templates that can be
   used to create new dictionaries with custom parameters.  Each predefined
   dictionary template is described below.  If no existing
   template is suitable, it is possible to create new ones; see the
   <filename>contrib/</> area of the <productname>PostgreSQL</> distribution
   for examples.
-->
<productname>PostgreSQL</productname>は、多くの言語に定義済の辞書を提供しています。
また、カスタムパラメータを使った新しい辞書を作るために使えるテンプレートもいくつかあります。
定義済の辞書のテンプレートについては、以下で述べています。
今あるテンプレートが適当でないのなら、新しいものを作ることもできます。例は、<productname>PostgreSQL</>の配布物の<filename>contrib/</>をご覧下さい。
  </para>

  <para>
<!--
   A text search configuration binds a parser together with a set of
   dictionaries to process the parser's output tokens.  For each token
   type that the parser can return, a separate list of dictionaries is
   specified by the configuration.  When a token of that type is found
   by the parser, each dictionary in the list is consulted in turn,
   until some dictionary recognizes it as a known word.  If it is identified
   as a stop word, or if no dictionary recognizes the token, it will be
   discarded and not indexed or searched for.
   Normally, the first dictionary that returns a non-<literal>NULL</>
   output determines the result, and any remaining dictionaries are not
   consulted; but a filtering dictionary can replace the given word
   with a modified word, which is then passed to subsequent dictionaries.
-->
テキスト検索設定は、パーサと、パーサの出力トークンを処理する辞書の集合を結び付けます。パーサが返却する各々のトークン型に対して、設定で辞書のリストを指定します。パーサがあるトークン型を見つけると、ある辞書が単語を認識するまでリスト中の辞書が順番に調べられます。
ストップワードであるか、あるいはどの辞書もトークンを認識しない場合はそれは捨てられ、インデックス付けや検索の対象となりません。
通常、非<literal>NULL</>を返す最初の辞書の出力が結果を決めることになり、他の残りの辞書は参照されません。しかし、フィルタリング辞書は与えられたワードを変更し、それを続く辞書へ渡すことができます。
  </para>

  <para>
<!--
   The general rule for configuring a list of dictionaries
   is to place first the most narrow, most specific dictionary, then the more
   general dictionaries, finishing with a very general dictionary, like
   a <application>Snowball</> stemmer or <literal>simple</>, which
   recognizes everything.  For example, for an astronomy-specific search
   (<literal>astro_en</literal> configuration) one could bind token type
   <type>asciiword</type> (ASCII word) to a synonym dictionary of astronomical
   terms, a general English dictionary and a <application>Snowball</> English
   stemmer:
-->
辞書をリストする一般的な方法は、まずもっとも範囲の狭い、特定用途向の辞書を配置し、次にもっと一般的な辞書を置き、最後に<application>Snowball</>語幹処理や<literal>simple</>辞書のような、すべてを認識する非常に一般的な辞書を置くことです。
たとえば、天文学向の検索では(<literal>astro_en</literal>設定)では、<type>asciiword</type> (ASCII単語)型を天文学用語の同義語辞書、一般的な英語辞書、そして<application>Snowball</>英語語幹辞書に結び付けることができます。

<programlisting>
ALTER TEXT SEARCH CONFIGURATION astro_en
    ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;
</programlisting>
  </para>

  <para>
<!--
   A filtering dictionary can be placed anywhere in the list, except at the
   end where it'd be useless.  Filtering dictionaries are useful to partially
   normalize words to simplify the task of later dictionaries.  For example,
   a filtering dictionary could be used to remove accents from accented
   letters, as is done by the <xref linkend="unaccent"> module.
-->
フィルタリング辞書は、リスト中の好きな場所へ配置できます。(役に立たなくなるリストの最後を除きます。)
フィルタリング辞書は、後続の辞書の処理を単純化するために、一部の文字の正規化を行うのに有用です。
例えば、フィルタリング辞書は<xref linkend="unaccent">モジュールで実施される様な、アクセント記号が付与された文字からアクセント記号を取り除くのに使用することができます。
  </para>

  <sect2 id="textsearch-stopwords">
<!--
   <title>Stop Words</title>
-->
   <title>ストップワード</title>

   <para>
<!--
    Stop words are words that are very common, appear in almost every
    document, and have no discrimination value. Therefore, they can be ignored
    in the context of full text searching. For example, every English text
    contains words like <literal>a</literal> and <literal>the</>, so it is
    useless to store them in an index.  However, stop words do affect the
    positions in <type>tsvector</type>, which in turn affect ranking:
-->
ストップワードは、ほとんどすべての文書に現れるような非常に一般的で、ほかのものと同じようには扱う価値のない単語です。
ですから、全文検索の際には無視して構いません。
たとえば、すべての英語のテキストは<literal>a</literal>や<literal>the</>のような単語を含んでおり、インデックスの中にそれらを入れても役に立ちません。
しかし、ストップワードは<type>tsvector</type>中の位置に影響を与えるので、結局ランキングにも影響があります。

<screen>
SELECT to_tsvector('english','in the list of stop words');
        to_tsvector
----------------------------
 'list':3 'stop':5 'word':6
</screen>

<!--
    The missing positions 1,2,4 are because of stop words.  Ranks
    calculated for documents with and without stop words are quite different:
-->
位置1, 2, 4は、ストップワードのために失われています。
ストップワードの有無により、文書のために計算されたランクは非常に影響を受けます。

<screen>
SELECT ts_rank_cd (to_tsvector('english','in the list of stop words'), to_tsquery('list &amp; stop'));
 ts_rank_cd
------------
       0.05

SELECT ts_rank_cd (to_tsvector('english','list stop words'), to_tsquery('list &amp; stop'));
 ts_rank_cd
------------
        0.1
</screen>

   </para>

   <para>
<!--
    It is up to the specific dictionary how it treats stop words. For example,
    <literal>ispell</literal> dictionaries first normalize words and then
    look at the list of stop words, while <literal>Snowball</literal> stemmers
    first check the list of stop words. The reason for the different
    behavior is an attempt to decrease noise.
-->
ストップワードをどのように扱うかは、特定の辞書に任されています。
例えば、<literal>ispell</literal>辞書はまず単語を正規化し、そして、ストップワードのリストを検索します。一方、<literal>Snowball</literal>語幹抽出はまずストップワードのリストを検査します。
動作が異なる理由は、ノイズが紛れ込む可能性を減らすことです。
   </para>

  </sect2>

  <sect2 id="textsearch-simple-dictionary">
<!--
   <title>Simple Dictionary</title>
-->
   <title>simple辞書</title>

   <para>
<!--
    The <literal>simple</> dictionary template operates by converting the
    input token to lower case and checking it against a file of stop words.
    If it is found in the file then an empty array is returned, causing
    the token to be discarded.  If not, the lower-cased form of the word
    is returned as the normalized lexeme.  Alternatively, the dictionary
    can be configured to report non-stop-words as unrecognized, allowing
    them to be passed on to the next dictionary in the list.
-->
<literal>simple</>辞書テンプレートは、入力トークンを小文字に変換し、ストップワードのファイルに対してチェックすることによって動作します。
もしファイルの中にあれば、空の配列が返却され、そのトークンは捨てられます。
そうでないときは、小文字形式の単語が正規化された語彙素として返却されます。
別の方法としては、ストップワードではないものは、認識できないものとすることもできます。そうすることにより、それらをリスト中の次の辞書に渡すことができます。
   </para>

   <para>
<!--
    Here is an example of a dictionary definition using the <literal>simple</>
    template:
-->
<literal>simple</>テンプレートを使った辞書定義の例を示します。

<programlisting>
CREATE TEXT SEARCH DICTIONARY public.simple_dict (
    TEMPLATE = pg_catalog.simple,
    STOPWORDS = english
);
</programlisting>

<!--
    Here, <literal>english</literal> is the base name of a file of stop words.
    The file's full name will be
    <filename>$SHAREDIR/tsearch_data/english.stop</>,
    where <literal>$SHAREDIR</> means the
    <productname>PostgreSQL</productname> installation's shared-data directory,
    often <filename>/usr/local/share/postgresql</> (use <command>pg_config
    &#045;-sharedir</> to determine it if you're not sure).
    The file format is simply a list
    of words, one per line.  Blank lines and trailing spaces are ignored,
    and upper case is folded to lower case, but no other processing is done
    on the file contents.
-->
ここで、<literal>english</literal>は、ストップワードファイルのベースネームです。
ファイルのフルネームは、<filename>$SHAREDIR/tsearch_data/english.stop</>です。<literal>$SHAREDIR</>は、<productname>PostgreSQL</productname>インストール先の共有データディレクトリです。これは、よく<filename>/usr/local/share/postgresql</>に置いてあります。(良くわからない場合は<command>pg_config --sharedir</>を使ってください)。
ファイル形式は、単に1行ごとに単語を書くだけです。
空行と、後方の空白は無視されます。大文字は小文字に変換されます。このファイルの内容に関する処理はこれだけです。
   </para>

   <para>
<!--
    Now we can test our dictionary:
-->
これで辞書のテストができます。

<screen>
SELECT ts_lexize('public.simple_dict','YeS');
 ts_lexize
-----------
 {yes}

SELECT ts_lexize('public.simple_dict','The');
 ts_lexize
-----------
 {}
</screen>
   </para>

   <para>
<!--
    We can also choose to return <literal>NULL</>, instead of the lower-cased
    word, if it is not found in the stop words file.  This behavior is
    selected by setting the dictionary's <literal>Accept</> parameter to
    <literal>false</>.  Continuing the example:
-->
また、ストップワードファイルの中に見つからないときに、小文字に変換した単語を返す代わりに、<literal>NULL</>を返すことを選ぶこともできます。
この挙動は、辞書の<literal>Accept</>パラメータを<literal>false</>に設定することで選択されます。
さらに例を続けます。

<screen>
ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false );

SELECT ts_lexize('public.simple_dict','YeS');
 ts_lexize
-----------


SELECT ts_lexize('public.simple_dict','The');
 ts_lexize
-----------
 {}
</screen>
   </para>

   <para>
<!--
    With the default setting of <literal>Accept</> = <literal>true</>,
    it is only useful to place a <literal>simple</> dictionary at the end
    of a list of dictionaries, since it will never pass on any token to
    a following dictionary.  Conversely, <literal>Accept</> = <literal>false</>
    is only useful when there is at least one following dictionary.
-->
デフォルト設定の<literal>Accept</> = <literal>true</>では、<literal>simple</>辞書は、辞書リストの最後に置かなければ意味がありません。なぜなら、後続の辞書にトークンを渡すことがないからです。逆に<literal>Accept</> = <literal>false</>は、後続の辞書が少なくとも一つはあるときに意味があります。
   </para>

   <caution>
    <para>
<!--
     Most types of dictionaries rely on configuration files, such as files of
     stop words.  These files <emphasis>must</> be stored in UTF-8 encoding.
     They will be translated to the actual database encoding, if that is
     different, when they are read into the server.
-->
ほとんどの辞書の形式は、ストップワードファイルのように設定ファイルに依存します。これらのファイルは<emphasis>必ず</>UTF-8エンコーディングにしてください。サーバのエンコーディングがUTF-8でない場合は、サーバに読み込まれる際に実際のデータベースエンコーディングに変換されます。
    </para>
   </caution>

   <caution>
    <para>
<!--
     Normally, a database session will read a dictionary configuration file
     only once, when it is first used within the session.  If you modify a
     configuration file and want to force existing sessions to pick up the
     new contents, issue an <command>ALTER TEXT SEARCH DICTIONARY</> command
     on the dictionary.  This can be a <quote>dummy</> update that doesn't
     actually change any parameter values.
-->
通常、辞書はデータベースセッションの中で最初に使われる際に、一度だけ読み込まれます。辞書を変更し、現在使われているセッションの中で新しい内容が読み込まれるようにしたい場合は、その辞書に対して<command>ALTER TEXT SEARCH DICTIONARY</>を発行してください。これは実際にはどんなパラメータ値をも変更しない<quote>ダミー</>の更新でよいです。
    </para>
   </caution>

  </sect2>

  <sect2 id="textsearch-synonym-dictionary">
<!--
   <title>Synonym Dictionary</title>
-->
   <title>同義語辞書</title>

   <para>
<!--
    This dictionary template is used to create dictionaries that replace a
    word with a synonym. Phrases are not supported (use the thesaurus
    template (<xref linkend="textsearch-thesaurus">) for that).  A synonym
    dictionary can be used to overcome linguistic problems, for example, to
    prevent an English stemmer dictionary from reducing the word <quote>Paris</quote> to
    <quote>pari</quote>.  It is enough to have a <literal>Paris paris</literal> line in the
    synonym dictionary and put it before the <literal>english_stem</>
    dictionary.  For example:
-->
この辞書テンプレートは、単語を同義語に置き換える辞書を作るために使われます。語句はサポートされていません(そのためには類語テンプレート(<xref linkend="textsearch-thesaurus">)を使ってください)。同義語辞書は、言語学的な問題、たとえば、英語語幹辞書が<quote>Paris</quote>という単語を<quote>pari</quote>に縮小してしまうのを防ぎます。<literal>Paris paris</literal>という行を同義語辞書に登録し、<literal>english_stem</>辞書の前に置くようにするだけでよいのです。下記はその例です。

<screen>
SELECT * FROM ts_debug('english', 'Paris');
   alias   |   description   | token |  dictionaries  |  dictionary  | lexemes 
-----------+-----------------+-------+----------------+--------------+---------
 asciiword | Word, all ASCII | Paris | {english_stem} | english_stem | {pari}

CREATE TEXT SEARCH DICTIONARY my_synonym (
    TEMPLATE = synonym,
    SYNONYMS = my_synonyms
);

ALTER TEXT SEARCH CONFIGURATION english
    ALTER MAPPING FOR asciiword
    WITH my_synonym, english_stem;

SELECT * FROM ts_debug('english', 'Paris');
   alias   |   description   | token |       dictionaries        | dictionary | lexemes 
-----------+-----------------+-------+---------------------------+------------+---------
 asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | my_synonym | {paris}
</screen>
   </para>

   <para>
<!--
    The only parameter required by the <literal>synonym</> template is
    <literal>SYNONYMS</>, which is the base name of its configuration file
    &mdash; <literal>my_synonyms</> in the above example.
    The file's full name will be
    <filename>$SHAREDIR/tsearch_data/my_synonyms.syn</>
    (where <literal>$SHAREDIR</> means the
    <productname>PostgreSQL</> installation's shared-data directory).
    The file format is just one line
    per word to be substituted, with the word followed by its synonym,
    separated by white space.  Blank lines and trailing spaces are ignored.
-->
<literal>synonym</>テンプレートに必要なパラメータは<literal>SYNONYMS</>だけで、その設定ファイルのベースネームです &mdash; 上の例では<literal>my_synonyms</>です。
ファイルのフルネームは、<filename>$SHAREDIR/tsearch_data/my_synonyms.syn</> となります(ここで<literal>$SHAREDIR</>は、<productname>PostgreSQL</>をインストールした際の、共有データディレクトリです)。
ファイルの形式は、置き換え対象の1単語につき1行で、単語には空白で区切られた同義語が後に続きます。
空行、後方の空白は無視されます。
   </para>

   <para>
<!--
    The <literal>synonym</> template also has an optional parameter
    <literal>CaseSensitive</>, which defaults to <literal>false</>.  When
    <literal>CaseSensitive</> is <literal>false</>, words in the synonym file
    are folded to lower case, as are input tokens.  When it is
    <literal>true</>, words and tokens are not folded to lower case,
    but are compared as-is.
-->
<literal>synonym</>テンプレートはまた、<literal>CaseSensitive</>というオプションパラメータを持っており、デフォルトは<literal>false</>です。
<literal>CaseSensitive</>が<literal>false</>の時は、同義語辞書内の単語は入力トークンと同様に小文字に変換されます。
<literal>true</>の時は、単語とトークンは小文字に変換されずそのまま比較されます。
   </para>

   <para>
<!--
    An asterisk (<literal>*</literal>) can be placed at the end of a synonym
    in the configuration file.  This indicates that the synonym is a prefix.
    The asterisk is ignored when the entry is used in
    <function>to_tsvector()</function>, but when it is used in
    <function>to_tsquery()</function>, the result will be a query item with
    the prefix match marker (see
    <xref linkend="textsearch-parsing-queries">).
    For example, suppose we have these entries in
    <filename>$SHAREDIR/tsearch_data/synonym_sample.syn</>:
-->
アスタリスク(<literal>*</literal>)は設定ファイル中の同義語の最後に付与することができます。
これは同義語を接頭語とすることを意味します。
アスタリスクは、エントリが<function>to_tsvector()</function>で使用される場合には無視されますが、<function>to_tsquery()</function>で使用される場合、結果は前方一致を伴った問い合わせになるでしょう。(詳しくは<xref linkend="textsearch-parsing-queries">を見てください。)
例えば、<filename>$SHAREDIR/tsearch_data/synonym_sample.syn</>に以下の様なエントリをもっていたとします。
<programlisting>
postgres        pgsql
postgresql      pgsql
postgre pgsql
gogle   googl
indices index*
</programlisting>
<!--
    Then we will get these results:
-->
この場合、次のような結果を得ることになります。
<screen>
mydb=# CREATE TEXT SEARCH DICTIONARY syn (template=synonym, synonyms='synonym_sample');
mydb=# SELECT ts_lexize('syn','indices');
 ts_lexize
-----------
 {index}
(1 row)

mydb=# CREATE TEXT SEARCH CONFIGURATION tst (copy=simple);
mydb=# ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword WITH syn;
mydb=# SELECT to_tsvector('tst','indices');
 to_tsvector
-------------
 'index':1
(1 row)

mydb=# SELECT to_tsquery('tst','indices');
 to_tsquery
------------
 'index':*
(1 row)

mydb=# SELECT 'indexes are very useful'::tsvector;
            tsvector             
---------------------------------
 'are' 'indexes' 'useful' 'very'
(1 row)

mydb=# SELECT 'indexes are very useful'::tsvector @@ to_tsquery('tst','indices');
 ?column?
----------
 t
(1 row)
</screen>
   </para>
  </sect2>

  <sect2 id="textsearch-thesaurus">
<!--
   <title>Thesaurus Dictionary</title>
-->
   <title>類語辞書</title>

   <para>
<!--
    A thesaurus dictionary (sometimes abbreviated as <acronym>TZ</acronym>) is
    a collection of words that includes information about the relationships
    of words and phrases, i.e., broader terms (<acronym>BT</acronym>), narrower
    terms (<acronym>NT</acronym>), preferred terms, non-preferred terms, related
    terms, etc.
-->
類語辞書(<acronym>TZ</acronym>と略されることがあります)は、単語と語句の関係情報を集めたものです。つまり、広義用語(<acronym>BT</acronym>)、狭義用語(<acronym>NT</acronym>)、優先用語、非優先用語、関連用語などです。
   </para>

   <para>
<!--
    Basically a thesaurus dictionary replaces all non-preferred terms by one
    preferred term and, optionally, preserves the original terms for indexing
    as well.  <productname>PostgreSQL</>'s current implementation of the
    thesaurus dictionary is an extension of the synonym dictionary with added
    <firstterm>phrase</firstterm> support.  A thesaurus dictionary requires
    a configuration file of the following format:
-->
基本的には、類語辞書は、非優先用語を優先用語に置き換え、オプションで元の用語もインデックス付けのため保存します。<productname>PostgreSQL</>の現在の類語辞書の実装は、同義語辞書を拡張し、<firstterm>語句</firstterm>のサポートを追加したものです。類語辞書は、以下のようなフォーマットの設定ファイルを必要とします。

<programlisting>
# this is a comment
sample word(s) : indexed word(s)
more sample word(s) : more indexed word(s)
...
</programlisting>

<!--
    where  the colon (<symbol>:</symbol>) symbol acts as a delimiter between a
    phrase and its replacement.
-->
ここで、コロン(<symbol>:</symbol>)は、語句とその置き換え対象の区切りです。
   </para>

   <para>
<!--
    A thesaurus dictionary uses a <firstterm>subdictionary</firstterm> (which
    is specified in the dictionary's configuration) to normalize the input
    text before checking for phrase matches. It is only possible to select one
    subdictionary.  An error is reported if the subdictionary fails to
    recognize a word. In that case, you should remove the use of the word or
    teach the subdictionary about it.  You can place an asterisk
    (<symbol>*</symbol>) at the beginning of an indexed word to skip applying
    the subdictionary to it, but all sample words <emphasis>must</> be known
    to the subdictionary.
-->
類語辞書は、<firstterm>副辞書</firstterm>(辞書設定で指定します)を、一致する語句をチェックする前に入力テキストを正規化するために使います。
副辞書はただ一つだけ選べます。
副辞書が単語を認識できない場合はエラーが報告されます。
その場合は、その単語の利用を止めるか、副辞書にそのことを教えなければなりません。
アスタリスク(<symbol>*</symbol>)をインデックス付けされた単語の先頭に置くことにより、副辞書の適用をスキップできます。しかしながら、すべてのサンプルの単語は、副辞書に認識<emphasis>されなければなりません</>。
   </para>

   <para>
<!--
    The thesaurus dictionary chooses the longest match if there are multiple
    phrases matching the input, and ties are broken by using the last
    definition.
-->
複数の類語が照合するときは、類語辞書はもっとも長いものを選びます。そして、語句は、最後の定義を使って分解されます。
   </para>

   <para>
<!--
    Specific stop words recognized by the subdictionary cannot be
    specified;  instead use <literal>?</> to mark the location where any
    stop word can appear.  For example, assuming that <literal>a</> and
    <literal>the</> are stop words according to the subdictionary:
-->
特定のストップワードを副辞書に認識するように指定することはできません。その代わり、ストップワードが出現する位置を<literal>?</>でマークします。
たとえば、<literal>a</>と<literal>the</>が副辞書によればストップワードだったとします。

<programlisting>
? one ? two : swsw
</programlisting>

<!--
    matches <literal>a one the two</> and <literal>the one a two</>;
    both would be replaced by <literal>swsw</>.
-->
は、<literal>a one the two</>と<literal>the one a two</>に照合します。そして、両方とも<literal>swsw</>に置き換えられます。
   </para>

   <para>
<!--
    Since a thesaurus dictionary has the capability to recognize phrases it
    must remember its state and interact with the parser. A thesaurus dictionary
    uses these assignments to check if it should handle the next word or stop
    accumulation.  The thesaurus dictionary must be configured
    carefully. For example, if the thesaurus dictionary is assigned to handle
    only the <literal>asciiword</literal> token, then a thesaurus dictionary
    definition like <literal>one 7</> will not work since token type
    <literal>uint</literal> is not assigned to the thesaurus dictionary.
-->
類語辞書は語句を認識することができるので、状態を記憶してパーサと連携を保たなければなりません。
類語辞書は、この機能を使って次の単語を引き続き処理するのか、単語の蓄積を止めるのかを決定します。
類語辞書の設定は注意深く行わなければなりません。
たとえば、類語辞書が<literal>asciiword</literal>トークンだけを扱うようになっている場合、<literal>one 7</>のような類語辞書の定義は、トークン型<literal>uint</literal>が類語辞書にアサインされていないので動きません。
   </para>

   <caution>
    <para>
<!--
     Thesauruses are used during indexing so any change in the thesaurus
     dictionary's parameters <emphasis>requires</emphasis> reindexing.
     For most other dictionary types, small changes such as adding or
     removing stopwords does not force reindexing.
-->
類語辞書はインデックス付けの際に利用されるので、類語辞書を設定変更すると、再インデックス付けが<emphasis>必要</emphasis>になります。他のほとんどの辞書では、ストップワードを追加あるいは削除するような小さな変更は、インデックス付けを必要としません。
    </para>
   </caution>

  <sect3 id="textsearch-thesaurus-config">
<!--
   <title>Thesaurus Configuration</title>
-->
   <title>類語設定</title>

   <para>
<!--
    To define a new thesaurus dictionary, use the <literal>thesaurus</>
    template.  For example:
-->
新しい類語辞書を定義するには、<literal>thesaurus</>テンプレートを使います。例を示します。

<programlisting>
CREATE TEXT SEARCH DICTIONARY thesaurus_simple (
    TEMPLATE = thesaurus,
    DictFile = mythesaurus,
    Dictionary = pg_catalog.english_stem
);
</programlisting>

<!--
    Here:
-->
ここで、
    <itemizedlist  spacing="compact" mark="bullet">
     <listitem>
      <para>
<!--
       <literal>thesaurus_simple</literal> is the new dictionary's name
-->
<literal>thesaurus_simple</literal>は新しい辞書の名前です。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>mythesaurus</literal> is the base name of the thesaurus
       configuration file.
       (Its full name will be <filename>$SHAREDIR/tsearch_data/mythesaurus.ths</>,
       where <literal>$SHAREDIR</> means the installation shared-data
       directory.)
-->
<literal>mythesaurus</literal>は、類語設定ファイルのベースネームです。
(フルパスは、<filename>$SHAREDIR/tsearch_data/mythesaurus.ths</>となります。ここで、<literal>$SHAREDIR</>はインストール時の共有データディレクトリです。)
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>pg_catalog.english_stem</literal> is the subdictionary (here,
       a Snowball English stemmer) to use for thesaurus normalization.
       Notice that the subdictionary will have its own
       configuration (for example, stop words), which is not shown here.
-->
類語正規化で使用する<literal>pg_catalog.english_stem</literal>は副辞書です(ここでは、Snowball英語語幹辞書)。
副辞書にはそれ用の設定(たとえばストップワード)があることに注意してください。ここではそれは表示していません。
      </para>
     </listitem>
    </itemizedlist>

<!--
    Now it is possible to bind the thesaurus dictionary <literal>thesaurus_simple</literal>
    to the desired token types in a configuration, for example:
-->
これで、類語辞書<literal>thesaurus_simple</literal>を、設定中の希望のトークンにバインドすることができるようになります。例を示します。

<programlisting>
ALTER TEXT SEARCH CONFIGURATION russian
    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart
    WITH thesaurus_simple;
</programlisting>
   </para>

  </sect3>

  <sect3 id="textsearch-thesaurus-examples">
<!--
   <title>Thesaurus Example</title>
-->
   <title>類語の例</title>

   <para>
<!--
    Consider a simple astronomical thesaurus <literal>thesaurus_astro</literal>,
    which contains some astronomical word combinations:
-->
天文学の単語の組合わせを含む単純な天文学用の<literal>thesaurus_astro</literal>類語を考えます。

<programlisting>
supernovae stars : sn
crab nebulae : crab
</programlisting>

<!--
    Below we create a dictionary and bind some token types to
    an astronomical thesaurus and English stemmer:
-->
以下で辞書を作り、トークン型を天文学類語辞書と英語の語幹辞書に結び付けます。

<programlisting>
CREATE TEXT SEARCH DICTIONARY thesaurus_astro (
    TEMPLATE = thesaurus,
    DictFile = thesaurus_astro,
    Dictionary = english_stem
);

ALTER TEXT SEARCH CONFIGURATION russian
    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart
    WITH thesaurus_astro, english_stem;
</programlisting>

<!--
    Now we can see how it works.
    <function>ts_lexize</function> is not very useful for testing a thesaurus,
    because it treats its input as a single token.  Instead we can use
    <function>plainto_tsquery</function> and <function>to_tsvector</function>
    which will break their input strings into multiple tokens:
-->
さあ、これでどのように動くか試せます。<function>ts_lexize</function>は類語をテストする目的にはあまり有用ではありません。なぜなら、それは入力を単一のトークンとして扱うからです。
その代わりに、<function>plainto_tsquery</function>と<function>to_tsvector</function>を使って入力文字列を複数のトークンに分解します。

<screen>
SELECT plainto_tsquery('supernova star');
 plainto_tsquery
-----------------
 'sn'

SELECT to_tsvector('supernova star');
 to_tsvector
-------------
 'sn':1
</screen>

<!--
    In principle, one can use <function>to_tsquery</function> if you quote
    the argument:
-->
原則として、引数を引用符で囲めば<function>to_tsquery</function>が使えます。

<screen>
SELECT to_tsquery('''supernova star''');
 to_tsquery
------------
 'sn'
</screen>

<!--
    Notice that <literal>supernova star</literal> matches <literal>supernovae
    stars</literal> in <literal>thesaurus_astro</literal> because we specified
    the <literal>english_stem</literal> stemmer in the thesaurus definition.
    The stemmer removed the <literal>e</> and <literal>s</>.
-->
<literal>english_stem</literal>語幹辞書を同義語辞書の定義時に指定したので、<literal>supernova star</literal>が<literal>thesaurus_astro</literal>中の<literal>supernovae stars</literal>に照合していることに注意してください。
語幹処理が<literal>e</>と<literal>s</>を削除しています。
   </para>

   <para>
<!--
    To index the original phrase as well as the substitute, just include it
    in the right-hand part of the definition:
-->
置き換え後の語句とオリジナルの語句の両方をインデックス付けするには、定義の右項にオリジナルを追加するだけで良いです。

<screen>
supernovae stars : sn supernovae stars

SELECT plainto_tsquery('supernova star');
       plainto_tsquery
-----------------------------
 'sn' &amp; 'supernova' &amp; 'star'
</screen>
   </para>

  </sect3>

  </sect2>

  <sect2 id="textsearch-ispell-dictionary">
<!--
   <title><application>Ispell</> Dictionary</title>
-->
   <title><application>Ispell</>辞書</title>

   <para>
<!--
    The <application>Ispell</> dictionary template supports
    <firstterm>morphological dictionaries</>, which can normalize many
    different linguistic forms of a word into the same lexeme.  For example,
    an English <application>Ispell</> dictionary can match all declensions and
    conjugations of the search term <literal>bank</literal>, e.g.,
    <literal>banking</>, <literal>banked</>, <literal>banks</>,
    <literal>banks'</>, and <literal>bank's</>.
-->
<application>Ispell</>辞書テンプレートは、<firstterm>形態論辞書</>を提供します。これによって、言語学的に多様な単語の形態を同じ語彙素に変換することができます。
たとえば、英語<application>Ispell</>辞書は、検索語<literal>bank</literal>の語形変化と活用変化、たとえば<literal>banking</>, <literal>banked</>, <literal>banks</>, <literal>banks'</>, <literal>bank's</>に照合します。
   </para>

   <para>
<!--
    The standard <productname>PostgreSQL</productname> distribution does
    not include any <application>Ispell</> configuration files.
    Dictionaries for a large number of languages are available from <ulink
    url="http://ficus-www.cs.ucla.edu/geoff/ispell.html">Ispell</ulink>.
    Also, some more modern dictionary file formats are supported &mdash; <ulink
    url="http://en.wikipedia.org/wiki/MySpell">MySpell</ulink> (OO &lt; 2.0.1)
    and <ulink url="http://sourceforge.net/projects/hunspell/">Hunspell</ulink>
    (OO &gt;= 2.0.2).  A large list of dictionaries is available on the <ulink
    url="http://wiki.services.openoffice.org/wiki/Dictionaries">OpenOffice
    Wiki</ulink>.
-->
<productname>PostgreSQL</productname>の標準配布には、<application>Ispell</>の設定ファイルは含まれていません。
多くの言語用の辞書が<ulink url="http://ficus-www.cs.ucla.edu/geoff/ispell.html">Ispell</ulink>で入手できます。
また、より新しい辞書のフォーマットもサポートされています &mdash; <ulink url="http://en.wikipedia.org/wiki/MySpell">MySpell</ulink>(OO &lt; 2.0.1)と<ulink url="http://sourceforge.net/projects/hunspell/">Hunspell</ulink>(OO &gt;= 2.0.2)。
多数の辞書のリストが <ulink url="http://wiki.services.openoffice.org/wiki/Dictionaries">OpenOffice Wiki</ulink>で入手できます。
   </para>

   <para>
<!--
    To create an <application>Ispell</> dictionary, use the built-in
    <literal>ispell</literal> template and specify several parameters:
-->
<application>Ispell</>辞書を作るには、組み込みの<literal>ispell</literal>テンプレートを使い、いくつかパラメータを指定します。
   </para>

<programlisting>
CREATE TEXT SEARCH DICTIONARY english_ispell (
    TEMPLATE = ispell,
    DictFile = english,
    AffFile = english,
    StopWords = english
);
</programlisting>

   <para>
<!--
    Here, <literal>DictFile</>, <literal>AffFile</>, and <literal>StopWords</>
    specify the base names of the dictionary, affixes, and stop-words files.
    The stop-words file has the same format explained above for the
    <literal>simple</> dictionary type.  The format of the other files is
    not specified here but is available from the above-mentioned web sites.
-->
ここで、<literal>DictFile</>, <literal>AffFile</>, および<literal>StopWords</>は、辞書のベースネーム、接辞ファイル、ストップワードファイルを指定します。
ストップワードファイルは、上で説明した<literal>simple</>辞書と同じ形式です。
ほかのファイルの形式はここでは説明されませんが、上にあげたウェブサイトに説明があります。
   </para>

   <para>
<!--
    Ispell dictionaries usually recognize a limited set of words, so they
    should be followed by another broader dictionary; for
    example, a Snowball dictionary, which recognizes everything.
-->
Ispell辞書は通常限られた数の単語を認識します。ですので、なんでも認識できるSnowball辞書のような、より適用範囲の広い辞書による後処理が必要です。
   </para>

   <para>
<!--
    Ispell dictionaries support splitting compound words;
    a useful feature.
    Notice that the affix file should specify a special flag using the
    <literal>compoundwords controlled</literal> statement that marks dictionary
    words that can participate in compound formation:
-->
Ispell辞書を使って複合語を分割することができます。これは優れた機能です。
接辞ファイルは、複合語形式の候補になる辞書中の単語に印を付ける<literal>compoundwords controlled</literal>文を使う特別なフラグを指定しなければならないことに注意してください。

<programlisting>
compoundwords  controlled z
</programlisting>

<!--
    Here are some examples for the Norwegian language:
-->
ノルウェー語の例をいくつか示します。

<programlisting>
SELECT ts_lexize('norwegian_ispell', 'overbuljongterningpakkmesterassistent');
   {over,buljong,terning,pakk,mester,assistent}
SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk');
   {sjokoladefabrikk,sjokolade,fabrikk}
</programlisting>
   </para>

   <note>
    <para>
<!--
     <application>MySpell</> does not support compound words.
     <application>Hunspell</> has sophisticated support for compound words. At
     present, <productname>PostgreSQL</productname> implements only the basic
     compound word operations of Hunspell.
-->
<application>MySpell</>は複合語をサポートしていません。<application>Hunspell</>は複合語の高度なサポートを提供しています。いまのところ、<productname>PostgreSQL</productname>はHunspellの基本的な複合語操作しかサポートしていません。
    </para>
   </note>

  </sect2>

  <sect2 id="textsearch-snowball-dictionary">
<!--
   <title><application>Snowball</> Dictionary</title>
-->
   <title><application>Snowball</>辞書</title>

   <para>
<!--
    The <application>Snowball</> dictionary template is based on a project
    by Martin Porter, inventor of the popular Porter's stemming algorithm
    for the English language.  Snowball now provides stemming algorithms for
    many languages (see the <ulink url="http://snowball.tartarus.org">Snowball
    site</ulink> for more information).  Each algorithm understands how to
    reduce common variant forms of words to a base, or stem, spelling within
    its language.  A Snowball dictionary requires a <literal>language</>
    parameter to identify which stemmer to use, and optionally can specify a
    <literal>stopword</> file name that gives a list of words to eliminate.
    (<productname>PostgreSQL</productname>'s standard stopword lists are also
    provided by the Snowball project.)
    For example, there is a built-in definition equivalent to
-->
<application>Snowball</>辞書テンプレートは、有名な「英語用のポーターの語幹アルゴリズム」を発明したMartin Porterのプロジェクトに基づいています。Snowballは今では多くの言語用の語幹アルゴリズムを提供しています(詳細は<ulink url="http://snowball.tartarus.org">Snowballのサイト</ulink>を参照してください)。各々のアルゴリズムにより、その言語において単語の共通部分を取りだし、基本部もしくは語幹の綴りに縮退させることができます。Snowball辞書には、どの語幹処理を使うかを識別する<literal>言語</>パラメータが必須で、加えて、オプションで無視すべき単語のリストを保持する<literal>ストップワード</>ファイルを指定することもできます。(<productname>PostgreSQL</productname>の標準的なストップワードファイルもまたSnowball projectから提供されています)。たとえば、以下と同じ組み込みの定義があります。

<programlisting>
CREATE TEXT SEARCH DICTIONARY english_stem (
    TEMPLATE = snowball,
    Language = english,
    StopWords = english
);
</programlisting>

<!--
    The stopword file format is the same as already explained.
-->
ストップワードファイルの形式はすでに説明されているものと同じです。
   </para>

   <para>
<!--
    A <application>Snowball</> dictionary recognizes everything, whether
    or not it is able to simplify the word, so it should be placed
    at the end of the dictionary list. It is useless to have it
    before any other dictionary because a token will never pass through it to
    the next dictionary.
-->
<application>Snowball</>辞書は、単純化できるかどうかに関係なく、すべての単語を認識するので、辞書リストの最後に置く必要があります。他の辞書の前に置くのは意味がありません。<application>Snowball</>辞書は決してトークンを次の辞書に渡さないからです。
   </para>

  </sect2>

 </sect1>

 <sect1 id="textsearch-configuration">
<!--
  <title>Configuration Example</title>
-->
  <title>設定例</title>

   <para>
<!--
    A text search configuration specifies all options necessary to transform a
    document into a <type>tsvector</type>: the parser to use to break text
    into tokens, and the dictionaries to use to transform each token into a
    lexeme.  Every call of
    <function>to_tsvector</function> or <function>to_tsquery</function>
    needs a text search configuration to perform its processing.
    The configuration parameter
    <xref linkend="guc-default-text-search-config">
    specifies the name of the default configuration, which is the
    one used by text search functions if an explicit configuration
    parameter is omitted.
    It can be set in <filename>postgresql.conf</filename>, or set for an
    individual session using the <command>SET</> command.
-->
テキスト検索設定は、文書を<type>tsvector</type>に変換する必要なすべてのオプションを指定します。すなわち、テキストをトークンに分解するパーサ、そしてトークンを語彙素に変換する辞書です。<function>to_tsvector</function>または<function>to_tsquery</function>を呼び出すたびに、処理を進めるためにテキスト検索設定が必要になります。設定パラメータの<xref linkend="guc-default-text-search-config">は、デフォルトの設定を指定します。これは、明示的な設定が省略されたときにテキスト検索関数が使用します。<filename>postgresql.conf</filename>に設定するか、個々のセッションで<command>SET</>コマンドを使って設定できます。
   </para>

   <para>
<!--
    Several predefined text search configurations are available, and
    you can create custom configurations easily.  To facilitate management
    of text search objects, a set of <acronym>SQL</acronym> commands
    is available, and there are several <application>psql</application> commands that display information
    about text search objects (<xref linkend="textsearch-psql">).
-->
既定のテキスト検索設定がいくつか利用できます。また、カスタム設定を作るのも容易です。テキスト検索オブジェクトを管理する機能を実現するために、<acronym>SQL</acronym>コマンドが一通り用意されています。テキスト検索オブジェクトに関する情報を表示する<application>psql</application>コマンドもいくつか用意されています(<xref linkend="textsearch-psql">)。
   </para>

   <para>
<!--
    As an example we will create a configuration
    <literal>pg</literal>, starting by duplicating the built-in
    <literal>english</> configuration:
-->
例として、組み込みの<literal>english</>設定のコピーを用いて、新しい<literal>pg</literal>設定を作ります。

<programlisting>
CREATE TEXT SEARCH CONFIGURATION public.pg ( COPY = pg_catalog.english );
</programlisting>
   </para>

   <para>
<!--
    We will use a PostgreSQL-specific synonym list
    and store it in <filename>$SHAREDIR/tsearch_data/pg_dict.syn</filename>.
    The file contents look like:
-->
PostgreSQL固有の同義語リストを使い、それを<filename>$SHAREDIR/tsearch_data/pg_dict.syn</filename>に格納します。ファイルの内容は以下のようになります。

<programlisting>
postgres    pg
pgsql       pg
postgresql  pg
</programlisting>

<!--
    We define the synonym dictionary like this:
-->
同義語辞書を次のように定義します。

<programlisting>
CREATE TEXT SEARCH DICTIONARY pg_dict (
    TEMPLATE = synonym,
    SYNONYMS = pg_dict
);
</programlisting>

<!--
    Next we register the <productname>Ispell</> dictionary
    <literal>english_ispell</literal>, which has its own configuration files:
-->
次に、<productname>Ispell</>辞書の<literal>english_ispell</literal>を登録します。これにはそれ自身の設定があります。

<programlisting>
CREATE TEXT SEARCH DICTIONARY english_ispell (
    TEMPLATE = ispell,
    DictFile = english,
    AffFile = english,
    StopWords = english
);
</programlisting>

<!--
    Now we can set up the mappings for words in configuration
    <literal>pg</>:
-->
ここで、<literal>pg</>設定に単語用のマッピングを設定します。

<programlisting>
ALTER TEXT SEARCH CONFIGURATION pg
    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart,
                      word, hword, hword_part
    WITH pg_dict, english_ispell, english_stem;
</programlisting>

<!--
    We choose not to index or search some token types that the built-in
    configuration does handle:
-->
組み込み設定が扱っているいくつかのトークンに関しては、インデックス付けと検索に扱わないことにします。

<programlisting>
ALTER TEXT SEARCH CONFIGURATION pg
    DROP MAPPING FOR email, url, url_path, sfloat, float;
</programlisting>
   </para>

   <para>
<!--
    Now we can test our configuration:
-->
これでここまで作った設定を試すことができます。

<programlisting>
SELECT * FROM ts_debug('public.pg', '
PostgreSQL, the highly scalable, SQL compliant, open source object-relational
database management system, is now undergoing beta testing of the next
version of our software.
');
</programlisting>
   </para>

   <para>
<!--
    The next step is to set the session to use the new configuration, which was
    created in the <literal>public</> schema:
-->
次に、セッションの中で新しい設定を使うようにします。この設定は、<literal>public</>スキーマの中に作られています。

<screen>
=&gt; \dF
   List of text search configurations
 Schema  | Name | Description
---------+------+-------------
 public  | pg   |

SET default_text_search_config = 'public.pg';
SET

SHOW default_text_search_config;
 default_text_search_config
----------------------------
 public.pg
</screen>
  </para>

 </sect1>

 <sect1 id="textsearch-debugging">
<!--
  <title>Testing and Debugging Text Search</title>
-->
  <title>テキスト検索のテストとデバッグ</title>

  <para>
<!--
   The behavior of a custom text search configuration can easily become
   confusing.  The functions described
   in this section are useful for testing text search objects.  You can
   test a complete configuration, or test parsers and dictionaries separately.
-->
カスタムテキスト検索設定の挙動は複雑になりがちで、結果として混乱を招くことになります。この章では、テキスト検索オブジェクトのテストの際に役に立つ関数を説明します。設定が完全かどうか、パーサと辞書を別々にテストすることなどが可能です。
  </para>

  <sect2 id="textsearch-configuration-testing">
<!--
   <title>Configuration Testing</title>
-->
   <title>設定のテスト</title>

  <para>
<!--
   The function <function>ts_debug</function> allows easy testing of a
   text search configuration.
-->
<function>ts_debug</function>関数により、テキスト検索設定の容易なテストができます。
  </para>

  <indexterm>
   <primary>ts_debug</primary>
  </indexterm>

<synopsis>
ts_debug(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>,
         OUT <replaceable class="PARAMETER">alias</> <type>text</>,
         OUT <replaceable class="PARAMETER">description</> <type>text</>,
         OUT <replaceable class="PARAMETER">token</> <type>text</>,
         OUT <replaceable class="PARAMETER">dictionaries</> <type>regdictionary[]</>,
         OUT <replaceable class="PARAMETER">dictionary</> <type>regdictionary</>,
         OUT <replaceable class="PARAMETER">lexemes</> <type>text[]</>)
         returns setof record
</synopsis>

  <para>
<!--
   <function>ts_debug</> displays information about every token of
   <replaceable class="PARAMETER">document</replaceable> as produced by the
   parser and processed by the configured dictionaries.  It uses the
   configuration specified by <replaceable
   class="PARAMETER">config</replaceable>,
   or <varname>default_text_search_config</varname> if that argument is
   omitted.
-->
<function>ts_debug</>は、パーサが生成し、設定された辞書が処理した<replaceable class="PARAMETER">document</replaceable>のすべてのトークンの情報を表示します。その際、<replaceable class="PARAMETER">config</replaceable>で指定した設定が使われます。引数が省略されると<varname>default_text_search_config</varname>が使われます。
  </para>

  <para>
<!--
   <function>ts_debug</> returns one row for each token identified in the text
   by the parser.  The columns returned are
-->
<function>ts_debug</>は、パーサが認識したテキスト中のトークンを1行につき一つ返します。
返却される列は以下です。

    <itemizedlist  spacing="compact" mark="bullet">
     <listitem>
      <para>
<!--
       <replaceable>alias</> <type>text</> &mdash; short name of the token type
-->
       <replaceable>alias</> <type>text</> &mdash; トークン型の短縮名
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>description</> <type>text</> &mdash; description of the
       token type
-->
       <replaceable>description</> <type>text</> &mdash; トークン型の説明
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>token</> <type>text</> &mdash; text of the token
-->
       <replaceable>token</> <type>text</> &mdash; トークンテキスト
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>dictionaries</> <type>regdictionary[]</> &mdash; the
       dictionaries selected by the configuration for this token type
-->
       <replaceable>dictionaries</> <type>regdictionary[]</> &mdash; 設定によってこのトークン型用に選択された辞書
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>dictionary</> <type>regdictionary</> &mdash; the dictionary
       that recognized the token, or <literal>NULL</> if none did
-->
       <replaceable>dictionary</> <type>regdictionary</> &mdash; トークンを認識した辞書。もし認識した辞書がなければ <literal>NULL</>
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <replaceable>lexemes</> <type>text[]</> &mdash; the lexeme(s) produced
       by the dictionary that recognized the token, or <literal>NULL</> if
       none did; an empty array (<literal>{}</>) means it was recognized as a
       stop word
-->
       <replaceable>lexemes</> <type>text[]</> &mdash; トークンを認識した辞書が生成した語彙素。もしどの辞書も認識しなければ<literal>NULL</>。空の配列(<literal>{}</>)が返った場合は、ストップワードとして認識されたことを示す
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
<!--
   Here is a simple example:
-->
簡単な例を示します。

<screen>
SELECT * FROM ts_debug('english','a fat  cat sat on a mat - it ate a fat rats');
   alias   |   description   | token |  dictionaries  |  dictionary  | lexemes 
-----------+-----------------+-------+----------------+--------------+---------
 asciiword | Word, all ASCII | a     | {english_stem} | english_stem | {}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | fat   | {english_stem} | english_stem | {fat}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | cat   | {english_stem} | english_stem | {cat}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | sat   | {english_stem} | english_stem | {sat}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | on    | {english_stem} | english_stem | {}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | a     | {english_stem} | english_stem | {}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | mat   | {english_stem} | english_stem | {mat}
 blank     | Space symbols   |       | {}             |              | 
 blank     | Space symbols   | -     | {}             |              | 
 asciiword | Word, all ASCII | it    | {english_stem} | english_stem | {}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | ate   | {english_stem} | english_stem | {ate}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | a     | {english_stem} | english_stem | {}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | fat   | {english_stem} | english_stem | {fat}
 blank     | Space symbols   |       | {}             |              | 
 asciiword | Word, all ASCII | rats  | {english_stem} | english_stem | {rat}
</screen>
  </para>

  <para>
<!--
   For a more extensive demonstration, we
   first create a <literal>public.english</literal> configuration and
   Ispell dictionary for the English language:
-->
もう少し高度なデモをお見せするために、まず英語用の<literal>public.english</literal>設定と、Ispell辞書を作ります。
  </para>

<programlisting>
CREATE TEXT SEARCH CONFIGURATION public.english ( COPY = pg_catalog.english );

CREATE TEXT SEARCH DICTIONARY english_ispell (
    TEMPLATE = ispell,
    DictFile = english,
    AffFile = english,
    StopWords = english
);

ALTER TEXT SEARCH CONFIGURATION public.english
   ALTER MAPPING FOR asciiword WITH english_ispell, english_stem;
</programlisting>

<screen>
SELECT * FROM ts_debug('public.english','The Brightest supernovaes');
   alias   |   description   |    token    |         dictionaries          |   dictionary   |   lexemes   
-----------+-----------------+-------------+-------------------------------+----------------+-------------
 asciiword | Word, all ASCII | The         | {english_ispell,english_stem} | english_ispell | {}
 blank     | Space symbols   |             | {}                            |                | 
 asciiword | Word, all ASCII | Brightest   | {english_ispell,english_stem} | english_ispell | {bright}
 blank     | Space symbols   |             | {}                            |                | 
 asciiword | Word, all ASCII | supernovaes | {english_ispell,english_stem} | english_stem   | {supernova}
</screen>

  <para>
<!--
   In this example, the word <literal>Brightest</> was recognized by the
   parser as an <literal>ASCII word</literal> (alias <literal>asciiword</literal>).
   For this token type the dictionary list is
   <literal>english_ispell</> and
   <literal>english_stem</literal>. The word was recognized by
   <literal>english_ispell</literal>, which reduced it to the noun
   <literal>bright</literal>. The word <literal>supernovaes</literal> is
   unknown to the <literal>english_ispell</literal> dictionary so it
   was passed to the next dictionary, and, fortunately, was recognized (in
   fact, <literal>english_stem</literal> is a Snowball dictionary which
   recognizes everything; that is why it was placed at the end of the
   dictionary list).
-->
この例では、単語<literal>Brightest</>は、<literal>ASCII word</literal> (別名は<literal>asciiword</literal>)として認識されています。
このトークン型のための辞書リストは<literal>english_ispell</> と<literal>english_stem</literal>です。この単語は<literal>english_ispell</literal>に認識され、名詞<literal>bright</literal>へと縮退されています。単語<literal>supernovaes</literal>は<literal>english_ispell</literal>辞書には認識されず、次の辞書に渡され、幸い認識されました(実際には、<literal>english_stem</literal>はSnowball辞書で、何でも認識します。それで、この辞書は辞書リストの最後に置かれているわけです)。
  </para>

  <para>
<!--
   The word <literal>The</literal> was recognized by the
   <literal>english_ispell</literal> dictionary as a stop word (<xref
   linkend="textsearch-stopwords">) and will not be indexed.
   The spaces are discarded too, since the configuration provides no
   dictionaries at all for them.
-->
単語<literal>The</literal>は、<literal>english_ispell</literal>辞書によってストップワード(<xref linkend="textsearch-stopwords">)として認識されており、インデックス付けされません。空白も捨てられます。この設定では空白に関する辞書が提供されていないからです。
  </para>

  <para>
<!--
   You can reduce the width of the output by explicitly specifying which columns
   you want to see:
-->
明示的に見たい列を指定することにより、出力の幅を減らすことができます。

<screen>
SELECT alias, token, dictionary, lexemes
FROM ts_debug('public.english','The Brightest supernovaes');
   alias   |    token    |   dictionary   |   lexemes   
-----------+-------------+----------------+-------------
 asciiword | The         | english_ispell | {}
 blank     |             |                | 
 asciiword | Brightest   | english_ispell | {bright}
 blank     |             |                | 
 asciiword | supernovaes | english_stem   | {supernova}
</screen>
  </para>

  </sect2>

  <sect2 id="textsearch-parser-testing">
<!--
   <title>Parser Testing</title>
-->
   <title>パーサのテスト</title>

  <para>
<!--
   The following functions allow direct testing of a text search parser.
-->
次にあげた関数により、テキスト検索パーサを直接テストすることができます。
  </para>

  <indexterm>
   <primary>ts_parse</primary>
  </indexterm>

<synopsis>
ts_parse(<replaceable class="PARAMETER">parser_name</replaceable> <type>text</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>,
         OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>) returns <type>setof record</>
ts_parse(<replaceable class="PARAMETER">parser_oid</replaceable> <type>oid</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>,
         OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>) returns <type>setof record</>
</synopsis>

  <para>
<!--
   <function>ts_parse</> parses the given <replaceable>document</replaceable>
   and returns a series of records, one for each token produced by
   parsing. Each record includes a <varname>tokid</varname> showing the
   assigned token type and a <varname>token</varname> which is the text of the
   token.  For example:
-->
<function>ts_parse</>は与えられた<replaceable>document</replaceable>をパースし、パーサが生成したトークンを1行に1個もつ一連のレコードを返します。それぞれのレコードには、割り当てられたトークン型を示す<varname>tokid</varname>と、テキストのトークンである<varname>token</varname>が含まれます。
例を示します。

<screen>
SELECT * FROM ts_parse('default', '123 - a number');
 tokid | token
-------+--------
    22 | 123
    12 |
    12 | -
     1 | a
    12 |
     1 | number
</screen>
  </para>

  <indexterm>
   <primary>ts_token_type</primary>
  </indexterm>

<synopsis>
ts_token_type(<replaceable class="PARAMETER">parser_name</> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>,
              OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>) returns <type>setof record</>
ts_token_type(<replaceable class="PARAMETER">parser_oid</> <type>oid</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>,
              OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>) returns <type>setof record</>
</synopsis>

  <para>
<!--
   <function>ts_token_type</> returns a table which describes each type of
   token the specified parser can recognize.  For each token type, the table
   gives the integer <varname>tokid</varname> that the parser uses to label a
   token of that type, the <varname>alias</varname> that names the token type
   in configuration commands, and a short <varname>description</varname>.  For
   example:
-->
<function>ts_token_type</>は、指定したパーサが認識できるトークン型を記述したテーブルを返します。各々のトークン型に対し、パーサがトークン型をラベル付けするのに使用する整数<varname>tokid</varname>、設定コマンド中のトークンの名前である<varname>alias</varname>、簡単な説明である<varname>description</varname>が含まれます。
例を示します。

<screen>
SELECT * FROM ts_token_type('default');
 tokid |      alias      |               description                
-------+-----------------+------------------------------------------
     1 | asciiword       | Word, all ASCII
     2 | word            | Word, all letters
     3 | numword         | Word, letters and digits
     4 | email           | Email address
     5 | url             | URL
     6 | host            | Host
     7 | sfloat          | Scientific notation
     8 | version         | Version number
     9 | hword_numpart   | Hyphenated word part, letters and digits
    10 | hword_part      | Hyphenated word part, all letters
    11 | hword_asciipart | Hyphenated word part, all ASCII
    12 | blank           | Space symbols
    13 | tag             | XML tag
    14 | protocol        | Protocol head
    15 | numhword        | Hyphenated word, letters and digits
    16 | asciihword      | Hyphenated word, all ASCII
    17 | hword           | Hyphenated word, all letters
    18 | url_path        | URL path
    19 | file            | File or path name
    20 | float           | Decimal notation
    21 | int             | Signed integer
    22 | uint            | Unsigned integer
    23 | entity          | XML entity
</screen>
   </para>

  </sect2>

  <sect2 id="textsearch-dictionary-testing">
<!--
   <title>Dictionary Testing</title>
-->
   <title>辞書のテスト</title>

   <para>
<!--
    The <function>ts_lexize</> function facilitates dictionary testing.
-->
<function>ts_lexize</>関数は辞書のテストを支援します。
   </para>

   <indexterm>
    <primary>ts_lexize</primary>
   </indexterm>

<synopsis>
ts_lexize(<replaceable class="PARAMETER">dict</replaceable> <type>regdictionary</>, <replaceable class="PARAMETER">token</replaceable> <type>text</>) returns <type>text[]</>
</synopsis>

   <para>
<!--
    <function>ts_lexize</> returns an array of lexemes if the input
    <replaceable>token</replaceable> is known to the dictionary,
    or an empty array if the token
    is known to the dictionary but it is a stop word, or
    <literal>NULL</literal> if it is an unknown word.
-->
<function>ts_lexize</>は、入力<replaceable>token</replaceable>が辞書に認識されれば語彙素の配列を返します。辞書に認識され、それがストップワードである場合には空の配列を返します。認識されなければ<literal>NULL</literal>を返します。
   </para>

   <para>
<!--
    Examples:
-->
例:

<screen>
SELECT ts_lexize('english_stem', 'stars');
 ts_lexize
-----------
 {star}

SELECT ts_lexize('english_stem', 'a');
 ts_lexize
-----------
 {}
</screen>
   </para>

   <note>
    <para>
<!--
     The <function>ts_lexize</function> function expects a single
     <emphasis>token</emphasis>, not text. Here is a case
     where this can be confusing:
-->
<function>ts_lexize</function>関数には、テキストではなく単一の<emphasis>トークン</emphasis>を与えます。これを間違えると次のようになります。

<screen>
SELECT ts_lexize('thesaurus_astro','supernovae stars') is null;
 ?column?
----------
 t
</screen>

<!--
     The thesaurus dictionary <literal>thesaurus_astro</literal> does know the
     phrase <literal>supernovae stars</literal>, but <function>ts_lexize</>
     fails since it does not parse the input text but treats it as a single
     token. Use <function>plainto_tsquery</> or <function>to_tsvector</> to
     test thesaurus dictionaries, for example:
-->
類語辞書<literal>thesaurus_astro</literal>は語句<literal>supernovae stars</literal>を認識しますが、<function>ts_lexize</>はしません。なぜなら、入力をテキストではなく、単一のトークンとして扱うからです。類語辞書をテストするには、<function>plainto_tsquery</>または<function>to_tsvector</>を使ってください。例を示します。

<screen>
SELECT plainto_tsquery('supernovae stars');
 plainto_tsquery
-----------------
 'sn'
</screen>
    </para>
   </note>

  </sect2>

 </sect1>

 <sect1 id="textsearch-indexes">
<!--
  <title>GiST and GIN Index Types</title>
-->
  <title>GiSTおよびGINインデックス種類</title>

  <indexterm zone="textsearch-indexes">
   <primary>text search</primary>
   <secondary>indexes</secondary>
  </indexterm>

  <para>
<!--
   There are two kinds of indexes that can be used to speed up full text
   searches.
   Note that indexes are not mandatory for full text searching, but in
   cases where a column is searched on a regular basis, an index is
   usually desirable.
-->
全文検索を高速化するために、2種類のインデックスが使えます。全文検索のためにインデックスが必須だと言うわけではないことを言っておかなければなりませんが、日常的に検索される列には、インデックスを使った方が良いでしょう。

   <variablelist>

    <varlistentry>

     <term>
     <indexterm zone="textsearch-indexes">
      <primary>index</primary>
      <secondary>GiST</secondary>
      <tertiary>text search</tertiary>
     </indexterm>

      <literal>CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING gist(<replaceable>column</replaceable>);</literal>
     </term>

     <listitem>
      <para>
<!--
       Creates a GiST (Generalized Search Tree)-based index.
       The <replaceable>column</replaceable> can be of <type>tsvector</> or
       <type>tsquery</> type.
-->
GiST (Generalized Search Tree)インデックスを作ります。<replaceable>column</replaceable>は <type>tsvector</> または<type>tsquery</> 型です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>

     <term>
     <indexterm zone="textsearch-indexes">
      <primary>index</primary>
      <secondary>GIN</secondary>
      <tertiary>text search</tertiary>
     </indexterm>

      <literal>CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING gin(<replaceable>column</replaceable>);</literal>
     </term>

     <listitem>
      <para>
<!--
       Creates a GIN (Generalized Inverted Index)-based index.
       The <replaceable>column</replaceable> must be of <type>tsvector</> type.
-->
GIN (Generalized Inverted Index)インデックスを作ります。
<replaceable>column</replaceable>は<type>tsvector</>型でなければなりません。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <para>
<!--
   There are substantial performance differences between the two index types,
   so it is important to understand their characteristics.
-->
この2つのインデックス形式には、性能上の大きな違いがあります。ですので、それらの特長を理解しておくことが重要です.
  </para>

  <para>
<!--
   A GiST index is <firstterm>lossy</firstterm>, meaning that the index
   may produce false matches, and it is necessary
   to check the actual table row to eliminate such false matches.
   (<productname>PostgreSQL</productname> does this automatically when needed.)
   GiST indexes are lossy because each document is represented in the
   index by a fixed-length signature. The signature is generated by hashing
   each word into a single bit in an n-bit string, with all these bits OR-ed
   together to produce an n-bit document signature.  When two words hash to
   the same bit position there will be a false match.  If all words in
   the query have matches (real or false) then the table row must be
   retrieved to see if the match is correct.
-->
GiSTインデックスは、<firstterm>非可逆</firstterm>です。つまり、インデックスは間違った結果を返すかも知れないので、間違った結果を排除するために、テーブルの行をチェックすることが必要です。<productname>PostgreSQL</productname>はこの処理が必要とされた時に自動的に行います。
GiSTインデックスが非可逆なのは、インデックス中の各文書が固定長の署名によって表現されているからです。署名は、各々の単語をハッシュして単一なビットにして、これらのビットをnビットの文書署名にORし、nビットの列中のビットにすることで実現されています。2つの単語が同じビット位置を生成すると、間違った一致が起こります。問い合わせ対象のすべての単語が照合すると(それが正しいか間違っているかは別として)、その照合が正しいものかどうかテーブルの行を取得して調べなければなりません。
  </para>

  <para>
<!--
   Lossiness causes performance degradation due to unnecessary fetches of table
   records that turn out to be false matches.  Since random access to table
   records is slow, this limits the usefulness of GiST indexes.  The
   likelihood of false matches depends on several factors, in particular the
   number of unique words, so using dictionaries to reduce this number is
   recommended.
-->
非可逆性は、間違った照合によるテーブルからの不必要なデータ取得のため、性能を劣化させます。テーブルへのランダムアクセスは遅いので、GiSTインデックスの有用性は制限されています。誤った照合がどの位あるかという可能性はいくつか要因によりますが、とりわけユニークな単語の数に依存します。ですから、辞書を使ってユニークな単語の数を減らすことをお勧めします。
  </para>

  <para>
<!--
   GIN indexes are not lossy for standard queries, but their performance
   depends logarithmically on the number of unique words.
   (However, GIN indexes store only the words (lexemes) of <type>tsvector</>
   values, and not their weight labels.  Thus a table row recheck is needed
   when using a query that involves weights.)
-->
GINインデックスは標準の問い合わせに対しては非可逆ではありませんが、その性能はユニークな単語の数の対数に依存します。(しかしながら、GINインデックスはtsvector値の中の単語(語彙素)のみを保持しており、重み付けラベルは持っていません。したがって、重み付けを伴う問合わせではテーブルの行を再チェックしなければなりません。)
  </para>

  <para>
<!--
   In choosing which index type to use, GiST or GIN, consider these
   performance differences:
-->
GiST、GINのどちらのインデックス形式を選ぶにあたっては、以下の性能上の違いを考慮してください。

   <itemizedlist  spacing="compact" mark="bullet">
    <listitem>
     <para>
<!--
      GIN index lookups are about three times faster than GiST
-->
GINインデックスの検索はGiSTの約3倍高速です
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      GIN indexes take about three times longer to build than GiST
-->
GINインデックスの構築はGiSTの約3倍時間がかかります
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      GIN indexes are moderately slower to update than GiST indexes, but
      about 10 times slower if fast-update support was disabled
      (see <xref linkend="gin-fast-update"> for details)
-->
GINインデックスに対する更新はGiSTよりもそこそこ低速ですが、もし高速更新サポートを無効にしている場合は10倍の低速になります(詳細は<xref linkend="gin-fast-update">を見てください)
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      GIN indexes are two-to-three times larger than GiST indexes
-->
GINインデックスは、GiSTインデックスより2から3倍大きいです
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   As a rule of thumb, <acronym>GIN</acronym> indexes are best for static data
   because lookups are faster.  For dynamic data, GiST indexes are
   faster to update.  Specifically, <acronym>GiST</acronym> indexes are very
   good for dynamic data and fast if the number of unique words (lexemes) is
   under 100,000, while <acronym>GIN</acronym> indexes will handle 100,000+
   lexemes better but are slower to update.
-->
大雑把に言うと、<acronym>GIN</acronym>インデックスは検索が高速なので、静的なデータにもっとも向いています。動的なデータには、GiSTインデックスの更新が高速です。とりわけ、<acronym>GiST</acronym>インデックスは、動的なデータに非常に向いており、ユニークな単語(語彙素)が100,000未満ならば高速です。一方<acronym>GIN</acronym>インデックスは100,000以上の語彙素をよりうまく扱うことができますが、更新が遅いです。
  </para>

  <para>
<!--
   Note that <acronym>GIN</acronym> index build time can often be improved
   by increasing <xref linkend="guc-maintenance-work-mem">, while
   <acronym>GiST</acronym> index build time is not sensitive to that
   parameter.
-->
<acronym>GIN</acronym>インデックスの構築時間は<xref linkend="guc-maintenance-work-mem">を増やすことによってしばしば改善することができることに注意してください。一方<acronym>GiST</acronym>インデックスの構築時間にはあまりそのパラメータは効きません。
  </para>

  <para>
<!--
   Partitioning of big collections and the proper use of GiST and GIN indexes
   allows the implementation of very fast searches with online update.
   Partitioning can be done at the database level using table inheritance,
   or by distributing documents over
   servers and collecting search results using the <xref linkend="dblink">
   module. The latter is possible because ranking functions use
   only local information.
-->
大きなデータをパーティショニングし、GiST、GINインデックスを使うことによってオンラインの更新を伴いながら、非常に高速な検索を実現することができます。パーティショニングは、継承を使ってデータベースレベルで実現できます。あるいは、文書を複数のサーバに分散させ、<xref linkend="dblink">モジュールを使って検索結果を集約できます。これは、ランキング関数がローカルな情報しか使わないために可能になります。
  </para>

 </sect1>

 <sect1 id="textsearch-psql">
<!--
  <title><application>psql</> Support</title>
-->
  <title><application>psql</>サポート</title>

  <para>
<!--
   Information about text search configuration objects can be obtained
   in <application>psql</application> using a set of commands:
-->
psqlでテキスト検索設定オブジェクトに関する情報は、コマンドの集まりを使って取得できます。
<synopsis>
\dF{d,p,t}<optional>+</optional> <optional>PATTERN</optional>
</synopsis>
   An optional <literal>+</literal> produces more details.
  </para>

  <para>
<!--
   The optional parameter <literal>PATTERN</literal> can be the name of
   a text search object, optionally schema-qualified.  If
   <literal>PATTERN</literal> is omitted then information about all
   visible objects will be displayed.  <literal>PATTERN</literal> can be a
   regular expression and can provide <emphasis>separate</emphasis> patterns
   for the schema and object names.  The following examples illustrate this:
-->
オプションパラメータの<literal>PATTERN</literal>はテキスト検索オブジェクトの名前にすることができます。オプションとしてスキーマ修飾することができます。<literal>PATTERN</literal>が省略されると、すべての可視的なオブジェクトが表示されます。<literal>PATTERN</literal>は正規表現を与えることができ、さらにスキーマとオブジェクト名に対して<emphasis>別々の</emphasis>パターンを与えることができます。
次の例はこれを説明するものです。

<screen>
=&gt; \dF *fulltext*
       List of text search configurations
 Schema |  Name        | Description
--------+--------------+-------------
 public | fulltext_cfg |
</screen>

<screen>
=&gt; \dF *.fulltext*
       List of text search configurations
 Schema   |  Name        | Description
----------+----------------------------
 fulltext | fulltext_cfg |
 public   | fulltext_cfg |
</screen>

<!--
   The available commands are:
-->
以下のコマンドが利用できます。
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>\dF<optional>+</optional> <optional>PATTERN</optional></literal></term>
    <listitem>
     <para>
<!--
      List text search configurations (add <literal>+</> for more detail).
-->
テキスト検索設定を表示します(<literal>+</>追加で詳細表示)。
<screen>
=&gt; \dF russian
            List of text search configurations
   Schema   |  Name   |            Description             
------------+---------+------------------------------------
 pg_catalog | russian | configuration for russian language

=&gt; \dF+ russian
Text search configuration "pg_catalog.russian"
Parser: "pg_catalog.default"
      Token      | Dictionaries 
-----------------+--------------
 asciihword      | english_stem
 asciiword       | english_stem
 email           | simple
 file            | simple
 float           | simple
 host            | simple
 hword           | russian_stem
 hword_asciipart | english_stem
 hword_numpart   | simple
 hword_part      | russian_stem
 int             | simple
 numhword        | simple
 numword         | simple
 sfloat          | simple
 uint            | simple
 url             | simple
 url_path        | simple
 version         | simple
 word            | russian_stem
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>\dFd<optional>+</optional> <optional>PATTERN</optional></literal></term>
    <listitem>
     <para>
<!--
      List text search dictionaries (add <literal>+</> for more detail).
-->
テキスト検索辞書を表示します(<literal>+</>追加で詳細表示)。
<screen>
=&gt; \dFd
                            List of text search dictionaries
   Schema   |      Name       |                        Description                        
------------+-----------------+-----------------------------------------------------------
 pg_catalog | danish_stem     | snowball stemmer for danish language
 pg_catalog | dutch_stem      | snowball stemmer for dutch language
 pg_catalog | english_stem    | snowball stemmer for english language
 pg_catalog | finnish_stem    | snowball stemmer for finnish language
 pg_catalog | french_stem     | snowball stemmer for french language
 pg_catalog | german_stem     | snowball stemmer for german language
 pg_catalog | hungarian_stem  | snowball stemmer for hungarian language
 pg_catalog | italian_stem    | snowball stemmer for italian language
 pg_catalog | norwegian_stem  | snowball stemmer for norwegian language
 pg_catalog | portuguese_stem | snowball stemmer for portuguese language
 pg_catalog | romanian_stem   | snowball stemmer for romanian language
 pg_catalog | russian_stem    | snowball stemmer for russian language
 pg_catalog | simple          | simple dictionary: just lower case and check for stopword
 pg_catalog | spanish_stem    | snowball stemmer for spanish language
 pg_catalog | swedish_stem    | snowball stemmer for swedish language
 pg_catalog | turkish_stem    | snowball stemmer for turkish language
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
   <term><literal>\dFp<optional>+</optional> <optional>PATTERN</optional></literal></term>
    <listitem>
     <para>
<!--
      List text search parsers (add <literal>+</> for more detail).
-->
テキスト検索パーサを表示します(<literal>+</>追加で詳細表示)。
<screen>
=&gt; \dFp
        List of text search parsers
   Schema   |  Name   |     Description     
------------+---------+---------------------
 pg_catalog | default | default word parser
=&gt; \dFp+
    Text search parser "pg_catalog.default"
     Method      |    Function    | Description 
-----------------+----------------+-------------
 Start parse     | prsd_start     | 
 Get next token  | prsd_nexttoken | 
 End parse       | prsd_end       | 
 Get headline    | prsd_headline  | 
 Get token types | prsd_lextype   | 

        Token types for parser "pg_catalog.default"
   Token name    |               Description                
-----------------+------------------------------------------
 asciihword      | Hyphenated word, all ASCII
 asciiword       | Word, all ASCII
 blank           | Space symbols
 email           | Email address
 entity          | XML entity
 file            | File or path name
 float           | Decimal notation
 host            | Host
 hword           | Hyphenated word, all letters
 hword_asciipart | Hyphenated word part, all ASCII
 hword_numpart   | Hyphenated word part, letters and digits
 hword_part      | Hyphenated word part, all letters
 int             | Signed integer
 numhword        | Hyphenated word, letters and digits
 numword         | Word, letters and digits
 protocol        | Protocol head
 sfloat          | Scientific notation
 tag             | XML tag
 uint            | Unsigned integer
 url             | URL
 url_path        | URL path
 version         | Version number
 word            | Word, all letters
(23 rows)
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
   <term><literal>\dFt<optional>+</optional> <optional>PATTERN</optional></literal></term>
    <listitem>
     <para>
<!--
      List text search templates (add <literal>+</> for more detail).
-->
テキスト検索テンプレートを表示します(<literal>+</>追加で詳細表示)。
<screen>
=&gt; \dFt
                           List of text search templates
   Schema   |   Name    |                        Description                        
------------+-----------+-----------------------------------------------------------
 pg_catalog | ispell    | ispell dictionary
 pg_catalog | simple    | simple dictionary: just lower case and check for stopword
 pg_catalog | snowball  | snowball stemmer
 pg_catalog | synonym   | synonym dictionary: replace word by its synonym
 pg_catalog | thesaurus | thesaurus dictionary: phrase by phrase substitution
</screen>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="textsearch-limitations">
<!--
  <title>Limitations</title>
-->
  <title>制限事項</title>

  <para>
<!--
   The current limitations of <productname>PostgreSQL</productname>'s
   text search features are:
-->
<productname>PostgreSQL</productname>のテキスト検索機能の制限事項は以下です。
   <itemizedlist  spacing="compact" mark="bullet">
    <listitem>
<!--
     <para>The length of each lexeme must be less than 2K bytes</para>
-->
     <para>各々の語彙素の長さは2Kバイト未満でなければなりません</para>
    </listitem>
    <listitem>
<!--
     <para>The length of a <type>tsvector</type> (lexemes + positions) must be
     less than 1 megabyte</para>
-->
     <para><type>tsvector</type>の長さ (語彙素 + 位置)は1Mバイト未満でなければなりません</para>
    </listitem>
    <listitem>
     <!-- 原文コメント TODO: number of lexemes in what?  This is unclear -->
<!--
     <para>The number of lexemes must be less than
     2<superscript>64</superscript></para>
-->
     <para>語彙素の数は2<superscript>64</superscript>未満でなければなりません</para>
    </listitem>
    <listitem>
<!--
     <para>Position values in <type>tsvector</> must be greater than 0 and
     no more than 16,383</para>
-->
     <para><type>tsvector</>の位置量は、0より大きくかつ16,383以下でなければなりません</para>
    </listitem>
    <listitem>
<!--
     <para>No more than 256 positions per lexeme</para>
-->
     <para>語彙素の位置情報は256以下でなければなりません</para>
    </listitem>
    <listitem>
<!--
     <para>The number of nodes (lexemes + operators) in a <type>tsquery</type>
     must be less than 32,768</para>
-->
     <para><type>tsquery</type>中のノードの数(語彙素 + 演算子)は32,768未満でなければなりません</para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   For comparison, the <productname>PostgreSQL</productname> 8.1 documentation
   contained 10,441 unique words, a total of 335,420 words, and the most
   frequent word <quote>postgresql</> was mentioned 6,127 times in 655
   documents.
-->
比較対象として述べておくと、<productname>PostgreSQL</productname>8.1 のドキュメントは10,441のユニークな単語を含み、全部の単語数は335,420で、最頻出の単語<quote>postgresql</>は655の文書中に6,127回出現しました。
  </para>

   <!-- 原文コメント TODO we need to put a date on these numbers? -->
  <para>
<!--
   Another example &mdash; the <productname>PostgreSQL</productname> mailing
   list archives contained 910,989 unique words with 57,491,343 lexemes in
   461,020 messages.
-->
別の例です &mdash; <productname>PostgreSQL</productname>メーリングリストのアーカイブは910,989のユニークな単語を含み、461,020のメッセージ中に57,491,343の語彙素がありました。
  </para>

 </sect1>

 <sect1 id="textsearch-migration">
<!--
  <title>Migration from Pre-8.3 Text Search</title>
-->
  <title>8.3以前のテキスト検索からの移行</title>

  <para>
<!--
   Applications that use the <xref linkend="tsearch2">
   module for text searching will need some adjustments to work
   with the
   built-in features:
-->
テキスト検索のために<xref linkend="tsearch2">モジュールを使っていたアプリケーションは、組み込みの機能に対して多少の調整が必要になります。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     Some functions have been renamed or had small adjustments in their
     argument lists, and all of them are now in the <literal>pg_catalog</>
     schema, whereas in a previous installation they would have been in
     <literal>public</> or another non-system schema.  There is a new
     version of <application>tsearch2</>
     that provides a compatibility layer to solve most problems in this
     area.
-->
いくつかの関数は名前が変わり、引数が変更され、すべて<literal>pg_catalog</>スキーマに入りました。以前はこれらの関数は<literal>public</>か、あるいはほかのシステム用でないスキーマに格納されていました。新しいバージョンの<application>tsearch2</>が、この種の互換性問題を解決するためのレイヤーとして提供されています。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     The old <application>tsearch2</> functions and other objects
     <emphasis>must</> be suppressed when loading <application>pg_dump</>
     output from a pre-8.3 database.  While many of them won't load anyway,
     a few will and then cause problems.  One simple way to deal with this
     is to load the new <application>tsearch2</> module before restoring
     the dump; then it will block the old objects from being loaded.
-->
古い<application>tsearch2</>関数と、その他のオブジェクトは、8.3以前のデータベースのダンプをロードする際に、<emphasis>無効にしておかなければなりません</>。ほとんどのものはどのみちロードできませんが、2, 3ロードされ、悪さをするものがあります。この問題に対処する簡単な方法は、ダンプファイルをリストアする前に、新しい<application>tsearch2</>モジュールをロードしておくことです。そうすれば、古いオブジェクトがロードされるのを防ぐことができます。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Text search configuration setup is completely different now.
     Instead of manually inserting rows into configuration tables,
     search is configured through the specialized SQL commands shown
     earlier in this chapter.  There is no automated
     support for converting an existing custom configuration for 8.3;
     you're on your own here.
-->
テキスト検索設定をセットアップする方法がまったく変わりました。設定テーブルに手動で行を挿入する代わりに、この章の最初の方で説明した特別なSQLコマンドを使って設定するようになりました。既存の設定を8.3用に自動的に変換する方法は提供されていません。自分でやってください。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Most types of dictionaries rely on some outside-the-database
     configuration files.  These are largely compatible with pre-8.3
     usage, but note the following differences:
-->
ほとんどの形式の辞書はデータベース外の設定ファイルに依存しています。これらは8.3以前の使い方と概ね互換性がありますが、一部以下のような違いがあります。

     <itemizedlist  spacing="compact" mark="bullet">
      <listitem>
       <para>
<!--
        Configuration files now must be placed in a single specified
        directory (<filename>$SHAREDIR/tsearch_data</>), and must have
        a specific extension depending on the type of file, as noted
        previously in the descriptions of the various dictionary types.
        This restriction was added to forestall security problems.
-->
設定ファイルは、単一のディレクトリ(<filename>$SHAREDIR/tsearch_data</>)に格納しておかなければなりません。そして、以前いろいろな種類の辞書形式について述べたように、その種類に応じて特定の拡張子を持たなければなりません。この制限はあらかじめセキュリティ上の問題を考慮して追加されました。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Configuration files must be encoded in UTF-8 encoding,
        regardless of what database encoding is used.
-->
設定ファイルは、データベースエンコーディングが何であろうと、UTF-8エンコーディングで符号化しておかなければなりません。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        In thesaurus configuration files, stop words must be marked with
        <literal>?</>.
-->
同義語辞書設定ファイルでは、ストップワードは<literal>?</>でマークしておかなければなりません。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </listitem>

  </itemizedlist>

 </sect1>

</chapter>
