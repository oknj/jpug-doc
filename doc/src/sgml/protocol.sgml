<!-- doc/src/sgml/protocol.sgml -->

<chapter id="protocol">
<!--
 <title>Frontend/Backend Protocol</title>
-->
<title>フロントエンド/バックエンドプロトコル</title>

 <indexterm zone="protocol">
<!--
  <primary>protocol</primary>
  <secondary>frontend-backend</secondary>
-->
<primary>プロトコル</primary>
<secondary>フロントエンド/バックエンド</secondary>
 </indexterm>

 <para>
<!--
  <productname>PostgreSQL</productname> uses a message-based protocol
  for communication between frontends and backends (clients and servers).
  The protocol is supported over <acronym>TCP/IP</acronym> and also over
  Unix-domain sockets.  Port number 5432 has been registered with IANA as
  the customary TCP port number for servers supporting this protocol, but
  in practice any non-privileged port number can be used.
-->
<application>PostgreSQL</application>はフロントエンドとバックエンド（クライアントとサーバ）の通信にメッセージベースのプロトコルを使用します。
このプロトコルは<Acronym>TCP/IP</Acronym>に加え、Unixドメインソケットをサポートします。
ポート番号5432は、このプロトコルをサポートするサーバ用のTCPポートとしてIANAに登録されています。
しかし、実際には任意の非特権ポート番号を使用することができます。
 </para>

 <para>
<!--
  This document describes version 3.0 of the protocol, implemented in
  <productname>PostgreSQL</productname> 7.4 and later.  For descriptions
  of the earlier protocol versions, see previous releases of the
  <productname>PostgreSQL</productname> documentation.  A single server
  can support multiple protocol versions.  The initial
  startup-request message tells the server which protocol version the
  client is attempting to use, and then the server follows that protocol
  if it is able.
-->
この文書は<application>PostgreSQL</application> 7.4以降で実装されたプロトコル3.0バージョンについて記載します。
以前のプロトコルバージョンについての説明は、<productname>PostgreSQL</productname>の以前のリリースの文書を参照してください。
初めの開始要求メッセージは、サーバに対し、クライアントが使用する予定のプロトコルバージョンを通知します。
その後、サーバは可能であればそのプロトコルに従います。
 </para>

  <para>
<!--
   In order to serve multiple clients efficiently, the server launches
   a new <quote>backend</> process for each client.
   In the current implementation, a new child
   process is created immediately after an incoming connection is detected.
   This is transparent to the protocol, however.  For purposes of the
   protocol, the terms <quote>backend</> and <quote>server</> are
   interchangeable; likewise <quote>frontend</> and <quote>client</>
   are interchangeable.
-->
複数のクライアントにサービスを効率的に提供するために、サーバは各クライアント毎に新規の<quote>バックエンド</>プロセスを起動します。
現在の実装では、サーバに接続が届いたことを検知すると即座に新しい子プロセスが生成されます。
しかし、これはプロトコルに対して透過的です。
プロトコルという意味では、<quote>バックエンド</>と<quote>サーバ</>という用語は相互交換可能です。
同様に<quote>フロントエンド</>と<quote>クライアント</>も相互交換可能です。
  </para>

 <sect1 id="protocol-overview">
<!--
  <title>Overview</title>
-->
<title>概要</title>

  <para>
<!--
   The protocol has separate phases for startup and normal operation.
   In the startup phase, the frontend opens a connection to the server
   and authenticates itself to the satisfaction of the server.  (This might
   involve a single message, or multiple messages depending on the
   authentication method being used.)  If all goes well, the server then sends
   status information to the frontend, and finally enters normal operation.
   Except for the initial startup-request message, this part of the
   protocol is driven by the server.
-->
このプロトコルでは、接続開始と通常操作で段階が分かれています。
接続開始段階で、フロントエンドはサーバへの接続を開き、サーバの義務を履行できるよう自身を証明します。
（これは使用する認証方法に応じて、単一のメッセージになったり、複数のメッセージになったりします。）
すべてうまく行けば、サーバはフロントエンドに状態情報を送信し、最終的に通常操作段階に入ります。
初期の開始要求メッセージを除いて、プロトコルのこの部分はサーバによって駆動されます。
  </para>

  <para>
<!--
   During normal operation, the frontend sends queries and
   other commands to the backend, and the backend sends back query results
   and other responses.  There are a few cases (such as <command>NOTIFY</>)
   wherein the
   backend will send unsolicited messages, but for the most part this portion
   of a session is driven by frontend requests.
-->
通常操作の間、フロントエンドは問い合わせやその他のコマンドをバックエンドに送信し、バックエンドは問い合わせ結果やその他の応答を返送します。
（<command>NOTIFY</>のように）バックエンドから依頼されずにメッセージが送信されるまれな場合がありますが、セッションのこの部分のほとんどはフロントエンドの要求によって駆動されます。
  </para>

  <para>
<!--
   Termination of the session is normally by frontend choice, but can be
   forced by the backend in certain cases.  In any case, when the backend
   closes the connection, it will roll back any open (incomplete) transaction
   before exiting.
-->
セッションの終了は通常フロントエンドが選択することですが、特定の場合はバックエンドによって強制される可能性があります。
どちらの場合でも、バックエンドが接続を閉ざす時、終了前に実行中の（未完の）トランザクションをすべてロールバックします。
  </para>

  <para>
<!--
   Within normal operation, SQL commands can be executed through either of
   two sub-protocols.  In the <quote>simple query</> protocol, the frontend
   just sends a textual query string, which is parsed and immediately
   executed by the backend.  In the <quote>extended query</> protocol,
   processing of queries is separated into multiple steps: parsing,
   binding of parameter values, and execution.  This offers flexibility
   and performance benefits, at the cost of extra complexity.
-->
通常操作中は、SQLコマンドを２つのサブプロトコルのうちのいずれかによって実行することができます。
<quote>簡易問い合わせ</>プロトコルでは、フロントエンドはテキストで問い合わせ文字列を単に送信し、バックエンドによって解析され、即実行されます。
<quote>拡張問い合わせ</>プロトコルでは、問い合わせの処理は、解析、パラメータ値の結び付け、そして実行という複数の段階に分離されます。
これは複雑性が加わりますが、柔軟性と性能という点で利点が生まれます。
  </para>

  <para>
<!--
   Normal operation has additional sub-protocols for special operations
   such as <command>COPY</>.
-->
通常操作には、さらに、<command>COPY</>のような特殊な操作向けのサブプロトコルがあります。
  </para>

 <sect2 id="protocol-message-concepts">
<!--
  <title>Messaging Overview</title>
-->
<title>メッセージ処理の概要</title>

  <para>
<!--
   All communication is through a stream of messages.  The first byte of a
   message identifies the message type, and the next four bytes specify the
   length of the rest of the message (this length count includes itself, but
   not the message-type byte).  The remaining contents of the message are
   determined by the message type.  For historical reasons, the very first
   message sent by the client (the startup message) has no initial
   message-type byte.
-->
すべての通信はメッセージストリームを介します。
メッセージの先頭バイトはメッセージ種類を識別するもの、次の４バイトはメッセージの残りの長さを指定するものです
（この長さにはメッセージ種類バイトは含まれませんが、自身を含んで数えられます）。
残りのメッセージの内容は、メッセージ種類で決まります。
歴史的な理由のため、一番初めにクライアントから送信されるメッセージ（開始メッセージ）にはメッセージ種類バイトはありません。
  </para>

  <para>
<!--
   To avoid losing synchronization with the message stream, both servers and
   clients typically read an entire message into a buffer (using the byte
   count) before attempting to process its contents.  This allows easy
   recovery if an error is detected while processing the contents.  In
   extreme situations (such as not having enough memory to buffer the
   message), the receiver can use the byte count to determine how much
   input to skip before it resumes reading messages.
-->
メッセージストリームの同期ずれを防ぐために、サーバとクライアントの両方は、通常、メッセージの内容を処理し始める前に、（バイト数を使用して）メッセージ全体をバッファ内に読み込みます。
これにより、その内容を処理する時にエラーが検出された場合に、簡単に復旧することができます。
（メッセージをバッファするために十分なメモリがない場合のような）極限状況では、受信側はメッセージの読み取りを再開する前にどれだけの量の入力を飛ばすかどうかを決定するために、バイト数を活用することができます。
  </para>

  <para>
<!--
   Conversely, both servers and clients must take care never to send an
   incomplete message.  This is commonly done by marshaling the entire message
   in a buffer before beginning to send it.  If a communications failure
   occurs partway through sending or receiving a message, the only sensible
   response is to abandon the connection, since there is little hope of
   recovering message-boundary synchronization.
-->
反対に、サーバとクライアントの両方は、不完全なメッセージを決して送信しないように注意しなければなりません。
これは通常、送信する前にバッファ内のメッセージ全体を整列させることで行われます。
メッセージの送受信の途中で通信エラーが発生した場合、メッセージ境界の同期を復旧できる望みはほとんどありませんので、実用的な唯一の応答は通信を中断することです。
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
<!--
   <title>Extended Query Overview</title>
-->
<title>拡張問い合わせの概要</title>

   <para>
<!--
    In the extended-query protocol, execution of SQL commands is divided
    into multiple steps.  The state retained between steps is represented
    by two types of objects: <firstterm>prepared statements</> and
    <firstterm>portals</>.  A prepared statement represents the result of
    parsing and semantic analysis of a textual query string.
    A prepared statement is not in itself ready to execute, because it might
    lack specific values for <firstterm>parameters</>.  A portal represents
    a ready-to-execute or already-partially-executed statement, with any
    missing parameter values filled in.  (For <command>SELECT</> statements,
    a portal is equivalent to an open cursor, but we choose to use a different
    term since cursors don't handle non-<command>SELECT</> statements.)
-->
拡張問い合わせプロトコルでは、SQLコマンドの実行は複数の段階に分割されます。
段階間で保持される状態は、<firstterm>プリペアド文</>と<firstterm>ポータル</>の２種類のオブジェクトで表現されます。
プリペアド文は、テキスト問い合わせ文字列の解析、意味解析を表現します。
プリペアド文は実行準備が整ったことを示すものではありません。
<firstterm>パラメータ</>の特定の値が欠落しているかもしれないからです。
ポータルは、すべてのパラメータ値が設定され、実行準備が整った、あるいは、既に一部実行された文を表現します。
（<command>SELECT</>文では、ポータルは開いているカーソルと等価です。
しかし、カーソルは<command>SELECT</>以外の文を扱いませんので、ここでは異なる用語を使用するよう選択しました。）
   </para>

   <para>
<!--
    The overall execution cycle consists of a <firstterm>parse</> step,
    which creates a prepared statement from a textual query string; a
    <firstterm>bind</> step, which creates a portal given a prepared
    statement and values for any needed parameters; and an
    <firstterm>execute</> step that runs a portal's query.  In the case of
    a query that returns rows (<command>SELECT</>, <command>SHOW</>, etc),
    the execute step can be told to fetch only
    a limited number of rows, so that multiple execute steps might be needed
    to complete the operation.
-->
実行サイクル全体は、テキストの問い合わせ文字列からプリペアド文を生成する<firstterm>解析</>段階、プリペアド文と必要なパラメータ値によりポータルを作成する<firstterm>バインド</>段階、ポータルの問い合わせを実行する<firstterm>実行</>段階からなります。
行を返す問い合わせ（<command>SELECT</>、<command>SHOW</>など）の場合、操作を完了させるために複数の実行段階が必要とすることができるように、実行段階に限定された行数のみを取り出すよう指示することができます。
   </para>

   <para>
<!--
    The backend can keep track of multiple prepared statements and portals
    (but note that these exist only within a session, and are never shared
    across sessions).  Existing prepared statements and portals are
    referenced by names assigned when they were created.  In addition,
    an <quote>unnamed</> prepared statement and portal exist.  Although these
    behave largely the same as named objects, operations on them are optimized
    for the case of executing a query only once and then discarding it,
    whereas operations on named objects are optimized on the expectation
    of multiple uses.
-->
バックエンドは複数のプリペアド文とポータルの経過を追うことができます
（しかし、1つのセッション内でのみ存在可能です。複数のセッションで共有することはできません）。
存在するプリペアド文とポータルは、作成時に割り当てられた名前で参照されます。
さらに、<quote>無名の</>プリペアド文とポータルも存在します。
これらは名前付きのオブジェクトとほとんど同じ動きをしますが、問い合わせを一回だけ実行し、その後に破棄する場合に備えて、これらに対する操作は最適化されています。
一方、名前付きオブジェクトの操作は複数回の使用を想定して最適化されています。
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
<!--
   <title>Formats and Format Codes</title>
-->
<title>書式と書式コード</title>

   <para>
<!--
    Data of a particular data type might be transmitted in any of several
    different <firstterm>formats</>.  As of <productname>PostgreSQL</> 7.4
    the only supported formats are <quote>text</> and <quote>binary</>,
    but the protocol makes provision for future extensions.  The desired
    format for any value is specified by a <firstterm>format code</>.
    Clients can specify a format code for each transmitted parameter value
    and for each column of a query result.  Text has format code zero,
    binary has format code one, and all other format codes are reserved
    for future definition.
-->
特定のデータ型のデータはいくつかの異なる<firstterm>書式</>で転送することができます。
<productname>PostgreSQL</> 7.4の時点でサポートしている書式は<quote>テキスト</>と<quote>バイナリ</>のみですが、プロトコルは将来の拡張に備えて準備をしています。
任意の値の必要な書式は<firstterm>書式コード</>で指定されます。
クライアントは、転送されるパラメータ値それぞれに書式コードを指定することも、問い合わせ結果の列それぞれに書式コードを指定することもできます。
テキストは書式コード0、バイナリは書式コード1です。
他の書式コードは将来の定義用に予約されています。
   </para>

   <para>
<!--
    The text representation of values is whatever strings are produced
    and accepted by the input/output conversion functions for the
    particular data type.  In the transmitted representation, there is
    no trailing null character; the frontend must add one to received
    values if it wants to process them as C strings.
    (The text format does not allow embedded nulls, by the way.)
-->
値のテキスト表現は、特定のデータ型の入出力変換関数で生成され、受け付けられる何らかの文字列です。
転送時の表現では、ヌル終端文字はありません。
フロントエンドでC言語文字列として処理したい場合は、必ず受信した値にヌル終端文字を追加しなければなりません。
（ついでですが、テキスト書式ではヌルを埋め込むことはできません。）
   </para>

   <para>
<!--
    Binary representations for integers use network byte order (most
    significant byte first).  For other data types consult the documentation
    or source code to learn about the binary representation.  Keep in mind
    that binary representations for complex data types might change across
    server versions; the text format is usually the more portable choice.
-->
整数用のバイナリ表現はネットワークバイト順（先頭に最上位バイト）を使用します。
他のデータ型のバイナリ表現については、文書もしくはソースコードを参照してください。
複雑なデータ型のバイナリ表現はサーバのバージョンによって異なる可能性があることに注意してください。
通常、テキスト書式がより移植性が高い選択肢です。
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
<!--
  <title>Message Flow</title>
-->
<title>メッセージの流れ</title>

  <para>
<!--
   This section describes the message flow and the semantics of each
   message type.  (Details of the exact representation of each message
   appear in <xref linkend="protocol-message-formats">.)  There are
   several different sub-protocols depending on the state of the
   connection: start-up, query, function call,
   <command>COPY</command>, and termination.  There are also special
   provisions for asynchronous operations (including notification
   responses and command cancellation), which can occur at any time
   after the start-up phase.
-->
本節では、メッセージの流れと各メッセージ種類のセマンティックスを説明します。
（各メッセージの正確な表現の詳細については<xref linkend="protocol-message-formats">で説明します。）
開始、問い合わせ、関数呼び出し、<command>COPY</command>、終了といった接続状態に応じて、複数の異なるサブプロトコルがあります。
また、開始段階の後の任意の時点で発生する可能性がある、非同期操作（通知応答やコマンドのキャンセルを含む）用の特別な準備もあります。
  </para>

  <sect2>
<!--
   <title>Start-up</title>
-->
<title>開始</title>

   <para>
<!--
    To begin a session, a frontend opens a connection to the server and sends
    a startup message.  This message includes the names of the user and of the
    database the user wants to connect to; it also identifies the particular
    protocol version to be used.  (Optionally, the startup message can include
    additional settings for run-time parameters.)
    The server then uses this information and
    the contents of its configuration files (such as
    <filename>pg_hba.conf</filename>) to determine
    whether the connection is provisionally acceptable, and what additional
    authentication is required (if any).
-->
セッションを開始するために、フロントエンドはサーバへの接続を開き、開始メッセージを送信します。
このメッセージには、ユーザ名と接続を希望するデータベース名が含まれます。
これはまた、使用する特定のプロトコルバージョンを識別します。
（オプションとして、開始メッセージに、実行時パラメータの追加設定を含めることもできます。）
サーバはその後、この情報と設定ファイル（<filename>pg_hba.conf</filename>など）の内容を使用して、接続が暫定的に受け付けられるかどうか、そして（もしあれば）どのような追加認証が必要かを決定します。
   </para>

   <para>
<!--
    The server then sends an appropriate authentication request message,
    to which the frontend must reply with an appropriate authentication
    response message (such as a password).
    For all authentication methods except GSSAPI and SSPI, there is at most
    one request and one response. In some methods, no response
    at all is needed from the frontend, and so no authentication request
    occurs. For GSSAPI and SSPI, multiple exchanges of packets may be needed
    to complete the authentication.
-->
サーバはその後、適切な認証要求メッセージを送信します。
フロントエンドはこれに適切な認証応答メッセージ（パスワードなど）で答えなければなりません。
GSSAPIとSSPIを除くすべての認証方式では、多くても１つの要求と１つの応答が存在します。
認証方式の中には、フロントエンドからの応答をまったく必要としないものもあり、その場合、認証要求も発生しません。
GSSAPIとSSPIでは認証を完了するために複数のパケットの交換が必要となるかもしれません。
   </para>

   <para>
<!--
    The authentication cycle ends with the server either rejecting the
    connection attempt (ErrorResponse), or sending AuthenticationOk.
-->
認証サイクルは、サーバによって接続要求を拒絶する（ErrorResponse）か、あるいはAuthenticationOkを送信することで終わります。
   </para>

   <para>
<!--
    The possible messages from the server in this phase are:
-->
この段階でサーバから送信される可能性があるメッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        The connection attempt has been rejected.
        The server then immediately closes the connection.
-->
接続試行が拒絶されました。
サーバはその後即座に接続を閉ざします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
<!--
        The authentication exchange is successfully completed.
-->
認証情報の交換が正常に完了しました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5</term>
      <listitem>
       <para>
<!--
        The frontend must now take part in a Kerberos V5
        authentication dialog (not described here, part of the
        Kerberos specification) with the server.  If this is
        successful, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse. This is no
        longer supported.
-->
フロントエンドはここでサーバとのKerberos V5認証ダイアログ（ここでは説明しません。Kerberos仕様の一部）に参加する必要があります。
これが成功すれば、サーバはAuthenticationOk応答を行います。
失敗すれば、ErrorResponse応答を行います。
これはもはやサポートされていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword</term>
      <listitem>
       <para>
<!--
        The frontend must now send a PasswordMessage containing the
        password in clear-text form.  If
        this is the correct password, the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
-->
フロントエンドはここで平文形式のパスワードを含むPasswordMessageを送信する必要があります。
これが正しいパスワードであればサーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password</term>
      <listitem>
       <para>
<!--
        The frontend must now send a PasswordMessage containing the
        password (with username) encrypted via MD5, then encrypted
        again using the 4-byte random salt specified in the
        AuthenticationMD5Password message.  If this is the correct
        password, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse.  The actual
        PasswordMessage can be computed in SQL as <literal>concat('md5',
        md5(concat(md5(concat(password, username)), random-salt)))</>.
        (Keep in mind the <function>md5()</> function returns its
        result as a hex string.)
-->
フロントエンドはここでMD5で暗号化したパスワード（とユーザ名）を再度AuthenticationMD5Passwordメッセージで指定されたランダムな４バイトのソルトを使用して暗号化したものを含むPasswordMessageを送信する必要があります。
これが正しいパスワードであればサーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
実際のPasswordMessageを<literal>concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</>というSQLで計算することができます。
（<function>md5()</>関数がその結果を１６進数表記で返すことに注意してください。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSCMCredential</term>
      <listitem>
       <para>
<!--
        This response is only possible for local Unix-domain connections
        on platforms that support SCM credential messages.  The frontend
        must issue an SCM credential message and then send a single data
        byte.  (The contents of the data byte are uninteresting; it's
        only used to ensure that the server waits long enough to receive
        the credential message.)  If the credential is acceptable,
        the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
        (This message type is only issued by pre-9.1 servers.  It may
        eventually be removed from the protocol specification.)
-->
この応答はSCM資格証明メッセージをサポートするプラットフォーム上のローカルなUnixドメイン接続でのみあり得ます。
フロントエンドはSCM資格証明メッセージを発行し、その後単一のデータバイトを送信する必要があります。
（データバイトの内容には意味はありません。
これはサーバが資格証明メッセージの受信にどれだけ待機すればよいのかを確実にするためだけに使用されます。）
資格証明が受け付け可能であれば、サーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
（この種類のメッセージは9.1より前のサーバでのみ発行されます。
最終的にはプロトコル仕様から削除されるかもしれません。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
<!--
        The frontend must now initiate a GSSAPI negotiation. The frontend
        will send a PasswordMessage with the first part of the GSSAPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
-->
ここでフロントエンドはGSSAPIの調停を開始しなければなりません。
これに対する応答におけるGSSAPIデータストリームの最初の部分で、フロントエンドはPasswordMessageを送信します。
さらにメッセージが必要となる場合、サーバはAuthenticationGSSContinueで応答します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
<!--
        The frontend must now initiate a SSPI negotiation. The frontend
        will send a PasswordMessage with the first part of the SSPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
-->
ここでフロントエンドはSSPI調停を開始しなければなりません。
これに対する応答におけるSSPIデータストリームの最初の部分で、フロントエンドはPasswordMessageを送信します。
さらにメッセージが必要となる場合、サーバはAuthenticationGSSContinueで応答します。
       </para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
<!--
        This message contains the response data from the previous step
        of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI
        or a previous AuthenticationGSSContinue). If the GSSAPI
        or SSPI data in this message
        indicates more data is needed to complete the authentication,
        the frontend must send that data as another PasswordMessage. If
        GSSAPI or SSPI authentication is completed by this message, the server
        will next send AuthenticationOk to indicate successful authentication
        or ErrorResponse to indicate failure.
-->
このメッセージには、GSSAPIまたはSSPI調停の直前の段階（AuthenticationGSS、AuthenticationSSPIまたは前回のAuthenticationGSSContinue）についての応答データが含まれます。
このメッセージ内のGSSAPIまたはSSPIデータが認証を完結させるため、更なる追加データが必要であることを指示している場合、フロントエンドは他のPasswordMessageとしてデータを送信しなければなりません。
このメッセージでGSSAPIまたはSSPI認証が完了すれば、次にサーバはAuthenticationOkを送信して認証が成功したことを示すか、あるいはErrorResponseを送信して失敗したことを示します。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    If the frontend does not support the authentication method
    requested by the server, then it should immediately close the
    connection.
-->
サーバが要求した認証方式をフロントエンドがサポートしていない場合、フロントエンドは即座に接続を閉ざします。
   </para>

   <para>
<!--
    After having received AuthenticationOk, the frontend must wait
    for further messages from the server.  In this phase a backend process
    is being started, and the frontend is just an interested bystander.
    It is still possible for the startup attempt
    to fail (ErrorResponse), but in the normal case the backend will send
    some ParameterStatus messages, BackendKeyData, and finally ReadyForQuery.
-->
AuthenticationOkを受け取った後、フロントエンドはさらにサーバからのメッセージを待機する必要があります。
この段階で、バックエンドプロセスが起動し、このフロントエンドは単なる関心を有する第三者となります。
開始試行が失敗（ErrorResponse）する可能性がまだありますが、通常、バックエンドは何らかのParameterStatusメッセージ、BackendKeyData、そして最後にReadyForQueryを送信します。
   </para>

   <para>
<!--
    During this phase the backend will attempt to apply any additional
    run-time parameter settings that were given in the startup message.
    If successful, these values become session defaults.  An error causes
    ErrorResponse and exit.
-->
この段階の期間中、バックエンドは開始メッセージで与えられた任意の実行時パラメータの追加設定を適用しようとします。
成功した場合は、これらの値はセッションのデフォルトになります。
エラーが発生した場合はErrorResponseを行い、終了します。
   </para>

   <para>
<!--
    The possible messages from the backend in this phase are:
-->
この段階でバックエンドから送信される可能性があるメッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>BackendKeyData</term>
      <listitem>
       <para>
<!--
        This message provides secret-key data that the frontend must
        save if it wants to be able to issue cancel requests later.
        The frontend should not respond to this message, but should
        continue listening for a ReadyForQuery message.
-->
このメッセージは、フロントエンドがキャンセル要求を後で送信できるようにしたい場合に保存しなければならない、秘密キーデータを用意します。
フロントエンドはこのメッセージに応答してはいけませんが、ReadyForQueryメッセージの監視を続けなくてはなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus</term>
      <listitem>
       <para>
<!--
        This message informs the frontend about the current (initial)
         setting of backend parameters, such as <xref
         linkend="guc-client-encoding"> or <xref linkend="guc-datestyle">.
         The frontend can ignore this message, or record the settings
         for its future use; see <xref linkend="protocol-async"> for
         more details.  The frontend should not respond to this
         message, but should continue listening for a ReadyForQuery
         message.
-->
このメッセージは、フロントエンドに現在（初期）の<xref linkend="guc-client-encoding">や<xref linkend="guc-datestyle">などのバックエンドパラメータの設定情報を通知します。
フロントエンドはこのメッセージを無視しても、将来の使用に備えてその設定を記録しても構いません。
詳細は<xref linkend="protocol-async">を参照してください。
フロントエンドはこのメッセージに応答してはいけませんが、ReadyForQueryメッセージの監視を続けなくてはなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
<!--
        Start-up is completed.  The frontend can now issue commands.
-->
開始処理が完了しました。
フロントエンドはここでコマンドを発行することができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        Start-up failed.  The connection is closed after sending this
        message.
-->
開始処理が失敗しました。
接続はこのメッセージの送信後に閉ざされます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
<!--
        A warning message has been issued.  The frontend should
        display the message but continue listening for ReadyForQuery
        or ErrorResponse.
-->
警告メッセージが発行されました。
フロントエンドはこのメッセージを表示し、ReadyForQueryもしくはErrorResponseメッセージの監視を続けなければなりません。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    The ReadyForQuery message is the same one that the backend will
    issue after each command cycle.  Depending on the coding needs of
    the frontend, it is reasonable to consider ReadyForQuery as
    starting a command cycle, or to consider ReadyForQuery as ending the
    start-up phase and each subsequent command cycle.
-->
ReadyForQueryメッセージは各コマンドサイクルの後にバックエンドが発行するものと同じものです。
フロントエンドのコーディングにおいて必要であれば、ReadyForQueryをコマンドサイクルの開始とみなしても構いませんし、ReadyForQueryを開始段階とその後の各コマンドサイクルの終端とみなしても構いません。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Simple Query</title>
-->
<title>簡易問い合わせ</title>

   <para>
<!--
    A simple query cycle is initiated by the frontend sending a Query message
    to the backend.  The message includes an SQL command (or commands)
    expressed as a text string.
    The backend then sends one or more response
    messages depending on the contents of the query command string,
    and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new command.
    (It is not actually necessary for the frontend to wait for
    ReadyForQuery before issuing another command, but the frontend must
    then take responsibility for figuring out what happens if the earlier
    command fails and already-issued later commands succeed.)
-->
フロントエンドがQueryメッセージをバックエンドに送信することで、簡易問い合わせサイクルが開始されます。
このメッセージには、テキスト文字列で表現されたSQLコマンド（またはコマンド）が含まれます。
そうすると、バックエンドは、問い合わせコマンド文字列の内容に応じて1つ以上の応答を送信し、最終的にReadyForQueryを応答します。
ReadyForQueryは、新しいコマンドを安全に送信できることをフロントエンドに知らせます。
（実際には、フロントエンドが他のコマンドを発行する前にReadyForQueryを待機することは不要です。
しかし、フロントエンドは、前のコマンドが失敗し、発行済みの後のコマンドが成功した場合に何が起きるかを了解する責任を持たなければなりません。）
   </para>

   <para>
<!--
    The possible response messages from the backend are:
-->
バックエンドから送信される可能性がある応答メッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>CommandComplete</term>
      <listitem>
       <para>
<!--
        An SQL command completed normally.
-->
SQLコマンドが正常に終了しました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse</term>
      <listitem>
       <para>
<!--
        The backend is ready to copy data from the frontend to a
        table; see <xref linkend="protocol-copy">.
-->
バックエンドがフロントエンドからのデータをテーブルにコピーする準備ができました。
<xref linkend="protocol-copy">を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse</term>
      <listitem>
       <para>
<!--
        The backend is ready to copy data from a table to the
        frontend; see <xref linkend="protocol-copy">.
-->
バックエンドがデータをテーブルからフロントエンドにコピーする準備ができました。
<xref linkend="protocol-copy">を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription</term>
      <listitem>
       <para>
<!--
        Indicates that rows are about to be returned in response to
        a <command>SELECT</command>, <command>FETCH</command>, etc query.
        The contents of this message describe the column layout of the rows.
        This will be followed by a DataRow message for each row being returned
        to the frontend.
-->
<command>SELECT</command>や<command>FETCH</command>などの問い合わせの応答の行がまさに返されようとしていることを示します。
このメッセージには、行の列レイアウトに関する説明が含まれます。
このメッセージの後に、フロントエンドに返される各行に対するDataRowメッセージが続きます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow</term>
      <listitem>
       <para>
<!--
        One of the set of rows returned by
        a <command>SELECT</command>, <command>FETCH</command>, etc query.
-->
<command>SELECT</command>や<command>FETCH</command>などの問い合わせで返される行の集合の1つです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse</term>
      <listitem>
       <para>
<!--
        An empty query string was recognized.
-->
空の問い合わせ文字列が検知されました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        An error has occurred.
-->
エラーが起こりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
<!--
        Processing of the query string is complete.  A separate
        message is sent to indicate this because the query string might
        contain multiple SQL commands.  (CommandComplete marks the
        end of processing one SQL command, not the whole string.)
        ReadyForQuery will always be sent, whether processing
        terminates successfully or with an error.
-->
問い合わせ文字列の処理が終了しました。
問い合わせ文字列は複数のSQLコマンドが含まれる場合があるため、このことを通知するために分離したメッセージが送出されます。
（CommandCompleteは文字列全体ではなく、1つのSQLコマンドの処理の終了を明らかにします。）
処理が成功またはエラーで終了したかどうかにかかわらずReadyForQueryは常に送出されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
<!--
        A warning message has been issued in relation to the query.
        Notices are in addition to other responses, i.e., the backend
        will continue processing the command.
-->
問い合わせに関して警告メッセージが発行されました。
警告メッセージは他の応答に対する追加のメッセージです。 
したがって、バックエンドはそのコマンドの処理を続行します。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    The response to a <command>SELECT</> query (or other queries that
    return row sets, such as <command>EXPLAIN</> or <command>SHOW</>)
    normally consists of RowDescription, zero or more
    DataRow messages, and then CommandComplete.
    <command>COPY</> to or from the frontend invokes special protocol
    as described in <xref linkend="protocol-copy">.
    All other query types normally produce only
    a CommandComplete message.
-->
<command>SELECT</>問い合わせ（あるいは、<command>EXPLAIN</>や<command>SHOW</>などの行集合を返す他の問い合わせ）に対する応答は、通常、RowDescription、0個以上のDataRowメッセージ、そしてその後のCommandCompleteから構成されます。
フロントエンドへの<command>COPY</>もしくはフロントエンドからの<command>COPY</>は<xref linkend="protocol-copy">で説明する特別なプロトコルを呼び出します。
他の種類の問い合わせは通常CommandCompleteメッセージのみを生成します。
   </para>

   <para>
<!--
    Since a query string could contain several queries (separated by
    semicolons), there might be several such response sequences before the
    backend finishes processing the query string.  ReadyForQuery is issued
    when the entire string has been processed and the backend is ready to
    accept a new query string.
-->
問い合わせ文字列には（セミコロンで区切られた）複数の問い合わせが含まれることがありますので、バックエンドが問い合わせ文字列の処理を完了する前に、こうした応答シーケンスが複数発生する可能性があります。
ReadyForQueryは、文字列全体が処理され、バックエンドが新しい問い合わせ文字列を受け付ける準備が整った時点で発行されます。
   </para>

   <para>
<!--
    If a completely empty (no contents other than whitespace) query string
    is received, the response is EmptyQueryResponse followed by ReadyForQuery.
-->
完全に空の（空白文字以外の文字がない）問い合わせ文字列を受け取った場合、その応答は、EmptyQueryResponse、続いて、ReadyForQueryとなります。
   </para>

   <para>
<!--
    In the event of an error, ErrorResponse is issued followed by
    ReadyForQuery.  All further processing of the query string is aborted by
    ErrorResponse (even if more queries remained in it).  Note that this
    might occur partway through the sequence of messages generated by an
    individual query.
-->
エラーが発生した場合、ErrorResponse、続いて、ReadyForQueryが発行されます。
その問い合わせ文字列に対する以降の処理は（複数の問い合わせが残っていたとしても）すべて、ErrorResponseによって中断されます。
これは、個々の問い合わせで生成されるメッセージの並びの途中で発生する可能性があることに注意してください。
   </para>

   <para>
<!--
    In simple Query mode, the format of retrieved values is always text,
    except when the given command is a <command>FETCH</> from a cursor
    declared with the <literal>BINARY</> option.  In that case, the
    retrieved values are in binary format.  The format codes given in
    the RowDescription message tell which format is being used.
-->
簡易問い合わせモードでは、読み出される値の書式は常にテキストです。
ただし、与えられたコマンドが<literal>BINARY</>オプション付きで宣言されたカーソルからの<command>FETCH</>であった場合は例外です。
この場合は、読み出される値はバイナリ書式になります。
RowDescriptionメッセージ内で与えられる書式コードは、どの書式が使用されているかを通知します。
   </para>

   <para>
<!--
    A frontend must be prepared to accept ErrorResponse and
    NoticeResponse messages whenever it is expecting any other type of
    message.  See also <xref linkend="protocol-async"> concerning messages
    that the backend might generate due to outside events.
-->
他の種類のメッセージの受信を待機している時、フロントエンドは常にErrorResponseとNoticeResponseメッセージを受け取る準備ができていなければなりません。
また、外部イベントのためにバックエンドが生成する可能性があるメッセージの扱いについては<xref linkend="protocol-async">を参照してください。
   </para>

   <para>
<!--
    Recommended practice is to code frontends in a state-machine style
    that will accept any message type at any time that it could make sense,
    rather than wiring in assumptions about the exact sequence of messages.
-->
メッセージの正しい並びを前提としてコーディングするのではなく、任意のメッセージ種類を、そのメッセージが意味を持つ任意の時点で受け付ける状態マシン形式でフロントエンドのコーディングを行うことを推奨します。
   </para>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
<!--
   <title>Extended Query</title>
-->
<title>拡張問い合わせ</title>

   <para>
<!--
    The extended query protocol breaks down the above-described simple
    query protocol into multiple steps.  The results of preparatory
    steps can be re-used multiple times for improved efficiency.
    Furthermore, additional features are available, such as the possibility
    of supplying data values as separate parameters instead of having to
    insert them directly into a query string.
-->
拡張問い合わせプロトコルは、上述の簡易問い合わせプロトコルを複数段階に分解します。
予備段階の結果は複数回再利用できますので、効率が上がります。
さらに、問い合わせ文字列に直接埋め込むのではなく、データ値をパラメータとして分離して提供できる機能など、利用できる追加機能があります。
   </para>

   <para>
<!--
    In the extended protocol, the frontend first sends a Parse message,
    which contains a textual query string, optionally some information
    about data types of parameter placeholders, and the
    name of a destination prepared-statement object (an empty string
    selects the unnamed prepared statement).  The response is
    either ParseComplete or ErrorResponse.  Parameter data types can be
    specified by OID; if not given, the parser attempts to infer the
    data types in the same way as it would do for untyped literal string
    constants.
-->
拡張プロトコルでは、フロントエンドはまず、テキストの問い合わせ文字列とオプションとしてパラメータプレースホルダのデータ型情報やプリペアド文のオブジェクトの宛先名（空文字列は無名のプリペアド文を選択）を含む、Parseメッセージを送信します。
この応答はParseCompleteまたはErrorResponseです。
パラメータデータ型はそのOIDで指定することができます。
指定がなければ、パーサは型指定のないリテラル文字列定数に対する方法と同じ方法でデータ型を推定します。
   </para>

   <note>
    <para>
<!--
     A parameter data type can be left unspecified by setting it to zero,
     or by making the array of parameter type OIDs shorter than the
     number of parameter symbols (<literal>$</><replaceable>n</>)
     used in the query string.  Another special case is that a parameter's
     type can be specified as <type>void</> (that is, the OID of the
     <type>void</> pseudotype).  This is meant to allow parameter symbols
     to be used for function parameters that are actually OUT parameters.
     Ordinarily there is no context in which a <type>void</> parameter
     could be used, but if such a parameter symbol appears in a function's
     parameter list, it is effectively ignored.  For example, a function
     call such as <literal>foo($1,$2,$3,$4)</> could match a function with
     two IN and two OUT arguments, if <literal>$3</> and <literal>$4</>
     are specified as having type <type>void</>.
-->
パラメータデータ型をゼロと設定する、または、問い合わせ文字列内で使用されているパラメータ記号（<literal>$</><replaceable>n</>）の数より短くパラメータ型のOIDの配列を作成することで、指定しないまま残すことができます。
他にも、パラメータの型を<type>void</>（つまり<type>void</>仮想型のOID）と指定するという特別な場合があります。
これは、パラメータ記号を、実際のOUTパラメータである関数パラメータとして使用することができることを意味します。
通常では、<type>void</>パラメータが使用される文脈はありませんが、関数パラメータリストにこうしたパラメータ記号があると、実質的には無視されます。
例えば、<literal>$3</>と<literal>$4</>が<type>void</>型を持つと指定された場合、<literal>foo($1,$2,$3,$4)</>といった関数呼び出しは、2つのINと2つのOUT引数を持つ関数に一致します。
    </para>
   </note>

   <note>
    <para>
<!--
     The query string contained in a Parse message cannot include more
     than one SQL statement; else a syntax error is reported.  This
     restriction does not exist in the simple-query protocol, but it
     does exist in the extended protocol, because allowing prepared
     statements or portals to contain multiple commands would complicate
     the protocol unduly.
-->
Parseメッセージ内の問い合わせ文字列には、複数のSQL文を含めることはできません。
さもないと、構文エラーが報告されます。
この制限は簡易問い合わせプロトコルにはありませんが、複数のコマンドを持つプリペアド文やポータルを許すと、プロトコルが複雑になり過ぎるため、拡張プロトコルではこの制限があります。
    </para>
   </note>

   <para>
<!--
    If successfully created, a named prepared-statement object lasts till
    the end of the current session, unless explicitly destroyed.  An unnamed
    prepared statement lasts only until the next Parse statement specifying
    the unnamed statement as destination is issued.  (Note that a simple
    Query message also destroys the unnamed statement.)  Named prepared
    statements must be explicitly closed before they can be redefined by
    another Parse message, but this is not required for the unnamed statement.
    Named prepared statements can also be created and accessed at the SQL
    command level, using <command>PREPARE</> and <command>EXECUTE</>.
-->
作成に成功すると、名前付きプリペアド文オブジェクトは明示的に破棄されない限り現在のセッションが終わるまで残ります。
無名のプリペアド文オブジェクトは、次に無名のプリペアド文を宛先に指定したParse文が発行されるまでの間のみに残ります。
（単なるQueryメッセージでも無名のプリペアド文オブジェクトは破壊されることに注意してください。）
名前付きプリペアド文は、他のParseメッセージで再定義する前に明示的に閉じなければなりません。
しかし、これは無名のプリペアド文では必要ありません。
名前付きプリペアド文はまた、SQLコマンドレベルで<command>PREPARE</>と<command>EXECUTE</>を使用して作成しアクセスすることができます。
   </para>

   <para>
<!--
    Once a prepared statement exists, it can be readied for execution using a
    Bind message.  The Bind message gives the name of the source prepared
    statement (empty string denotes the unnamed prepared statement), the name
    of the destination portal (empty string denotes the unnamed portal), and
    the values to use for any parameter placeholders present in the prepared
    statement.  The
    supplied parameter set must match those needed by the prepared statement.
    (If you declared any <type>void</> parameters in the Parse message,
    pass NULL values for them in the Bind message.)
    Bind also specifies the format to use for any data returned
    by the query; the format can be specified overall, or per-column.
    The response is either BindComplete or ErrorResponse.
-->
プリペアド文が存在すると、Bindメッセージを使用してそれを実行可能状態にすることができます。
Bindメッセージは、元となるプリペアド文（空文字列は無名のプリペアド文を表します）の名前、宛先となるポータル（空文字列は無名ポータルを表します）の名前、およびプリペアド文内のパラメータプレースホルダに使用する値を与えます。
与えられたパラメータ集合はプリペアド文で必要とするものと一致しなければなりません。
（Parseメッセージ内で<type>void</>パラメータを1つでも宣言した場合、BindメッセージではそれらにはNULLを渡します。）
また、Bindは問い合わせで返されるデータに使用する書式を指定します。
書式は全体に対して指定することも、列単位で指定することも可能です。
応答はBindCompleteもしくはErrorResponseです。
   </para>

   <note>
    <para>
<!--
     The choice between text and binary output is determined by the format
     codes given in Bind, regardless of the SQL command involved.  The
     <literal>BINARY</> attribute in cursor declarations is irrelevant when
     using extended query protocol.
-->
テキスト出力とバイナリ出力との選択は、含まれるSQLコマンドに関係なく、Bindで与えられた書式コードで決定されます。
拡張問い合わせプロトコルを使用する場合、カーソル宣言の<literal>BINARY</>属性は役に立ちません。
    </para>
   </note>

   <para>
<!--
    Query planning typically occurs when the Bind message is processed.
    If the prepared statement has no parameters, or is executed repeatedly,
    the server might save the created plan and re-use it during subsequent
    Bind messages for the same prepared statement.  However, it will do so
    only if it finds that a generic plan can be created that is not much
    less efficient than a plan that depends on the specific parameter values
    supplied.  This happens transparently so far as the protocol is concerned.
-->
典型的に問い合わせ計画はBindメッセージが処理される時に作成されます。
プリペアド文がパラメータを持たない場合、または繰り返し実行される場合、サーバは作成した計画を保管し、その後の同じプリペアド文に対するBindメッセージの際に再利用する可能性があります。
しかし、作成できる汎用化した計画が提供された特定のパラメータ値に依存する計画より効率が大して劣化しないことが分かった場合のみ、このように動作します。
プロトコルに注目している限り、これは透過的に行われます。
   </para>

   <para>
<!--
    If successfully created, a named portal object lasts till the end of the
    current transaction, unless explicitly destroyed.  An unnamed portal is
    destroyed at the end of the transaction, or as soon as the next Bind
    statement specifying the unnamed portal as destination is issued.  (Note
    that a simple Query message also destroys the unnamed portal.)  Named
    portals must be explicitly closed before they can be redefined by another
    Bind message, but this is not required for the unnamed portal.
    Named portals can also be created and accessed at the SQL
    command level, using <command>DECLARE CURSOR</> and <command>FETCH</>.
-->
作成に成功すると、名前付きポータルオブジェクトは明示的に破棄されない限り現在のセッションが終わるまで残ります。
無名ポータルは、トランザクションの終わり、もしくは、次に無名ポータルを宛先に指定したParse文が発行されるまでの間のみに残ります。
（単なるQueryメッセージでも無名ポータルは破壊されることに注意してください。）
名前付きポータルは、他のBindメッセージで再定義する前に明示的に閉じなければなりません。
しかし、これは無名ポータルでは必要ありません。
名前付きポータルはまた、SQLコマンドレベルで<command>DECLARE CURSOR</>と<command>FETCH</>を使用して作成しアクセスすることができます。
   </para>

   <para>
<!--
    Once a portal exists, it can be executed using an Execute message.
    The Execute message specifies the portal name (empty string denotes the
    unnamed portal) and
    a maximum result-row count (zero meaning <quote>fetch all rows</>).
    The result-row count is only meaningful for portals
    containing commands that return row sets; in other cases the command is
    always executed to completion, and the row count is ignored.
    The possible
    responses to Execute are the same as those described above for queries
    issued via simple query protocol, except that Execute doesn't cause
    ReadyForQuery or RowDescription to be issued.
-->
ポータルが存在すると、Executeメッセージを使用してそれを実行することができます。
Executeメッセージは、ポータル名（空文字列は無名ポータルを表します）と結果行数の最大値（ゼロは<quote>fetch all rows</>を意味します）を指定します。
結果行数は、ポータルが行集合を返すコマンドを含む場合のみ意味があります。
その他の場合では、コマンドは常に終わりまで実行され、行数は無視されます。
Executeで起こり得る応答は、ExecuteではReadyForQueryやRowDescriptionが発行されない点を除き、上述の簡易問い合わせプロトコル経由で発行された問い合わせの場合と同じです。
   </para>

   <para>
<!--
    If Execute terminates before completing the execution of a portal
    (due to reaching a nonzero result-row count), it will send a
    PortalSuspended message; the appearance of this message tells the frontend
    that another Execute should be issued against the same portal to
    complete the operation.  The CommandComplete message indicating
    completion of the source SQL command is not sent until
    the portal's execution is completed.  Therefore, an Execute phase is
    always terminated by the appearance of exactly one of these messages:
    CommandComplete, EmptyQueryResponse (if the portal was created from
    an empty query string), ErrorResponse, or PortalSuspended.
-->
Executeがポータルの実行を完了する前に（非ゼロの結果行数に達したために）終了した場合、PortalSuspendedを送信します。
このメッセージの出現は、フロントエンドに操作を完了させるためには同一のポータルに対して、別のExecuteを発行しなければならないことを通知します。
元となったSQLコマンドが完了したことを示すCommandCompleteメッセージはポータルが完了するまで送信されません。
したがって、Execute段階は常にCommandComplete、EmptyQueryResponse（空の問い合わせ文字列からポータルが作成された場合）、ErrorResponse、またはPortalSuspendedの中の、正確にどれかが出現することによって常に終了します。
   </para>

   <para>
<!--
    At completion of each series of extended-query messages, the frontend
    should issue a Sync message.  This parameterless message causes the
    backend to close the current transaction if it's not inside a
    <command>BEGIN</>/<command>COMMIT</> transaction block (<quote>close</>
    meaning to commit if no error, or roll back if error).  Then a
    ReadyForQuery response is issued.  The purpose of Sync is to provide
    a resynchronization point for error recovery.  When an error is detected
    while processing any extended-query message, the backend issues
    ErrorResponse, then reads and discards messages until a Sync is reached,
    then issues ReadyForQuery and returns to normal message processing.
    (But note that no skipping occurs if an error is detected
    <emphasis>while</> processing Sync &mdash; this ensures that there is one
    and only one ReadyForQuery sent for each Sync.)
-->
拡張問い合わせメッセージの一連の流れのそれぞれの終了時、フロントエンドはSyncメッセージを発行しなければなりません。
このパラメータのないメッセージにより、もし<command>BEGIN</>/<command>COMMIT</>トランザクションブロックの内部でなければ、バックエンドは現在のトランザクションを閉ざします
（<quote>閉ざす</>とは、エラーがなければコミット、エラーがあればロールバックすることを意味します）。
そして、ReadyForQuery応答が発行されます。
Syncの目的は、エラーからの復旧用の再同期を行う時点を提供することです。
拡張問い合わせメッセージの処理中にエラーが検出されると、バックエンドはErrorResponseを発行し、Syncが届くまでメッセージを読み、それを破棄します。
その後、ReadyForQueryを発行し、通常のメッセージ処理に戻ります。
（しかし、Sync処理<emphasis>中に</>エラーが検出された場合に処理が飛ばされないことに注意してください。
これにより、各Syncに対してReadyForQueryが1つのみであることを保証します。）
   </para>

   <note>
    <para>
<!--
     Sync does not cause a transaction block opened with <command>BEGIN</>
     to be closed.  It is possible to detect this situation since the
     ReadyForQuery message includes transaction status information.
-->
Syncによって、<command>BEGIN</>で開かれたトランザクションブロックが閉ざされることはありません。
ReadyForQueryメッセージにはトランザクションの状態情報が含まれていますので、この状況を検出することができます。
    </para>
   </note>

   <para>
<!--
    In addition to these fundamental, required operations, there are several
    optional operations that can be used with extended-query protocol.
-->
これらの基本的な必要操作に加え、拡張問い合わせプロトコルで使用することができる、複数の省略可能な操作があります。
   </para>

   <para>
<!--
    The Describe message (portal variant) specifies the name of an existing
    portal (or an empty string for the unnamed portal).  The response is a
    RowDescription message describing the rows that will be returned by
    executing the portal; or a NoData message if the portal does not contain a
    query that will return rows; or ErrorResponse if there is no such portal.
-->
Describeメッセージ（ポータルの亜種）は、既存のポータルの名前（もしくは、無名ポータル用の空文字）を指定します。
応答は、実行中のポータルで返される予定の行を記述するRowDescriptionメッセージです。
ポータルが行を返す問い合わせを含まない場合はNoDataメッセージです。
指定したポータルが存在しない場合はErrorResponseです。
   </para>

   <para>
<!--
    The Describe message (statement variant) specifies the name of an existing
    prepared statement (or an empty string for the unnamed prepared
    statement).  The response is a ParameterDescription message describing the
    parameters needed by the statement, followed by a RowDescription message
    describing the rows that will be returned when the statement is eventually
    executed (or a NoData message if the statement will not return rows).
    ErrorResponse is issued if there is no such prepared statement.  Note that
    since Bind has not yet been issued, the formats to be used for returned
    columns are not yet known to the backend; the format code fields in the
    RowDescription message will be zeroes in this case.
-->
Describeメッセージ（ステートメントの亜種）は、既存のプリペアド文の名前（もしくは無名のプリペアド文用の空文字）を指定します。
応答は、文で必要とされるパラメータを記述するParameterDescriptionメッセージ、続いて、文が実行された場合に返される予定の行を記述するRowDescriptionメッセージ（もしくは文が行を返さない場合のNoDataメッセージ）です。
指定したプリペアド文が存在しない場合はErrorResponseが発行されます。
Bindがまだ発行されていませんので、返される列の書式はまだバックエンドでは不明であることに注意してください。
RowDescriptionメッセージ内の書式コードフィールドはこの場合はゼロになります。
   </para>

   <tip>
    <para>
<!--
     In most scenarios the frontend should issue one or the other variant
     of Describe before issuing Execute, to ensure that it knows how to
     interpret the results it will get back.
-->
ほとんどの状況では、フロントエンドはExecuteを発行する前に、返ってくる結果を解釈する方法を確実に判断できるように、Describeもしくはその亜種を実行すべきです。
    </para>
   </tip>

   <para>
<!--
    The Close message closes an existing prepared statement or portal
    and releases resources.  It is not an error to issue Close against
    a nonexistent statement or portal name.  The response is normally
    CloseComplete, but could be ErrorResponse if some difficulty is
    encountered while releasing resources.  Note that closing a prepared
    statement implicitly closes any open portals that were constructed
    from that statement.
-->
Closeメッセージは、既存のプリペアド文、もしくはポータルを閉ざし、リソースを解放します。
存在しない文やポータルに対してCloseを発行してもエラーになりません。
応答は通常CloseCompleteですが、リソースの解放に何らかの問題が発生した場合はErrorResponseになります。
プリペアド文を閉じると、そこから構築され、開いたポータルが暗黙的に閉ざされることに注意してください。
   </para>

   <para>
<!--
    The Flush message does not cause any specific output to be generated,
    but forces the backend to deliver any data pending in its output
    buffers.  A Flush must be sent after any extended-query command except
    Sync, if the frontend wishes to examine the results of that command before
    issuing more commands.  Without Flush, messages returned by the backend
    will be combined into the minimum possible number of packets to minimize
    network overhead.
-->
Flushメッセージにより特定の出力が生成されることはありません。
しかし、バックエンドに対して、出力バッファ内で待機しているデータを強制的に配送させます。
フロントエンドが他のコマンドを発行する前にコマンドの結果を検証したい場合に、FlushはSync以外の拡張問い合わせコマンドの後に送信される必要があります。
Flushを行わないと、バックエンドで返されるメッセージは、ネットワークオーバーヘッドを最小化する、最小限のパケット数にまとめられます。
   </para>

   <note>
    <para>
<!--
     The simple Query message is approximately equivalent to the series Parse,
     Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared
     statement and portal objects and no parameters.  One difference is that
     it will accept multiple SQL statements in the query string, automatically
     performing the bind/describe/execute sequence for each one in succession.
     Another difference is that it will not return ParseComplete, BindComplete,
     CloseComplete, or NoData messages.
-->
簡易問い合わせメッセージは、おおよそ、無名のプリペアド文とポータルオブジェクトを使用したパラメータなしのParse、Bind、ポータル用Describe、Execute、Close、Syncの流れと同一です。
違いは、問い合わせ文字列内に複数のSQL文を受け付けられ、bind/describe/executeという流れがそれぞれが成功すれば自動的に行われる点です。
他の違いとして、ParseCompleteやBindComplete、CloseComplete、NoDataメッセージが返されない点があります。
    </para>
   </note>
  </sect2>

  <sect2>
<!--
   <title>Function Call</title>
-->
<title>関数呼び出し</title>

   <para>
<!--
    The Function Call sub-protocol allows the client to request a direct
    call of any function that exists in the database's
    <structname>pg_proc</structname> system catalog.  The client must have
    execute permission for the function.
-->
関数呼び出しサブプロトコルにより、クライアントはデータベースの<structname>pg_proc</structname>システムカタログに存在する任意の関数を直接呼び出す要求を行うことができます。
クライアントはその関数を実行する権限を持たなければなりません。
   </para>

   <note>
    <para>
<!--
     The Function Call sub-protocol is a legacy feature that is probably best
     avoided in new code.  Similar results can be accomplished by setting up
     a prepared statement that does <literal>SELECT function($1, ...)</>.
     The Function Call cycle can then be replaced with Bind/Execute.
-->
関数呼び出しサブプロトコルは、おそらく新しく作成するコードでは使用すべきではない古い機能です。
同様の結果は、<literal>SELECT function($1, ...)</>を行うプリペアド文を設定することで得ることができます。
そして、この関数呼び出しサイクルをBind/Executeで置き換えることができます。
    </para>
   </note>

   <para>
<!--
    A Function Call cycle is initiated by the frontend sending a
    FunctionCall message to the backend.  The backend then sends one
    or more response messages depending on the results of the function
    call, and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new query or
    function call.
-->
関数呼び出しサイクルはフロントエンドがFunctionCallメッセージをバックエンドに送ることで起動されます。
バックエンドは1つまたは複数の応答メッセージを関数呼び出しの結果に基づいて送り、最終的にReadyForQueryメッセージを送出します。
ReadyForQueryはフロントエンドに対し新規の問い合わせまたは関数呼び出しを行っても安全確実であることを通知します。
   </para>

   <para>
<!--
    The possible response messages from the backend are:
-->
バックエンドから送信される可能性がある応答メッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        An error has occurred.
-->
エラーが起こりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse</term>
      <listitem>
       <para>
<!--
        The function call was completed and returned the result given
        in the message.
        (Note that the Function Call protocol can only handle a single
        scalar result, not a row type or set of results.)
-->
関数呼び出しが完了し、メッセージで与えられた結果が返されました。
（関数呼び出しプロトコルは単一のスカラ結果のみを扱うことができます。行型や結果集合を扱うことはできません。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
<!--
        Processing of the function call is complete.  ReadyForQuery
        will always be sent, whether processing terminates
        successfully or with an error.
-->
関数呼び出しの処理が終了しました。
処理が成功またはエラーで終了したかどうかにかかわらずReadyForQueryは常に送出されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
<!--
        A warning message has been issued in relation to the function
        call.  Notices are in addition to other responses, i.e., the
        backend will continue processing the command.
-->
関数呼び出しに関して警告メッセージが出されました。
警告メッセージは他の応答に対する追加のメッセージです。 
したがって、バックエンドはそのコマンドの処理を続行します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
<!--
   <title>COPY Operations</title>
-->
<title>COPY操作</title>

   <para>
<!--
    The <command>COPY</> command allows high-speed bulk data transfer
    to or from the server.  Copy-in and copy-out operations each switch
    the connection into a distinct sub-protocol, which lasts until the
    operation is completed.
-->
<command>COPY</>コマンドにより、サーバとの間で高速な大量データ転送を行うことができます。
コピーインとコピーアウト操作はそれぞれ接続を別のサブプロトコルに切り替えます。
これは操作が完了するまで残ります。
   </para>

   <para>
<!--
    Copy-in mode (data transfer to the server) is initiated when the
    backend executes a <command>COPY FROM STDIN</> SQL statement.  The backend
    sends a CopyInResponse message to the frontend.  The frontend should
    then send zero or more CopyData messages, forming a stream of input
    data.  (The message boundaries are not required to have anything to do
    with row boundaries, although that is often a reasonable choice.)
    The frontend can terminate the copy-in mode by sending either a CopyDone
    message (allowing successful termination) or a CopyFail message (which
    will cause the <command>COPY</> SQL statement to fail with an
    error).  The backend then reverts to the command-processing mode it was
    in before the <command>COPY</> started, which will be either simple or
    extended query protocol.  It will next send either CommandComplete
    (if successful) or ErrorResponse (if not).
-->
コピーインモード（サーバへのデータ転送）は、バックエンドが<command>COPY FROM STDIN</> SQL文を実行した時に起動されます。
バックエンドはフロントエンドにCopyInResponseメッセージを送信します。
フロントエンドはその後、ゼロ個以上のCopyDataメッセージを送信し、入力データのストリームを形成します。
（このメッセージの境界は行の境界に何かしら合わせる必要ありませんが、往々にしてそれが合理的な選択となります。）
フロントエンドは、CopyDoneメッセージ（正常に終了させる）、もしくは、CopyFailメッセージ（<command>COPY</> SQL文をエラーで失敗させる）を送信することで、コピーインモードを終了させることができます。
そして、バックエンドは、<command>COPY</>が始まる前の、簡易もしくは拡張問い合わせプロトコルを使用するコマンド処理モードに戻ります。
そして次に、CommandComplete（成功時）またはErrorResponse（失敗時）のどちらかを送信します。
   </para>

   <para>
<!--
    In the event of a backend-detected error during copy-in mode (including
    receipt of a CopyFail message), the backend will issue an ErrorResponse
    message.  If the <command>COPY</> command was issued via an extended-query
    message, the backend will now discard frontend messages until a Sync
    message is received, then it will issue ReadyForQuery and return to normal
    processing.  If the <command>COPY</> command was issued in a simple
    Query message, the rest of that message is discarded and ReadyForQuery
    is issued.  In either case, any subsequent CopyData, CopyDone, or CopyFail
    messages issued by the frontend will simply be dropped.
-->
コピーインモードの期間中にバックエンドがエラー（CopyFailメッセージの受信を含む）を検知すると、バックエンドはErrorResponseメッセージを発行します。
拡張問い合わせメッセージ経由で<command>COPY</>コマンドが発行された場合、バックエンドはSyncメッセージを受け取るまでフロントエンドのメッセージを破棄するようになります。
Syncメッセージを受け取ると、ReadyForQueryを発行し、通常処理に戻ります。
簡易問い合わせメッセージで<command>COPY</>が発行された場合、メッセージの残りは破棄され、ReadyForQueryメッセージを発行します。
どちらの場合でも、その後にフロントエンドによって発行されたCopyData、CopyDone、CopyFailは単に削除されます。
   </para>

   <para>
<!--
    The backend will ignore Flush and Sync messages received during copy-in
    mode.  Receipt of any other non-copy message type constitutes an error
    that will abort the copy-in state as described above.  (The exception for
    Flush and Sync is for the convenience of client libraries that always
    send Flush or Sync after an Execute message, without checking whether
    the command to be executed is a <command>COPY FROM STDIN</>.)
-->
バックエンドは、コピーインモード期間中、FlushとSyncメッセージを無視します。
その他の種類の非コピーメッセージを受け取ると、エラーになり、上述のようにコピーイン状態を中断します
（クライアントライブラリがExecuteメッセージの後に、実行したコマンドが<command>COPY FROM STDIN</>かどうかを検査することなく、常にFlushまたはSyncを送信できる、という便利さのためにFlushとSyncは例外です）。
   </para>

   <para>
<!--
    Copy-out mode (data transfer from the server) is initiated when the
    backend executes a <command>COPY TO STDOUT</> SQL statement.  The backend
    sends a CopyOutResponse message to the frontend, followed by
    zero or more CopyData messages (always one per row), followed by CopyDone.
    The backend then reverts to the command-processing mode it was
    in before the <command>COPY</> started, and sends CommandComplete.
    The frontend cannot abort the transfer (except by closing the connection
    or issuing a Cancel request),
    but it can discard unwanted CopyData and CopyDone messages.
-->
コピーアウトモード（サーバからのデータ転送）は、バックエンドが<command>COPY TO STDOUT</> SQL文を実行した時に起動します。
バックエンドはCopyOutResponseメッセージをフロントエンドに送信し、その後、ゼロ個以上のCopyDataメッセージ（常に行ごとに1つ）を、そして、CopyDoneを送信します。
その後、バックエンドは<command>COPY</>が始まる前のコマンド処理モードに戻り、CommandCompleteを送信します。
フロントエンドは（接続の切断やCancel要求の発行は例外ですが）転送を中断することはできません。
しかし、不要なCopyDataとCopyDoneメッセージを破棄することは可能です。
   </para>

   <para>
<!--
    In the event of a backend-detected error during copy-out mode,
    the backend will issue an ErrorResponse message and revert to normal
    processing.  The frontend should treat receipt of ErrorResponse as
    terminating the copy-out mode.
-->
コピーアウトモード期間中バックエンドはエラーを検知すると、ErrorResponseメッセージを発行し、通常処理に戻ります。
フロントエンドはErrorResponseの受信をコピーアウトモードの終了として扱うべきです。
   </para>

   <para>
<!--
    It is possible for NoticeResponse and ParameterStatus messages to be
    interspersed between CopyData messages; frontends must handle these cases,
    and should be prepared for other asynchronous message types as well (see
    <xref linkend="protocol-async">).  Otherwise, any message type other than
    CopyData or CopyDone may be treated as terminating copy-out mode.
-->
NoticeResponseおよびParameterStatusメッセージがCopyDataメッセージ間に散在することがあります。
フロントエンドはこのような場合も扱わなければなりません。
また、他の種類の非同期メッセージ（<xref linkend="protocol-async">を参照）も同様に準備すべきです。
さもなくば、CopyDataまたはCopyDone以外の種類のメッセージがコピーアウトモードの終了として扱われてしまう可能性があります。
   </para>

   <para>
<!--
    There is another Copy-related mode called copy-both, which allows
    high-speed bulk data transfer to <emphasis>and</> from the server.
    Copy-both mode is initiated when a backend in walsender mode
    executes a <command>START_REPLICATION</command> statement.  The
    backend sends a CopyBothResponse message to the frontend.  Both
    the backend and the frontend may then send CopyData messages
    until either end sends a CopyDone message. After the client
    sends a CopyDone message, the connection goes from copy-both mode to
    copy-out mode, and the client may not send any more CopyData messages.
    Similarly, when the server sends a CopyDone message, the connection
    goes into copy-in mode, and the server may not send any more CopyData
    messages. After both sides have sent a CopyDone message, the copy mode
    is terminated, and the backend reverts to the command-processing mode.
    In the event of a backend-detected error during copy-both mode,
    the backend will issue an ErrorResponse message, discard frontend messages
    until a Sync message is received, and then issue ReadyForQuery and return
    to normal processing.  The frontend should treat receipt of ErrorResponse
    as terminating the copy in both directions; no CopyDone should be sent
    in this case.  See <xref linkend="protocol-replication"> for more
    information on the subprotocol transmitted over copy-both mode.
-->
他にも、サーバへ、<emphasis>および</>サーバからの高速な一括データ転送を行うことができるコピーボースというコピーに関連したモードがあります。
コピーボースモードは、walsenderモードのバックエンドが<command>START_REPLICATION</command>文を実行した時に初期化されます。
バックエンドはCopyBothResponseメッセージをフロントエンドに送信します。
この後バックエンドとフロントエンドの両方が、接続が終了するまでの間にCopyDataメッセージを送信できるようになります。
同様に、サーバがCopyDoneメッセージを送信した場合、接続はコピーインモードとなり、サーバはそれ以上のCopyDataメッセージを送信できません。
両方の側がCopyDoneメッセージを送信した後、コピーモードは終了し、バックエンドはコマンド処理モードに戻ります。
コピーボースモード中にバックエンドが検出したエラーのイベントにおいては、バックエンドはErrorResponseメッセージを発行し、Syncメッセージの受信までフロントエンドのメッセージを破棄し、その後ReadyForQueryを発行して通常の処理に戻ります。
フロントエンドは両方向のコピーを終了するように、ErrorResponse受理の処理をするべきです。
この場合CopyDoneを送信するべきではありません。
コピーボースモードにおけるサブプロトコル転送の詳細は<xref linkend="protocol-replication">を参照してください。
   </para>

   <para>
<!--
    The CopyInResponse, CopyOutResponse and CopyBothResponse messages
    include fields that inform the frontend of the number of columns
    per row and the format codes being used for each column.  (As of
    the present implementation, all columns in a given <command>COPY</>
    operation will use the same format, but the message design does not
    assume this.)
-->
CopyInResponse、CopyOutResponse、CopyBothResponseメッセージには、フロントエンドに1行当たりの列数と各列で使用する書式コードを通知するためのフィールドが含まれています。
（現在の実装では、<command>COPY</>操作で与えられるすべての列は同一の書式を使用します。
しかし、メッセージ設計においては、これを前提としていません。）
   </para>

  </sect2>

  <sect2 id="protocol-async">
<!--
   <title>Asynchronous Operations</title>
-->
<title>非同期操作</title>

   <para>
<!--
    There are several cases in which the backend will send messages that
    are not specifically prompted by the frontend's command stream.
    Frontends must be prepared to deal with these messages at any time,
    even when not engaged in a query.
    At minimum, one should check for these cases before beginning to
    read a query response.
-->
バックエンドが、フロントエンドのコマンドストリームで特に依頼されていないメッセージを送信する場合が複数あります。
フロントエンドは、問い合わせ作業を行っていない時であっても常に、これらのメッセージを扱う準備をしなければなりません。
少なくとも、問い合わせの応答の読み込みを始める前にこれらを検査すべきです。
   </para>

   <para>
<!--
    It is possible for NoticeResponse messages to be generated due to
    outside activity; for example, if the database administrator commands
    a <quote>fast</> database shutdown, the backend will send a NoticeResponse
    indicating this fact before closing the connection.  Accordingly,
    frontends should always be prepared to accept and display NoticeResponse
    messages, even when the connection is nominally idle.
-->
外部の活動によって、NoticeResponseメッセージが生成されることがあり得ます。
例えば、データベース管理者が<quote>高速</>データベース停止コマンドを実行した場合、バックエンドは接続を閉ざす前にこれを通知するためにNoticeResponseを送信します。
したがって、たとえ接続が名目上待機状態であったとしても、フロントエンドは常にNoticeResponseメッセージを受け付け、表示する準備をすべきです。
   </para>

   <para>
<!--
    ParameterStatus messages will be generated whenever the active
    value changes for any of the parameters the backend believes the
    frontend should know about.  Most commonly this occurs in response
    to a <command>SET</> SQL command executed by the frontend, and
    this case is effectively synchronous &mdash; but it is also possible
    for parameter status changes to occur because the administrator
    changed a configuration file and then sent the
    <systemitem>SIGHUP</systemitem> signal to the server.  Also,
    if a <command>SET</command> command is rolled back, an appropriate
    ParameterStatus message will be generated to report the current
    effective value.
-->
ParameterStatusメッセージは、任意のパラメータの実際の値が変更され、それをバックエンドがフロントエンドに通知するべきであるとみなした場合は常に生成されます。
ほとんどの場合、これはフロントエンドによる<command>SET</> SQLコマンド実行に対する応答の中で起こります。
これは実質的には同期していますが、管理者が設定ファイルを変更し、<systemitem>SIGHUP</systemitem>シグナルをサーバに送った場合にも、パラメータ状態の変更が発生することがあります。
また、<command>SET</command>コマンドがロールバックされた場合、現在の有効値を報告するために適切なParameterStatusメッセージが生成されます。
   </para>

   <para>
<!--
    At present there is a hard-wired set of parameters for which
    ParameterStatus will be generated: they are
    <varname>server_version</>,
    <varname>server_encoding</>,
    <varname>client_encoding</>,
    <varname>application_name</>,
    <varname>is_superuser</>,
    <varname>session_authorization</>,
    <varname>DateStyle</>,
    <varname>IntervalStyle</>,
    <varname>TimeZone</>,
    <varname>integer_datetimes</>, and
    <varname>standard_conforming_strings</>.
    (<varname>server_encoding</>, <varname>TimeZone</>, and
    <varname>integer_datetimes</> were not reported by releases before 8.0;
    <varname>standard_conforming_strings</> was not reported by releases
    before 8.1;
    <varname>IntervalStyle</> was not reported by releases before 8.4;
    <varname>application_name</> was not reported by releases before 9.0.)
    Note that
    <varname>server_version</>,
    <varname>server_encoding</> and
    <varname>integer_datetimes</>
    are pseudo-parameters that cannot change after startup.
    This set might change in the future, or even become configurable.
    Accordingly, a frontend should simply ignore ParameterStatus for
    parameters that it does not understand or care about.
-->
現時点では、ParameterStatusを生成するパラメータ群は固定されています。
それらは<varname>server_version</>、<varname>server_encoding</>、<varname>client_encoding</>、<varname>application_name</>、<varname>is_superuser</>、<varname>session_authorization</>、<varname>DateStyle</>、<varname>IntervalStyle</>、<varname>TimeZone</>、<varname>integer_datetimes</>、および<varname>standard_conforming_strings</>です。
（8.0より前までのリリースでは、<varname>server_encoding</>、<varname>TimeZone</>および<varname>integer_datetimes</>は送信されませんでした。
8.1より前までのリリースでは、<varname>standard_conforming_strings</>は送信されませんでした。
8.4より前のリリースでは、<varname>IntervalStyle</>は送信されませんでした。
9.0より前のリリースでは、<varname>application_name</>は送信されませんでした。）
<varname>server_version</>、<varname>server_encoding</>および<varname>integer_datetimes</>は仮想的なパラメータであり、起動後に変更することができないことに注意してください。
これは今後変更される、あるいは設定変更可能になる可能性があります。
したがって、フロントエンドは未知または注目していないParameterStatusを単に無視すべきです。
   </para>

   <para>
<!--
    If a frontend issues a <command>LISTEN</command> command, then the
    backend will send a NotificationResponse message (not to be
    confused with NoticeResponse!)  whenever a
    <command>NOTIFY</command> command is executed for the same
    channel name.
-->
フロントエンドが<command>LISTEN</command>コマンドを発行した場合、同じチャネル名に対し<command>NOTIFY</command>コマンドが実行された時にバックエンドはNotificationResponseメッセージ（NoticeResponseと間違えないように！）を送出します。
   </para>

   <note>
    <para>
<!--
     At present, NotificationResponse can only be sent outside a
     transaction, and thus it will not occur in the middle of a
     command-response series, though it might occur just before ReadyForQuery.
     It is unwise to design frontend logic that assumes that, however.
     Good practice is to be able to accept NotificationResponse at any
     point in the protocol.
-->
現在、NotificationResponseをトランザクションの外部でのみ送信することができます。
このため、これはコマンド応答の流れの途中では起こりませんが、ReadyForQueryの直前に発生する可能性があります。
しかし、これを前提にフロントエンドのロジックを設計することは避けてください。
プロトコル内の任意の時点でNotificationResponseを受け付けられるようにすることを勧めます。
    </para>
   </note>
  </sect2>

  <sect2>
<!--
   <title>Canceling Requests in Progress</title>
-->
<title>処理中のリクエストの取り消し</title>

   <para>
<!--
    During the processing of a query, the frontend might request
    cancellation of the query.  The cancel request is not sent
    directly on the open connection to the backend for reasons of
    implementation efficiency: we don't want to have the backend
    constantly checking for new input from the frontend during query
    processing.  Cancel requests should be relatively infrequent, so
    we make them slightly cumbersome in order to avoid a penalty in
    the normal case.
-->
問い合わせの処理中に、フロントエンドが問い合わせを取り消す可能性があります。
取り消し要求は、効率を高めるために、接続を開いたバックエンドに対して直接送信されません。
その問い合わせを処理中のバックエンドが、フロントエンドからの新しい入力があるかどうかを定期的に確認することは好ましくありません。
取り消し要求はたいていの場合、頻繁には起こらないので、通常の状態においての負担を避けるため、多少扱いにくくなっています。
   </para>

   <para>
<!--
    To issue a cancel request, the frontend opens a new connection to
    the server and sends a CancelRequest message, rather than the
    StartupMessage message that would ordinarily be sent across a new
    connection.  The server will process this request and then close
    the connection.  For security reasons, no direct reply is made to
    the cancel request message.
-->
取り消し要求を出す場合、フロントエンドは通常の新規接続の時に送出されるStartupMessageメッセージではなくCancelRequestメッセージをサーバに送り、新規接続を開始します。
サーバはこの要求を処理し、接続を切断します。
セキュリティ上の理由から、取り消し要求メッセージに対し直接の回答はありません。
   </para>

   <para>
<!--
    A CancelRequest message will be ignored unless it contains the
    same key data (PID and secret key) passed to the frontend during
    connection start-up.  If the request matches the PID and secret
    key for a currently executing backend, the processing of the
    current query is aborted.  (In the existing implementation, this is
    done by sending a special signal to the backend process that is
    processing the query.)
-->
CancelRequestメッセージは、接続開始段階でフロントエンドに送られたものと同一の鍵データ（PIDと秘密鍵）を含んでいない場合は無視されます。
現在バックエンドが実行中の処理に対するPIDと秘密鍵が要求と一致した場合、その現在の問い合わせ処理は中断されます。
（現状では、これは、その問い合わせを処理しているバックエンドプロセスに対し特別なシグナルを送ることで実装されています。）
   </para>

   <para>
<!--
    The cancellation signal might or might not have any effect &mdash; for
    example, if it arrives after the backend has finished processing
    the query, then it will have no effect.  If the cancellation is
    effective, it results in the current command being terminated
    early with an error message.
-->
この取り消しシグナルは何の効果も生まないことがあります。
例えば、バックエンドが問い合わせの処理を完了した後に届いた場合、効果がありません。
もし取り消し処理が有効であれば、エラーメッセージとともに、現在のコマンドは終了されます。
   </para>

   <para>
<!--
    The upshot of all this is that for reasons of both security and
    efficiency, the frontend has no direct way to tell whether a
    cancel request has succeeded.  It must continue to wait for the
    backend to respond to the query.  Issuing a cancel simply improves
    the odds that the current query will finish soon, and improves the
    odds that it will fail with an error message instead of
    succeeding.
-->
セキュリティと効率上の理由による上述の実装の結果、フロントエンドは取り消し要求が成功したかどうかを直接判断することはできません。
フロントエンドはバックエンドからの問い合わせの回答を待ち続けなければいけません。
取り消しを要求することは単に現在の問い合わせを早めに終わらせ、成功ではなくエラーメッセージを出して不成功とする可能性を単に高める程度のものです。
   </para>

   <para>
<!--
    Since the cancel request is sent across a new connection to the
    server and not across the regular frontend/backend communication
    link, it is possible for the cancel request to be issued by any
    process, not just the frontend whose query is to be canceled.
    This might provide additional flexibility when building
    multiple-process applications.  It also introduces a security
    risk, in that unauthorized persons might try to cancel queries.
    The security risk is addressed by requiring a dynamically
    generated secret key to be supplied in cancel requests.
-->
取り消し要求は、通常のフロントエンドとバックエンドの通信接続を通してではなく新規のサーバとの接続に送られるため、取り消される問い合わせを実行したフロントエンドだけでなく、任意のプロセスによっても送信することができます。
このことはマルチプロセスアプリケーションを作るに当たって柔軟性を提供します。
同時に、権限のない者が問い合わせを取り消そうとするといったセキュリティ上のリスクも持ち込みます。
このセキュリティ上のリスクは、取り消し要求内に動的に生成される秘密キーを供給することを必須とすることで回避されます。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Termination</title>
-->
<title>終了</title>

   <para>
<!--
    The normal, graceful termination procedure is that the frontend
    sends a Terminate message and immediately closes the connection.
    On receipt of this message, the backend closes the connection and
    terminates.
-->
通常の洗練された終了手順はフロントエンドがTerminateメッセージを出し、すぐに接続を閉じることです。
このメッセージを受け取るとすぐにバックエンドは接続を閉じ終了します。
   </para>

   <para>
<!--
    In rare cases (such as an administrator-commanded database shutdown)
    the backend might disconnect without any frontend request to do so.
    In such cases the backend will attempt to send an error or notice message
    giving the reason for the disconnection before it closes the connection.
-->
まれに（管理者によるデータベース停止コマンドなど）、バックエンドはフロントエンドからの要求なしに切断することがあります。
こうした場合、バックエンドは、接続を閉ざす前に切断理由を通知するエラーまたは警報メッセージの送信を試みます。
   </para>

   <para>
<!--
    Other termination scenarios arise from various failure cases, such as core
    dump at one end or the other, loss of the communications link, loss of
    message-boundary synchronization, etc.  If either frontend or backend sees
    an unexpected closure of the connection, it should clean
    up and terminate.  The frontend has the option of launching a new backend
    by recontacting the server if it doesn't want to terminate itself.
    Closing the connection is also advisable if an unrecognizable message type
    is received, since this probably indicates loss of message-boundary sync.
-->
他にも、どちらかの側のコアダンプ、通信リンクの消失、メッセージ境界の同期の消失など各種失敗によって終了する状況があります。
フロントエンドかバックエンドいずれかが予期しない接続の中断を検知した場合、後始末を行い終了しなければいけません。
フロントエンドはもし自身が終了を望まない場合、サーバに再交信し新規のバックエンドを立ち上げる選択権を持っています。
解釈できないメッセージ種類を受け取った時、おそらくメッセージ境界の同期が消失したことを示しますので、接続を閉ざすことを勧めます。
   </para>

   <para>
<!--
    For either normal or abnormal termination, any open transaction is
    rolled back, not committed.  One should note however that if a
    frontend disconnects while a non-<command>SELECT</command> query
    is being processed, the backend will probably finish the query
    before noticing the disconnection.  If the query is outside any
    transaction block (<command>BEGIN</> ... <command>COMMIT</>
    sequence) then its results might be committed before the
    disconnection is recognized.
-->
通常の終了、異常な終了のどちらの場合でも、開いているトランザクションはすべてコミットされずにロールバックされます。
しかし、フロントエンドが<command>SELECT</command>以外の問い合わせを処理中に切断した場合、バックエンドはおそらく切断に気付く前にその問い合わせを完了させてしまうでしょう。
その問い合わせがトランザクションブロック（<command>BEGIN</> ... <command>COMMIT</>の並び）外部であった場合、切断に気付く前にその結果はコミットされる可能性があります。
   </para>
  </sect2>

  <sect2>
<!--
   <title><acronym>SSL</acronym> Session Encryption</title>
-->
<title><acronym>SSL</acronym>セッション暗号化</title>

   <para>
<!--
    If <productname>PostgreSQL</> was built with
    <acronym>SSL</acronym> support, frontend/backend communications
    can be encrypted using <acronym>SSL</acronym>.  This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting <productname>PostgreSQL</productname> sessions with
    <acronym>SSL</acronym>, see <xref linkend="ssl-tcp">.
-->
<productname>PostgreSQL</>が<acronym>SSL</acronym>サポート付きで構築された場合、フロントエンドとバックエンド間の通信を<acronym>SSL</acronym>で暗号化することができます。
攻撃者がセッショントラフィックをキャプチャできるような環境における通信を安全にすることができます。
<acronym>SSL</acronym>を使用した<productname>PostgreSQL</productname>セッションの暗号化に関する詳細は<xref linkend="ssl-tcp">を参照してください。
   </para>

   <para>
<!--
    To initiate an <acronym>SSL</acronym>-encrypted connection, the
    frontend initially sends an SSLRequest message rather than a
    StartupMessage.  The server then responds with a single byte
    containing <literal>S</> or <literal>N</>, indicating that it is
    willing or unwilling to perform <acronym>SSL</acronym>,
    respectively.  The frontend might close the connection at this point
    if it is dissatisfied with the response.  To continue after
    <literal>S</>, perform an <acronym>SSL</acronym> startup handshake
    (not described here, part of the <acronym>SSL</acronym>
    specification) with the server.  If this is successful, continue
    with sending the usual StartupMessage.  In this case the
    StartupMessage and all subsequent data will be
    <acronym>SSL</acronym>-encrypted.  To continue after
    <literal>N</>, send the usual StartupMessage and proceed without
    encryption.
-->
<acronym>SSL</acronym>暗号化接続を開始するには、フロントエンドはまず、StartupMessageではなくSSLRequestを送信します。
その後サーバはそれぞれ<acronym>SSL</acronym>の実行を行うか行わないかを示す<literal>S</>か<literal>N</>かを持つ1バイトの応答を返します。
フロントエンドはその応答に満足できなければ、この時点で接続を切断することができます。
<literal>S</>の後に継続するのであれば、サーバと間で<acronym>SSL</acronym>起動ハンドシェーク（ここでは<acronym>SSL</acronym>の仕様に関しては説明しません）を行います。
これが成功した場合、続いて通常のStartupMessageの送信を行います。
この場合、StartupMessageおよびその後のデータは<acronym>SSL</acronym>により暗号化されます。
<literal>N</>の後に、通常のStartupMessageを送信することで暗号化なしで進みます。
   </para>

   <para>
<!--
    The frontend should also be prepared to handle an ErrorMessage
    response to SSLRequest from the server.  This would only occur if
    the server predates the addition of <acronym>SSL</acronym> support
    to <productname>PostgreSQL</>.  (Such servers are now very ancient,
    and likely do not exist in the wild anymore.)
    In this case the connection must
    be closed, but the frontend might choose to open a fresh connection
    and proceed without requesting <acronym>SSL</acronym>.
-->
また、フロントエンドはサーバからのSSLRequestに対するErrorMessage応答を取り扱うための用意もすべきです。
これは、<productname>PostgreSQL</>に<acronym>SSL</acronym>サポートが追加される前のサーバの場合のみで発生します。
（現在ではこうしたサーバは非常に古いものといえ、ほとんど存在しません。）
この場合接続を切断しなければなりませんが、フロントエンドは<acronym>SSL</acronym>要求なしで新しく接続を開き、処理を進めることもできます。
   </para>

   <para>
<!--
    An initial SSLRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
-->
最初のSSLRequestはCancelRequestメッセージを送信するために開いた接続で使用することもできます。
   </para>

   <para>
<!--
    While the protocol itself does not provide a way for the server to
    force <acronym>SSL</acronym> encryption, the administrator can
    configure the server to reject unencrypted sessions as a byproduct
    of authentication checking.
-->
プロトコル自体には、サーバに<acronym>SSL</acronym>暗号化を強制する方法は用意されていませんが、管理者は認証検査の一方法として、暗号化されていないセッションを拒否するようにサーバを設定することができます。
   </para>
  </sect2>
 </sect1>

<sect1 id="protocol-replication">
<!--
<title>Streaming Replication Protocol</title>
-->
<title>ストリーミングレプリケーションプロトコル</title>

<para>
<!--
To initiate streaming replication, the frontend sends the
<literal>replication</> parameter in the startup message. A Boolean value
of <literal>true</> tells the backend to go into walsender mode, wherein a
small set of replication commands can be issued instead of SQL statements. Only
the simple query protocol can be used in walsender mode.
Passing <literal>database</> as the value instructs walsender to connect to
the database specified in the <literal>dbname</> parameter, which will allow
the connection to be used for logical replication from that database.
-->
ストリーミングレプリケーションを初期化するために、フロントエンドは開始メッセージにて<literal>replication</>パラメータを送信します。
ブール値の<literal>true</>がバックエンドに対して、SQL文ではなく小規模なレプリケーションコマンド群を発行できるようになる、walsenderモードに入るように伝えます。
walsenderモードでは簡易問い合わせプロトコルのみを使用することができます。
<literal>database</>を値として渡すことにより、
<literal>dbname</>パラメータに指定したデータベースに接続することをwalsenderに教えます。
それにより、そのデータベースからの論理的レプリケーションとして使用する接続が可能となります。
</para>
<para>
<!--
 For the purpose of testing replication commands, you can make a replication
 connection via <application>psql</application> or any other <literal>libpq</literal>-using
 tool with a connection string including the <literal>replication</literal> option,
 e.g.:
-->
レプリケーションコマンドをテストするために、<literal>replication</literal>オプションを含む接続文字列を使用して、<application>psql</application>または他の<literal>libpq</literal>によるレプリケーション接続を作成できます。
例を示します。
<programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
</programlisting>
<!--
 However it is often more useful to use
 <application>pg_receivexlog</application> (for physical replication) or
 <application>pg_recvlogical</application> (for logical replication).
-->
しかし、物理的レプリケーションのために<application>pg_receivexlog</application>を使用し、論理的レプリケーションのために<application>pg_recvlogical</application>を使用すれば、もっと有用なことが多いです。
</para>

<para>
<!--
The commands accepted in walsender mode are:
-->
walsenderモードで受け付けられるコマンドは以下の通りです。
<variablelist>
  <varlistentry>
    <term>IDENTIFY_SYSTEM
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Requests the server to identify itself. Server replies with a result
      set of a single row, containing four fields:
-->
サーバに自身を識別することを要求します。
サーバは以下の４つのフィールドを持つ単一行の結果セットをもって応答します。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       systemid
      </term>
      <listitem>
      <para>
<!--
       The unique system identifier identifying the cluster. This
       can be used to check that the base backup used to initialize the
       standby came from the same cluster.
-->
クラスタを識別する一意なシステム識別子です。
これを使用してスタンバイを初期化するために使用するベースバックアップが同じクラスタに由来していることを検査することができます。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       timeline
      </term>
      <listitem>
      <para>
<!--
       Current TimelineID. Also useful to check that the standby is
       consistent with the master.
-->
現在のタイムラインIDです。
同様にスタンバイがマスタと一貫性を持つことを検査するために使用されます。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       xlogpos
      </term>
      <listitem>
      <para>
<!--
       Current xlog write location. Useful to get a known location in the
       transaction log where streaming can start.
-->
現在のxlogの書き出し位置です。
ストリーミングを開始できるトランザクションログの既知の位置を得る際に有用です。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       dbname
      </term>
      <listitem>
      <para>
<!--
       Database connected to or NULL.
-->
接続したデータベース名またはNULLです。
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>TIMELINE_HISTORY <replaceable class="parameter">tli</replaceable>
     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Requests the server to send over the timeline history file for timeline
      <replaceable class="parameter">tli</replaceable>.  Server replies with a
      result set of a single row, containing two fields:
-->
<replaceable class="parameter">tli</replaceable>のタイムラインのため、サーバにTIMELINE HISTORYファイルの送付を要求します。
サーバは2列単一行の結果セットを返します。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       filename
      </term>
      <listitem>
      <para>
<!--
       Filename of the timeline history file, e.g <filename>00000002.history</>.
-->
TIMELINE HISTORYファイル名、例えば<filename>00000002.history</>
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       content
      </term>
      <listitem>
      <para>
<!--
       Contents of the timeline history file.
-->
TIMELINE HISTORYファイルの内容
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>CREATE_REPLICATION_SLOT <replaceable class="parameter">slot_name</> { <literal>PHYSICAL</> | <literal>LOGICAL</> <replaceable class="parameter">output_plugin</> }
     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Create a physical or logical replication
      slot. See <xref linkend="streaming-replication-slots"> for more about
      replication slots.
-->
物理的または論理的レプリケーションを作成するスロット。
レプリケーションスロットの詳細は<xref linkend="streaming-replication-slots">を参照。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</></term>
       <listitem>
         <para>
<!--
          The name of the slot to create. Must be a valid replication slot
          name (see <xref linkend="streaming-replication-slots-manipulation">).
-->
作成するスロット名。
有効なレプリケーションスロット名でなければならない。
（<xref linkend="streaming-replication-slots-manipulation">を参照）。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="parameter">output_plugin</></term>
       <listitem>
         <para>
<!--
          The name of the output plugin used for logical decoding
          (see <xref linkend="logicaldecoding-output-plugin">).
-->
論理的デコードに使用される出力プラグイン名。
（<xref linkend="logicaldecoding-output-plugin">を参照）。
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>START_REPLICATION [<literal>SLOT</literal> <replaceable class="parameter">slot_name</>] [<literal>PHYSICAL</literal>] <replaceable class="parameter">XXX/XXX</> [<literal>TIMELINE</literal> <replaceable class="parameter">tli</>]
     <indexterm><primary>START_REPLICATION</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Instructs server to start streaming WAL, starting at
      WAL position <replaceable class="parameter">XXX/XXX</>.
      If <literal>TIMELINE</literal> option is specified,
      streaming starts on timeline <replaceable class="parameter">tli</>;
      otherwise, the server's current timeline is selected. The server can
      reply with an error, e.g. if the requested section of WAL has already
      been recycled. On success, server responds with a CopyBothResponse
      message, and then starts to stream WAL to the frontend.
-->
サーバに対して、WALのストリーミングを<replaceable class="parameter">XXX/XXX</> WAL時点から開始するよう指示します。
<literal>TIMELINE</literal>オプションが指定された場合、ストリーミングは<replaceable class="parameter">tli</>のタイムラインから開始されます。
そうでなければ、サーバの現在のタイムラインが選択されます。
サーバが、例えば、要求されたWALの断片がすでに回収されているなど、エラーを返すことがありえます。
成功時サーバはCopyBothResponseメッセージで応答し、フロントエンドに対するWALストリームを開始します。
     </para>

     <para>
<!--
      If a slot's name is provided
      via <replaceable class="parameter">slot_name</>, it will be updated
      as replication progresses so that the server knows which WAL segments,
      and if <varname>hot_standby_feedback</> is on which transactions,
      are still needed by the standby.
-->
<replaceable class="parameter">slot_name</>を経由してスロット名が提供された場合、それはレプリケーションの進行として更新されます。
それによってサーバは、どのWALセグメントがまだスタンバイに必要か、<varname>hot_standby_feedback</>のトランザクションはどれか、を感知します。
     </para>

     <para>
<!--
      If the client requests a timeline that's not the latest, but is part of
      the history of the server, the server will stream all the WAL on that
      timeline starting from the requested startpoint, up to the point where
      the server switched to another timeline. If the client requests
      streaming at exactly the end of an old timeline, the server responds
      immediately with CommandComplete without entering COPY mode.
-->
最新ではなくて、サーバの過去のタイムラインをクライアントが要求した場合、サーバは要求された開始時点から他のタイムラインに切り替えるまでの、全てのWALストリームを送付します。
クライアントが旧タイムラインの終点のストリームを要求した場合、サーバはCOPYモードに入らずにCommandCompleteをすぐに応答します。
     </para>

     <para>
<!--
      After streaming all the WAL on a timeline that is not the latest one,
      the server will end streaming by exiting the COPY mode. When the client
      acknowledges this by also exiting COPY mode, the server sends a result
      set with one row and two columns, indicating the next timeline in this
      server's history. The first column is the next timeline's ID, and the
      second column is the XLOG position where the switch happened. Usually,
      the switch position is the end of the WAL that was streamed, but there
      are corner cases where the server can send some WAL from the old
      timeline that it has not itself replayed before promoting. Finally, the
      server sends CommandComplete message, and is ready to accept a new
      command.
-->
最新でないタイムラインの全てのWALストリームを送付した後、サーバはCOPYモードを出ることによりストリームを終了します。
クライアントもCOPYモードを出ることにより承認した場合、サーバは2列単一行の結果セットを送付し、サーバにある次のタイムラインを示します。
最初の列は次のタイムラインIDであり、次の列は切り替えたXLOGの位置です。
通常切り替えた位置はWALストリームの終点ですが、昇格する前に再実行されなかった旧タイムラインからWALを送付するというまれな場合もあります。
最後に、サーバはCommandCompleteメッセージを送付し、新規のコマンドを受理できるようになります。
     </para>

     <para>
<!--
      WAL data is sent as a series of CopyData messages.  (This allows
      other information to be intermixed; in particular the server can send
      an ErrorResponse message if it encounters a failure after beginning
      to stream.)  The payload of each CopyData message from server to the
      client contains a message of one of the following formats:
-->
WALデータはCopyDataメッセージ群として送信されます。
（これにより他の情報を混在させることができます。
具体的にはサーバはストリーム開始後に失敗が起きた場合にErrorResponseメッセージを送信することができます。）
サーバからクライアントへの各CopyDataメッセージのペイロード、は以下の書式のどれかを含みます。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          XLogData (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('w')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as WAL data.
-->
メッセージをWALデータとして識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The starting point of the WAL data in this message.
-->
このメッセージ内のWALの開始点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The current end of WAL on the server.
-->
サーバ上の現在のWAL終了点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The server's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのサーバのシステム時刻。
2000年1月1日午前0時からのマイクロ秒。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte<replaceable>n</replaceable>
      </term>
      <listitem>
      <para>
<!--
          A section of the WAL data stream.
-->
WALデータストリームの断片。
      </para>
      <para>
<!--
          A single WAL record is never split across two XLogData messages.
          When a WAL record crosses a WAL page boundary, and is therefore
          already split using continuation records, it can be split at the page
          boundary. In other words, the first main WAL record and its
          continuation records can be sent in different XLogData messages.
-->
単一のWALレコードが2つのXLogDataメッセージに分かれることはありません。
しかしWALレコードがWALページ境界を跨る場合、継続レコードを用いてすでに分割されていますので、ページ境界で分割することができます。
言い換えると、先頭の主WALレコードとその継続レコードは、別のXLogDataメッセージとして分かれることがありえます。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
<!--
          Primary keepalive message (B)
-->
プライマリキープアライブメッセージ(B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('k')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as a sender keepalive.
-->
このメッセージを送信元キープアライブとして識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The current end of WAL on the server.
-->
サーバ上の現在のWAL終端。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The server's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのサーバのシステム時刻。
2000年1月1日午前0時からのマイクロ秒。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
<!--
          1 means that the client should reply to this message as soon as
          possible, to avoid a timeout disconnect. 0 otherwise.
-->
タイムアウトによる切断を避けるため、クライアントがこのメッセージに即時に応答するべき方法の1つ。
0またはその他
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
<!--
       The receiving process can send replies back to the sender at any time,
       using one of the following message formats (also in the payload of a
       CopyData message):
-->
以下のメッセージ書式の1つ（およびCopyDataメッセージのペイロード中のもの）を使用して、受理プロセスは送信者にいつでも応答できます。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
<!--
          Standby status update (F)
-->
スタンバイ状態の更新(F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('r')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as a receiver status update.
-->
メッセージを受信側の状態更新として識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The location of the last WAL byte + 1 received and written to disk
          in the standby.
-->
スタンバイにおいて受信しディスクに書き込まれた最終WALバイト+1の場所。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The location of the last WAL byte + 1 flushed to disk in
          the standby.
-->
スタンバイにおいてディスクに吐き出された最終WALバイト+1の場所。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The location of the last WAL byte + 1 applied in the standby.
-->
スタンバイにおいて適用された最終WALバイト+1の場所。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The client's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのクライアントのシステム時刻。
2000年1月1日午前0時からのマイクロ秒。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
<!--
          If 1, the client requests the server to reply to this message
          immediately. This can be used to ping the server, to test if
          the connection is still healthy.
-->
値が1の場合、このメッセージにすぐ応答するように、クライアントはサーバへ要求します。
この方法は、接続がまだ保持されているか検査するために、サーバへのピング送信として使用できます。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
<!--
          Hot Standby feedback message (F)
-->
ホットスタンバイフィードバックメッセージ(F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('h')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as a Hot Standby feedback message.
-->
メッセージをホットスタンバイのフィードバックメッセージとして識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The client's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのクライアントのシステム時刻。
2000年1月1日午前0時からのマイクロ秒
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
<!--
          The standby's current xmin. This may be 0, if the standby is
          sending notification that Hot Standby feedback will no longer
          be sent on this connection. Later non-zero messages may
          reinitiate the feedback mechanism.
-->
スタンバイの現在のxminです。
もはやホットスタンバイフィードバックがこの接続では送信されないという通知を、スタンバイが送信している場合、この値は0でしょう。
後ほど、0でないメッセージがフィードバック機構を再び開始します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
<!--
          The standby's current epoch.
-->
スタンバイの現在のエポックです。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>START_REPLICATION <literal>SLOT</literal> <replaceable class="parameter">slot_name</> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</> [ ( <replaceable>option_name</replaceable> [<replaceable>option_value</replaceable>] [, ... ] ) ]</term>
    <listitem>
     <para>
<!--
      Instructs server to start streaming WAL for logical replication, starting
      at WAL position <replaceable class="parameter">XXX/XXX</>. The server can
      reply with an error, e.g. if the requested section of WAL has already
      been recycled. On success, server responds with a CopyBothResponse
      message, and then starts to stream WAL to the frontend.
-->
サーバに対して、<replaceable class="parameter">XXX/XXX</>WAL時点から、論理的レプリケーションのWALストリームを開始するよう指示します。
例えば、要求されたWALがすでに回収された場合、サーバはエラーを返します。
サーバが、例えば、要求されたWALセクションがすでに回収されている場合、エラーを返すことがありえます。
成功時サーバはCopyBothResponseメッセージで応答し、フロントエンドに対するWALストリームを開始します。
     </para>

     <para>
<!--
      The messages inside the CopyBothResponse messages are of the same format
      documented for <literal>START_REPLICATION ... PHYSICAL</literal>.
-->
CopyBothResponse内部のメッセージは、<literal>START_REPLICATION ... PHYSICAL</literal>の記述と同じ書式です。
     </para>

     <para>
<!--
      The output plugin associated with the selected slot is used
      to process the output for streaming.
-->
選択されたスロットに関連した出力プラグインは、出力ストリームの処理に使用されます。
     </para>

     <variablelist>
      <varlistentry>
       <term><literal>SLOT</literal> <replaceable class="parameter">slot_name</></term>
       <listitem>
         <para>
<!--
          The name of the slot to stream changes from. This parameter is required,
          and must correspond to an existing logical replication slot created
          with <literal>CREATE_REPLICATION_SLOT</literal> in
          <literal>LOGICAL</literal> mode.
-->
ストリームを変更したスロット名。
このパラメータは必須であり、<literal>LOGICAL</literal>モードにおいて<literal>CREATE_REPLICATION_SLOT</literal>によって作成された、実在する論理的レプリケーションスロットに対応しなければなりません。
         </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">XXX/XXX</></term>
       <listitem>
        <para>
<!--
         The WAL position to begin streaming at.
-->
ストリームを開始するWAL時点。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_name</></term>
       <listitem>
        <para>
<!--
         The name of an option passed to the slot's logical decoding plugin.
-->
論理的デコードプラグインスロットに渡すオプション名。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_value</></term>
       <listitem>
        <para>
<!--
         Optional value, in the form of a string constant, associated with the
         specified option.
-->
指定されたオプションに関連した省略可能な値。
文字列定数の形式。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>DROP_REPLICATION_SLOT <replaceable class="parameter">slot_name</>
     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Drops a replication slot, freeing any reserved server-side resources. If
      the slot is currently in use by an active connection, this command fails.
-->
レプリケーションスロットを削除し、サーバ側で準備した資源を解放します。
実行中の接続に現在スロットが使用中の場合、このコマンドは失敗します。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</></term>
       <listitem>
         <para>
<!--
          The name of the slot to drop.
-->
削除するスロット名。
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>BASE_BACKUP [<literal>LABEL</literal> <replaceable>'label'</replaceable>] [<literal>PROGRESS</literal>] [<literal>FAST</literal>] [<literal>WAL</literal>] [<literal>NOWAIT</literal>] [<literal>MAX_RATE</literal> <replaceable>rate</replaceable>]
     <indexterm><primary>BASE_BACKUP</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Instructs the server to start streaming a base backup.
      The system will automatically be put in backup mode before the backup
      is started, and taken out of it when the backup is complete. The
      following options are accepted:
-->
サーバにベースバックアップのストリーミングを始めるよう指示します。
システムはバックアップが開始される前に自動的にバックアップモードになり、バックアップが完了した時に取り出されます。
以下のオプションを受け付けることができます。
      <variablelist>
       <varlistentry>
        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
        <listitem>
         <para>
<!--
          Sets the label of the backup. If none is specified, a backup label
          of <literal>base backup</literal> will be used. The quoting rules
          for the label are the same as a standard SQL string with
          <xref linkend="guc-standard-conforming-strings"> turned on.
-->
バックアップのラベルを設定します。
指定がない場合、<literal>base backup</literal>というバックアップラベルが使用されます。
ラベルについての引用符付け規則は、<xref linkend="guc-standard-conforming-strings">を有効にした場合の標準SQLの文字列の規則と同じです。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>PROGRESS</></term>
        <listitem>
         <para>
<!--
          Request information required to generate a progress report. This will
          send back an approximate size in the header of each tablespace, which
          can be used to calculate how far along the stream is done. This is
          calculated by enumerating all the file sizes once before the transfer
          is even started, and may as such have a negative impact on the
          performance - in particular it may take longer before the first data
          is streamed. Since the database files can change during the backup,
          the size is only approximate and may both grow and shrink between
          the time of approximation and the sending of the actual files.
-->
進行状況の報告を生成するために必要な情報を要求します。
これは、ストリームが完了するまでにどのくらいかかるかを計算するために使用することができる、各テーブル空間のヘッダ内の概算容量を返送します。
これは、転送を始める前のすべてのファイルサイズを１度数え上げることで計算されます。
これ自体が性能に与える悪影響があるかもしれません。
特に最初のデータがストリームされるまでにより多くの時間がかかる可能性があります。
データベースファイルはバックアップの間変更される可能性がありますので、容量は概算に過ぎず、概算時と実ファイルを送信するまでの間に増減される可能性があります。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAST</></term>
        <listitem>
         <para>
<!--
          Request a fast checkpoint.
-->
高速チェックポイントを要求します。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAL</literal></term>
        <listitem>
         <para>
<!--
          Include the necessary WAL segments in the backup. This will include
          all the files between start and stop backup in the
          <filename>pg_xlog</filename> directory of the base directory tar
          file.
-->
バックアップ内に必要なWALセグメントを含めます。
ベースディレクトリtarファイルの<filename>pg_xlog</filename>ディレクトリにある、バックアップの開始から終了までのすべてのファイルが含まれます。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOWAIT</literal></term>
        <listitem>
         <para>
<!--
          By default, the backup will wait until the last required xlog
          segment has been archived, or emit a warning if log archiving is
          not enabled. Specifying <literal>NOWAIT</literal> disables both
          the waiting and the warning, leaving the client responsible for
          ensuring the required log is available.
-->
デフォルトでは、バックアップは必要な最終xlogセグメントがアーカイブされるまで待機します。
ログアーカイブが有効でない場合は警告が発せられます。
<literal>NOWAIT</literal>により、必要なログが利用できるようになったことを確認することをクライアント側の責任として、この待機や警告が無効になります。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>MAX_RATE</literal> <replaceable>rate</></term>
        <listitem>
         <para>
<!--
          Limit (throttle) the maximum amount of data transferred from server
          to client per unit of time.  The expected unit is kilobytes per second.
          If this option is specified, the value must either be equal to zero
          or it must fall within the range from 32 kB through 1 GB (inclusive).
          If zero is passed or the option is not specified, no restriction is
          imposed on the transfer.
-->
サーバからクライアントへ転送する単位時間当たりの最大データ容量を制限します（絞ります）。
予期される単位はkB/s（キロバイト/秒）です。
このオプションが指定された場合、値はゼロまたは32 kB以上1 GB以下でなければなりません。
ゼロが渡されるかオプションが指定されない場合、転送の制約は課されません。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
<!--
      When the backup is started, the server will first send two
      ordinary result sets, followed by one or more CopyResponse
      results.
-->
バックアップを開始する時、サーバはまず２つの通常の結果セットを送信し、続けて１つ以上のCopyResponse結果を送信します。
     </para>
     <para>
<!--
      The first ordinary result set contains the starting position of the
      backup, in a single row with two columns. The first column contains
      the start position given in XLogRecPtr format, and the second column
      contains the corresponding timeline ID.
-->
最初の通常の結果セットには、1行2列という形でバックアップの開始位置が含まれます。
最初の列にはXLogRecPtr書式の開始位置が、2番目の列には対応するタイムラインIDが含まれます。
     </para>
     <para>
<!--
      The second ordinary result set has one row for each tablespace.
      The fields in this row are:
-->
２番目の通常の結果セットには各テーブル空間に付き１行を持ちます。
この行のフィールドは以下の通りです。
      <variablelist>
       <varlistentry>
        <term>spcoid</term>
        <listitem>
         <para>
<!--
          The oid of the tablespace, or <literal>NULL</> if it's the base
          directory.
-->
テーブル空間のoidです。
ベースディレクトリの場合は<literal>NULL</>です。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>spclocation</term>
        <listitem>
         <para>
<!--
          The full path of the tablespace directory, or <literal>NULL</>
          if it's the base directory.
-->
テーブル空間ディレクトリのフルパスです。
ベースディレクトリの場合は<literal>NULL</>です。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>size</term>
        <listitem>
         <para>
<!--
          The approximate size of the tablespace, if progress report has
          been requested; otherwise it's <literal>NULL</>.
-->
進行状況報告が要求された場合は、テーブル空間の概算容量です。
要求されていない場合は<literal>NULL</>です。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
<!--
      After the second regular result set, one or more CopyResponse results
      will be sent, one for PGDATA and one for each additional tablespace other
      than <literal>pg_default</> and <literal>pg_global</>. The data in
      the CopyResponse results will be a tar format (following the
      <quote>ustar interchange format</> specified in the POSIX 1003.1-2008
      standard) dump of the tablespace contents, except that the two trailing
      blocks of zeroes specified in the standard are omitted.
      After the tar data is complete, a final ordinary result set will be sent,
      containing the WAL end position of the backup, in the same format as
      the start position.
-->
２番目の通常の結果セットの後、１つ以上のCopyResponse結果が送信されます。
１つはPGDATA用、<literal>pg_default</>、<literal>pg_global</>以外の追加のテーブル空間ごとに1つ送信されます。
CopyResponse結果内のデータは、テーブル空間の内容のtar形式（POSIX 1003.1-2008標準で規定された<quote>ustar交換形式</>に従う）ダンプです。
ただし標準で規定された最後の２つのゼロブロックは省略されています。
このtarデータが終わった後、最終の通常結果セットが送信されます。
結果セットには、開始位置と同じ書式のバックアップのWAL終了位置が含まれます。
     </para>

     <para>
<!--
      The tar archive for the data directory and each tablespace will contain
      all files in the directories, regardless of whether they are
      <productname>PostgreSQL</> files or other files added to the same
      directory. The only excluded files are:
-->
データディレクトリと各テーブル空間のtarアーカイブには、そのディレクトリ内のファイルが<productname>PostgreSQL</>ファイルかそのディレクトリに追加された他のファイルかに関係なく、すべて含まれます。
以下に除かれるファイルを示します。
      <itemizedlist spacing="compact" mark="bullet">
       <listitem>
        <para>
         <filename>postmaster.pid</>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>postmaster.opts</>
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         various temporary files created during the operation of the PostgreSQL server
-->
PostgreSQLサーバの操作中に、種々の一時ファイルが作成されます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <filename>pg_xlog</>, including subdirectories. If the backup is run
         with WAL files included, a synthesized version of <filename>pg_xlog</filename> will be
         included, but it will only contain the files necessary for the
         backup to work, not the rest of the contents.
-->
サブディレクトリを含む<filename>pg_xlog</>。
バックアップがwalファイルを含めて実行される場合、合成された版の<filename>pg_xlog</filename>が含まれます。
これにはバックアップが動作するために必要なファイルのみが含まれ、残りの内容は含まれません。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <filename>pg_replslot</> is copied as an empty directory.
-->
<filename>pg_replslot</>が空ディレクトリとしてコピーされます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Files other than regular files and directories, such as symbolic
         links and special device files, are skipped.  (Symbolic links
         in <filename>pg_tblspc</filename> are maintained.)
-->
通常のファイルとディレクトリ以外のもの、シンボリックリンクや特殊なデバイスファイルは省略されます。
（<filename>pg_tblspc</filename>中のシンボリックリンクは保持されます。）
        </para>
       </listitem>
      </itemizedlist>
<!--
      Owner, group and file mode are set if the underlying file system on
      the server supports it.
-->
サーバ上の基盤となるファイルシステムがサポートする場合、所有者、グループ、ファイルのモードが設定されます。
     </para>
     <para>
<!--
      Once all tablespaces have been sent, a final regular result set will
      be sent. This result set contains the end position of the
      backup, given in XLogRecPtr format as a single column in a single row.
-->
すべてのテーブル空間が送信された後、最終の通常の結果セットが送信されます。
この結果セットには、単一行の単一列という形でXLogRecPtr書式のバックアップの終了位置が含まれます。
     </para>
    </listitem>
  </varlistentry>
</variablelist>

</para>

</sect1>

<sect1 id="protocol-message-types">
<!--
<title>Message Data Types</title>
-->
<title>メッセージのデータ型</title>

<para>
<!--
This section describes the base data types used in messages.
-->
本節ではメッセージの中で使われる基本的なデータ型を説明します。

<variablelist>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
</term>
<listitem>
<para>
<!--
                An <replaceable>n</replaceable>-bit integer in network byte
                order (most significant byte first).
                If <replaceable>i</replaceable> is specified it
                is the exact value that will appear, otherwise the value
                is variable.  Eg. Int16, Int32(42).
-->
ネットワークバイト順（最上位バイトが先頭）における<replaceable>n</replaceable>ビットの整数。
もし<replaceable>i</replaceable>が指定されていれば、それがそのまま使われます。
さもなければ変数です。
例えばInt16、Int32(42)などです。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
</term>
<listitem>
<para>
<!--
                An array of <replaceable>k</replaceable>
                <replaceable>n</replaceable>-bit integers, each in network
                byte order.  The array length <replaceable>k</replaceable>
                is always determined by an earlier field in the message.
                Eg. Int16[M].
-->
<replaceable>n</replaceable>ビット整数の要素数<replaceable>k</replaceable>の配列で、それぞれはネットワークバイト順です。
配列サイズ<replaceable>k</replaceable>は常にメッセージの前のフィールドで決定されます。
例えばInt16[M]です。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        String(<replaceable>s</replaceable>)
</term>
<listitem>
<para>
<!--
                A null-terminated string (C-style string).  There is no
                specific length limitation on strings.
                If <replaceable>s</replaceable> is specified it is the exact
                value that will appear, otherwise the value is variable.
                Eg. String, String("user").
-->
NULL終端文字列（C様式文字列）。文字列には長さ制限の指定はありません。
<replaceable>s</replaceable>が指定されていれば、それがそのまま使われます。
さもなければ値は変数です。
例えばString、String("user")などです。
</para>

<note>
<para>
<!--
<emphasis>There is no predefined limit</emphasis> on the length of a string
that can be returned by the backend.  Good coding strategy for a frontend
is to use an expandable buffer so that anything that fits in memory can be
accepted.  If that's not feasible, read the full string and discard trailing
characters that don't fit into your fixed-size buffer.
-->
バックエンドから返すことができる文字列の長さには<emphasis>事前に定義された制限はありません</emphasis>。
フロントエンドではメモリに収まるものはすべて受け入れられるように拡張可能なバッファを使用するコーディング戦略を勧めます。
これが実行できないのであれば、文字列全体を読み取り、固定長バッファに合わない後の方の文字を破棄してください。
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
</term>
<listitem>
<para>
<!--
                Exactly <replaceable>n</replaceable> bytes.  If the field
                width <replaceable>n</replaceable> is not a constant, it is
                always determinable from an earlier field in the message.
                If <replaceable>c</replaceable> is specified it is the exact
                value.  Eg. Byte2, Byte1('\n').
-->
厳密に<replaceable>n</replaceable>バイト。
フィールド幅<replaceable>n</replaceable>が定数でない場合、メッセージの前のフィールドから決定されます。
<replaceable>c</replaceable>が指定されていれば、それがそのまま使われます。
例えば Byte2、Byte1('\n')などです。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="protocol-message-formats">
<!--
<title>Message Formats</title>
-->
<title>メッセージの書式</title>

<para>
<!--
This section describes the detailed format of each message.  Each is marked to
indicate that it can be sent by a frontend (F), a backend (B), or both
(F &amp; B).
Notice that although each message includes a byte count at the beginning,
the message format is defined so that the message end can be found without
reference to the byte count.  This aids validity checking.  (The CopyData
message is an exception, because it forms part of a data stream; the contents
of any individual CopyData message cannot be interpretable on their own.)
-->
本節ではそれぞれのメッセージの詳細書式について説明します。
それぞれにはフロントエンド（F）、バックエンド（B）あるいは双方（F &amp; B）から送出されることを示す印が付いています。
各メッセージには先頭にバイト数を持っていますが、バイト数を参照しなくてもメッセージの終わりを検知できるようにメッセージ書式は定義されています。
これは有効性検査を補助します。
（CopyDataメッセージはデータストリームの一部を形成しますので例外です。
個々のCopyDataメッセージの内容は自身でも解釈することができません。）
</para>

<variablelist>


<varlistentry>
<term>
AuthenticationOk (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
認証要求としてメッセージを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(0)
</term>
<listitem>
<para>
<!--
                Specifies that the authentication was successful.
-->
認証が成功したことを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationKerberosV5 (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージを認証要求として識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(2)
</term>
<listitem>
<para>
<!--
                Specifies that Kerberos V5 authentication is required.
-->
Kerberos V5認証が必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationCleartextPassword (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージを認証要求として識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(3)
</term>
<listitem>
<para>
<!--
                Specifies that a clear-text password is required.
-->
平文パスワードが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationMD5Password (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
<!--
                Specifies that an MD5-encrypted password is required.
-->
MD5暗号化パスワードが必要であることを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte4
</term>
<listitem>
<para>
<!--
                The salt to use when encrypting the password.
-->
パスワード暗号化用ソルトです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSCMCredential (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(6)
</term>
<listitem>
<para>
<!--
                Specifies that an SCM credentials message is required.
-->
SCM資格証明メッセージが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationGSS (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(7)
</term>
<listitem>
<para>
<!--
                Specifies that GSSAPI authentication is required.
-->
GSSAPI認証証明メッセージが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSSPI (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(9)
</term>
<listitem>
<para>
<!--
                Specifies that SSPI authentication is required.
-->
SSPI認証証明メッセージが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
AuthenticationGSSContinue (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Specifies that this message contains GSSAPI or SSPI data.
-->
このメッセージがGSSPAIまたはSSPIデータを含むことを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                GSSAPI or SSPI authentication data.
-->
GSSAPIまたはSSPI認証データです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BackendKeyData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
<!--
                Identifies the message as cancellation key data.
                The frontend must save these values if it wishes to be
                able to issue CancelRequest messages later.
-->
メッセージが取消用キーデータであることを識別します。
もし、後でCancelRequestメッセージを発行する可能性があれば、フロントエンドはこの値を保存しなければなりません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The process ID of this backend.
-->
このバックエンドのプロセスID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The secret key of this backend.
-->
このバックエンドの秘密鍵。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Bind (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Bind command.
-->
このメッセージがBindコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the destination portal
                (an empty string selects the unnamed portal).
-->
宛先ポータルの名前です
（空文字列で無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the source prepared statement
                (an empty string selects the unnamed prepared statement).
-->
元となるプリペアド文の名前です
（空文字列で無名のプリペアド文を選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameter format codes that follow
                (denoted <replaceable>C</> below).
                This can be zero to indicate that there are no parameters
                or that the parameters all use the default format (text);
                or one, in which case the specified format code is applied
                to all parameters; or it can equal the actual number of
                parameters.
-->
後続するパラメータ書式コードの数
（以下では<replaceable>C</>で表します）。
これは、パラメータが存在しない、あるいはすべてのパラメータがデフォルトの書式（テキスト）を使用することを示す0に、指定する書式コードをすべてのパラメータに適用することを示す1にすることができます。
さもなくば、これは実際のパラメータ数と同じになります。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</>]
</term>
<listitem>
<para>
<!--
                The parameter format codes.  Each must presently be
                zero (text) or one (binary).
-->
パラメータ書式コード。
現在、それぞれは0（テキスト）もしくは1（バイナリ）のいずれかでなければなりません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameter values that follow (possibly zero).
                This must match the number of parameters needed by the query.
-->
後続するパラメータ値の数
（ゼロの場合もあります）。
これは問い合わせが必要とするパラメータ数と一致する必要があります。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following pair of fields appear for each parameter:
-->
次に、各パラメータに対して、以下のフィールドのペアが現れます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the parameter value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL parameter value.
                No value bytes follow in the NULL case.
-->
パラメータ値のバイト単位の長さ（これには自身は含まれません）。
ゼロにすることもできます。
特別な場合として、-1はNULLというパラメータ値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the parameter, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式におけるパラメータの値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        After the last parameter, the following fields appear:
-->
最後のパラメータの後に、以下のフィールドが現れます。
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of result-column format codes that follow
                (denoted <replaceable>R</> below).
                This can be zero to indicate that there are no result columns
                or that the result columns should all use the default format
                (text);
                or one, in which case the specified format code is applied
                to all result columns (if any); or it can equal the actual
                number of result columns of the query.
-->
後続する結果列書式コードの数
（以下では<replaceable>R</>で表します）。
これは、結果列が存在しないことを示す0、あるいはすべての結果列が（もしあれば）デフォルトの書式コード（テキスト）を使用することを示す1にすることができます。
さもなくば、問い合わせの結果列の実際の数と同じになります。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>R</>]
</term>
<listitem>
<para>
<!--
                The result-column format codes.  Each must presently be
                zero (text) or one (binary).
-->
結果列の書式コード。
現在それぞれは0（テキスト）もしくは1（バイナリ）のいずれかでなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BindComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('2')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Bind-complete indicator.
-->
メッセージがBind完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CancelRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(16)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877102)
</term>
<listitem>
<para>
<!--
                The cancel request code.  The value is chosen to contain
                <literal>1234</> in the most significant 16 bits, and <literal>5678</> in the
                least 16 significant bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
-->
取消要求コードです。
この値は、最上位16ビットに<literal>1234</>が、下位16ビットに<literal>5678</>を持つように選択されます。
（混乱を防ぐため、このコードはプロトコルバージョン番号と同一になってはいけません。）
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The process ID of the target backend.
-->
対象バックエンドのプロセスIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The secret key for the target backend.
-->
対象バックエンドの秘密鍵です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Close (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Close command.
-->
メッセージがCloseコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                '<literal>S</>' to close a prepared statement; or
                '<literal>P</>' to close a portal.
-->
プリペアド文を閉ざす時は'<literal>S</>'。
ポータルを閉ざす時は'<literal>P</>'です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the prepared statement or portal to close
                (an empty string selects the unnamed prepared statement
                or portal).
-->
閉ざすプリペアド文またはポータルの名前です
（空文字列で無名のプリペアド文または無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CloseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('3')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Close-complete indicator.
-->
メッセージがClose完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CommandComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
<!--
                Identifies the message as a command-completed response.
-->
メッセージがコマンド完了応答であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
       <para>
<!--
        The command tag.  This is usually a single
        word that identifies which SQL command was completed.
-->
コマンドタグです。
これは通常どのSQLコマンドが完了したかを表す単一の単語です。
       </para>

       <para>
<!--
        For an <command>INSERT</command> command, the tag is
        <literal>INSERT <replaceable>oid</replaceable>
        <replaceable>rows</replaceable></literal>, where
        <replaceable>rows</replaceable> is the number of rows
        inserted. <replaceable>oid</replaceable> is the object ID
        of the inserted row if <replaceable>rows</replaceable> is 1
        and the target table has OIDs;
        otherwise <replaceable>oid</replaceable> is 0.
-->
<command>INSERT</command>コマンドの場合、タグは<literal>INSERT <replaceable>oid</replaceable> <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は挿入された行数です。
<replaceable>oid</replaceable>は、<replaceable>rows</replaceable>が1、かつ、対象テーブルがOIDを持つ場合、挿入された行のオブジェクトIDです。
さもなければ、<replaceable>oid</replaceable>は0です。
       </para>

       <para>
<!--
        For a <command>DELETE</command> command, the tag is
        <literal>DELETE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows deleted.
-->
<command>DELETE</command>コマンドの場合、タグは<literal>DELETE <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は削除された行数です。
       </para>

       <para>
<!--
        For an <command>UPDATE</command> command, the tag is
        <literal>UPDATE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows updated.
-->
<command>UPDATE</command>コマンドの場合、タグは<literal>UPDATE <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は更新された行数です。
       </para>

       <para>
<!--
        For a <command>SELECT</command> or <command>CREATE TABLE AS</command>
        command, the tag is <literal>SELECT <replaceable>rows</replaceable></literal>
        where <replaceable>rows</replaceable> is the number of rows retrieved.
-->
<command>SELECT</command>または<command>CREATE TABLE AS</command>の場合、タグは<literal>SELECT <replaceable>rows</replaceable></literal>となります。
ここで<replaceable>rows</replaceable>は取り込んだ行数です。
       </para>

       <para>
<!--
        For a <command>MOVE</command> command, the tag is
        <literal>MOVE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows the
        cursor's position has been changed by.
-->
<command>MOVE</command>コマンドの場合、タグは<literal>MOVE <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は、カーソル位置が何行変更されたかを示す数です。
       </para>

       <para>
<!--
        For a <command>FETCH</command> command, the tag is
        <literal>FETCH <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows that
        have been retrieved from the cursor.
-->
<command>FETCH</command>コマンドの場合、タグは<literal>FETCH <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は、カーソルから何行取り出したかを示す行数です。
       </para>

       <para>
<!--
        For a <command>COPY</command> command, the tag is
        <literal>COPY <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows copied.
        (Note: the row count appears only in
        <productname>PostgreSQL</productname> 8.2 and later.)
-->
<command>COPY</command>コマンドの場合、タグは<literal>COPY <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は、コピーされた行数です（注意：この行数は<productname>PostgreSQL</productname> 8.2以降でのみ出力されます）。
       </para>

</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyData (F &amp; B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('d')
</term>
<listitem>
<para>
<!--
                Identifies the message as <command>COPY</command> data.
-->
メッセージがデータの<command>COPY</command>であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                Data that forms part of a <command>COPY</command> data stream.  Messages sent
                from the backend will always correspond to single data rows,
                but messages sent by frontends might divide the data stream
                arbitrarily.
-->
<command>COPY</command>データストリームの一部を形成するデータです。
バックエンドから送信されるメッセージは、常に1つのデータ行に対応します。
しかし、フロントエンドから送信されるメッセージは任意のデータストリームに分割される可能性があります。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyDone (F &amp; B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('c')
</term>
<listitem>
<para>
<!--
                Identifies the message as a <command>COPY</command>-complete indicator.
-->
メッセージが<command>COPY</command>完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyFail (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('f')
</term>
<listitem>
<para>
<!--
                Identifies the message as a <command>COPY</command>-failure indicator.
-->
メッセージが<command>COPY</command>失敗指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                An error message to report as the cause of failure.
-->
失敗の原因を報告するエラーメッセージです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyInResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('G')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Start Copy In response.
                The frontend must now send copy-in data (if not
                prepared to do so, send a CopyFail message).
-->
メッセージがStart Copy Inの応答であることを識別します。
フロントエンドはここで必ずコピーインデータを送信しなければなりません
（まだ準備ができていない場合はCopyFailメッセージを送信してください）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                0 indicates the overall <command>COPY</command> format is textual (rows
                separated by newlines, columns separated by separator
                characters, etc).
                1 indicates the overall copy format is binary (similar
                to DataRow format).
                See <xref linkend="sql-copy">
                for more information.
-->
0は<command>COPY</command>全体の書式がテキスト（行は改行で区切られ、列は区切り文字などで区切られます）であることを示します。
1は、コピー全体の書式がバイナリ（DataRowの書式と同様）であることを示します。
より詳細については<xref linkend="sql-copy">を参照してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of columns in the data to be copied
                (denoted <replaceable>N</> below).
-->
コピーされるデータ内の列数です
（以下では<replaceable>N</>と表されます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</>]
</term>
<listitem>
<para>
<!--
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
-->
各列で使用される書式コードです。
現在それぞれは0（テキスト）または1（バイナリ）でなければなりません。
コピー全体の書式がテキストの場合、すべてが0でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyOutResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Start Copy Out response.
                This message will be followed by copy-out data.
-->
メッセージがStart Copy Outの応答であることを識別します。
このメッセージの後にコピーアウトデータが続きます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                0 indicates the overall <command>COPY</command> format
                is textual (rows separated by newlines, columns
                separated by separator characters, etc). 1 indicates
                the overall copy format is binary (similar to DataRow
                format). See <xref linkend="sql-copy"> for more information.
-->
0は<command>COPY</command>全体の書式がテキスト（行は改行で区切られ、列は区切り文字などで区切られます）であることを示します。
1はコピー全体の書式がバイナリ（DataRowの書式同様）であることを示します。
詳細については<xref linkend="sql-copy">を参照してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of columns in the data to be copied
                (denoted <replaceable>N</> below).
-->
コピーされるデータ内の列数です
（以下では<replaceable>N</>と表されます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</>]
</term>
<listitem>
<para>
<!--
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
-->
各列で使用される書式コードです。
現在それぞれは0（テキスト）または1（バイナリ）でなければなりません。
コピー全体の書式がテキストの場合、すべてが0でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyBothResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('W')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Start Copy Both response.
                This message is used only for Streaming Replication.
-->
メッセージがStart Copy Bothの応答であることを識別します。
このメッセージはストリーミングレプリケーションのみで使用されます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                0 indicates the overall <command>COPY</command> format
                is textual (rows separated by newlines, columns
                separated by separator characters, etc). 1 indicates
                the overall copy format is binary (similar to DataRow
                format). See <xref linkend="sql-copy"> for more information.
-->
0は<command>COPY</command>全体の書式がテキスト（行は改行で区切られ、列は区切り文字などで区切られます）であることを示します。
1はコピー全体の書式がバイナリ（DataRowの書式同様）であることを示します。
詳細については<xref linkend="sql-copy">を参照してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of columns in the data to be copied
                (denoted <replaceable>N</> below).
-->
コピーされるデータ内の列数です
（以下では<replaceable>N</>と表されます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</>]
</term>
<listitem>
<para>
<!--
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
-->
各列で使用される書式コードです。
現在それぞれは0（テキスト）または1（バイナリ）でなければなりません。
コピー全体の書式がテキストの場合、すべてが0でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
DataRow (B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
<!--
                Identifies the message as a data row.
-->
メッセージがデータ行であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of column values that follow (possibly zero).
-->
後に続く列値の数です
（ゼロの場合もあります）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following pair of fields appear for each column:
-->
次に、各列について以下のフィールドのペアが現れます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the column value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL column value.
                No value bytes follow in the NULL case.
-->
列値のバイト単位の長さです
（これには自身は含まれません）。
ゼロとすることもできます。
特別な場合として、-1はNULLという列値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the column, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式における列の値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Describe (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Describe command.
-->
メッセージがDescribeコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                '<literal>S</>' to describe a prepared statement; or
                '<literal>P</>' to describe a portal.
-->
プリペアド文の記述の場合は'<literal>S</>'。
ポータルの記述の場合は'<literal>P</>'です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the prepared statement or portal to describe
                (an empty string selects the unnamed prepared statement
                or portal).
-->
記述を求めるプリペアド文またはポータルの名前です
（空文字列で無名のプリペアド文または無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
EmptyQueryResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
<!--
                Identifies the message as a response to an empty query string.
                (This substitutes for CommandComplete.)
-->
メッセージが空の問い合わせ文字列に対する応答であることを識別します
（これはCommandCompleteを置き換えます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ErrorResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
<!--
                Identifies the message as an error.
-->
メッセージがエラーであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        The message body consists of one or more identified fields,
        followed by a zero byte as a terminator.  Fields can appear in
        any order.  For each field there is the following:
-->
このメッセージの本体には、ゼロバイトを終端として後続する、1つ以上の識別されるフィールドが含まれます。
フィールドは任意の順番で現れる可能性があります。
各フィールドには以下があります。
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                A code identifying the field type; if zero, this is
                the message terminator and no string follows.
                The presently defined field types are listed in
                <xref linkend="protocol-error-fields">.
                Since more field types might be added in future,
                frontends should silently ignore fields of unrecognized
                type.
-->
フィールド種類を識別するコードです。
ゼロならば、メッセージの終端であり、後続する文字列がないことを表します。
<xref linkend="protocol-error-fields">に、現時点でフィールド種類として定義されているものを列挙します。
将来もっと多くのフィールド種類が追加される可能性がありますので、フロントエンドは、認知できない種類のフィールドに対して何もせずに無視すべきです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The field value.
-->
フィールド値です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Execute (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
<!--
                Identifies the message as an Execute command.
-->
メッセージがExecuteコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the portal to execute
                (an empty string selects the unnamed portal).
-->
実行するポータルの名前です。
（空文字列で無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Maximum number of rows to return, if portal contains
                a query that returns rows (ignored otherwise).  Zero
                denotes <quote>no limit</>.
-->
ポータルが行を返す問い合わせの場合、返される行数の最大値です
（他の問い合わせでは無視されます）。
ゼロは<quote>無制限</>を表します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Flush (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Flush command.
-->
メッセージがFlushコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCall (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('F')
</term>
<listitem>
<para>
<!--
                Identifies the message as a function call.
-->
メッセージが関数呼び出しであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Specifies the object ID of the function to call.
-->
呼び出す関数のオブジェクトIDを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of argument format codes that follow
                (denoted <replaceable>C</> below).
                This can be zero to indicate that there are no arguments
                or that the arguments all use the default format (text);
                or one, in which case the specified format code is applied
                to all arguments; or it can equal the actual number of
                arguments.
-->
後述する引数書式コード数です
（以下では<replaceable>C</>と表します）。
これは、引数が存在しない、あるいは、すべての引数がデフォルトの書式（テキスト）を使用することを示す0に、指定する書式コードをすべての引数に適用することを示す1にすることができます。
さもなくば、これは実際の引数の数と同じになります。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</>]
</term>
<listitem>
<para>
<!--
                The argument format codes.  Each must presently be
                zero (text) or one (binary).
-->
引数の書式コードです。
それぞれは、0（テキスト）もしくは1（バイナリ）でなければなりません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                Specifies the number of arguments being supplied to the
                function.
-->
関数に提供する引数の数を指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following pair of fields appear for each argument:
-->
次に、各引数に対して以下のフィールドのペアが現れます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the argument value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL argument value.
                No value bytes follow in the NULL case.
-->
引数の値のバイト単位の長さです
（これには自身は含まれません）。
0とすることもできます。
特別な場合として、-1はNULLという引数の値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the argument, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式における引数の値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>
 <!--
        After the last argument, the following field appears:
-->
最後の引数の後に、以下のフィールドが現れます。
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The format code for the function result. Must presently be
                zero (text) or one (binary).
-->
関数結果用の書式コードです。
現在、0（テキスト）または1（バイナリ）でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCallResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('V')
</term>
<listitem>
<para>
<!--
                Identifies the message as a function call result.
-->
メッセージが関数呼び出しの結果であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the function result value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL function result.
                No value bytes follow in the NULL case.
-->
関数の結果の値のバイト単位の長さです
（これには自身は含まれません）。
ゼロとすることもできます。
特別な場合として、-1はNULLという関数の結果の値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the function result, in the format indicated by
                the associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式における関数の結果の値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
<!--
                Identifies the message as a no-data indicator.
-->
メッセージがデータなしの指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoticeResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
<!--
                Identifies the message as a notice.
-->
メッセージが警報であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        The message body consists of one or more identified fields,
        followed by a zero byte as a terminator.  Fields can appear in
        any order.  For each field there is the following:
-->
このメッセージの本体には、ゼロバイトを終端として後続する、1つ以上の識別されるフィールドが含まれます。
フィールドは任意の順番で現れる可能性があります。
各フィールドには以下があります。
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                A code identifying the field type; if zero, this is
                the message terminator and no string follows.
                The presently defined field types are listed in
                <xref linkend="protocol-error-fields">.
                Since more field types might be added in future,
                frontends should silently ignore fields of unrecognized
                type.
-->
フィールド種類を識別するコードです。
ゼロならば、メッセージの終端であり、後続する文字列がないことを表します。
<xref linkend="protocol-error-fields">に、現時点でフィールド種類として定義されているものを列挙します。
将来もっと多くのフィールド種類が追加される可能性がありますので、フロントエンドは、認知できない種類のフィールドに対して何もせずに無視すべきです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The field value.
-->
フィールドの値です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NotificationResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('A')
</term>
<listitem>
<para>
<!--
                Identifies the message as a notification response.
-->
メッセージが通知応答であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The process ID of the notifying backend process.
-->
通知元バックエンドのプロセスIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the channel that the notify has been raised on.
-->
通知の発生元となったチャネル名です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The <quote>payload</> string passed from the notifying process.
-->
通知プロセスから渡される<quote>ペイロード</>文字列です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
<!--
                Identifies the message as a parameter description.
-->
メッセージがパラメータ記述であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameters used by the statement
                (can be zero).
-->
文で使用されるパラメータ数です
（ゼロとすることができます）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for each parameter, there is the following:
-->
そして、各パラメータに対して、以下が続きます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Specifies the object ID of the parameter data type.
-->
パラメータのデータ型のオブジェクトIDを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterStatus (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
<!--
                Identifies the message as a run-time parameter status report.
-->
メッセージが実行時パラメータ状態報告であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the run-time parameter being reported.
-->
報告される実行時パラメータの名前です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The current value of the parameter.
-->
そのパラメータの現在値です。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Parse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('P')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Parse command.
-->
メッセージがParseコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the destination prepared statement
                (an empty string selects the unnamed prepared statement).
-->
宛先のプリペアド文の名前です
（空文字列で無名のプリペアド文を選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The query string to be parsed.
-->
解析される問い合わせ文字列です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameter data types specified
                (can be zero).  Note that this is not an indication of
                the number of parameters that might appear in the
                query string, only the number that the frontend wants to
                prespecify types for.
-->
指定されるパラメータデータ型の数です
（ゼロとすることができます）。
これは、問い合わせ文字列内にあるパラメータの数を示すものではないことに注意してください。
フロントエンドが型指定を希望するパラメータの数でしかありません。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for each parameter, there is the following:
-->
その後、各パラメータに対し、以下が続きます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Specifies the object ID of the parameter data type.
                Placing a zero here is equivalent to leaving the type
                unspecified.
-->
パラメータのデータ型のオブジェクトIDを指定します。
ここにゼロを書くことは型指定を行わないことと同じです。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('1')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Parse-complete indicator.
-->
メッセージがParse完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PasswordMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
<!--
                Identifies the message as a password response. Note that
                this is also used for GSSAPI and SSPI response messages
                (which is really a design error, since the contained data
                is not a null-terminated string in that case, but can be
                arbitrary binary data).
-->
メッセージがパスワード応答であることを識別します。
これがGSSAPIまたはSSPI応答メッセージでも使用されることに注意してください。
（これは本当は設計エラーです。こうした場合含まれるデータはヌル終端の文字列ではなく、任意のバイナリデータを取り得るためです。）
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The password (encrypted, if requested).
-->
パスワードです
（必要ならば暗号化されています）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PortalSuspended (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('s')
</term>
<listitem>
<para>
<!--
                Identifies the message as a portal-suspended indicator.
                Note this only appears if an Execute message's row-count limit
                was reached.
-->
メッセージがポータル中断指示子であることを識別します。
これは、Executeメッセージの行数制限に達した場合にのみ現れることに注意してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Query (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Q')
</term>
<listitem>
<para>
<!--
                Identifies the message as a simple query.
-->
メッセージが簡易問い合わせであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The query string itself.
-->
問い合わせ文字列自体です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ReadyForQuery (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Z')
</term>
<listitem>
<para>
<!--
                Identifies the message type.  ReadyForQuery is sent
                whenever the backend is ready for a new query cycle.
-->
このメッセージ種類を識別します。
バックエンドで新しい問い合わせサイクルの準備が整った時には常にReadyForQueryが送信されます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                Current backend transaction status indicator.
                Possible values are '<literal>I</>' if idle (not in
                a transaction block); '<literal>T</>' if in a transaction
                block; or '<literal>E</>' if in a failed transaction
                block (queries will be rejected until block is ended).
-->
現在のバックエンドのトランザクション状態指示子です。
取り得る値は、待機状態（トランザクションブロックにない状態）に'<literal>I</>'、トランザクションブロック内の場合に'<literal>T</>'、失敗したトランザクションブロック（ブロックが終わるまで問い合わせは拒絶されます）内の場合に'<literal>E</>'です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
RowDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
<!--
                Identifies the message as a row description.
-->
メッセージが行の記述であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                Specifies the number of fields in a row (can be zero).
-->
行内のフィールド数を指定します
（ゼロとすることができます）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for each field, there is the following:
-->
その後、各フィールドに対して以下が続きます。
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The field name.
-->
フィールド名です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                If the field can be identified as a column of a specific
                table, the object ID of the table; otherwise zero.
-->
フィールドが特定のテーブルの列として識別できる場合、テーブルのオブジェクトIDです。
さもなくばゼロです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                If the field can be identified as a column of a specific
                table, the attribute number of the column; otherwise zero.
-->
フィールドが特定のテーブルの列として識別できる場合、列の属性番号です。
さもなくばゼロです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The object ID of the field's data type.
-->
フィールドのデータ型のオブジェクトIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The data type size (see <varname>pg_type.typlen</>).
                Note that negative values denote variable-width types.
-->
データ型の大きさ（<varname>pg_type.typlen</>を参照）です。
負の値が可変長の型を表すことに注意してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The type modifier (see <varname>pg_attribute.atttypmod</>).
                The meaning of the modifier is type-specific.
-->
型修飾子（<varname>pg_attribute.atttypmod</>を参照）です。
修飾子の意味は型に固有です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The format code being used for the field.  Currently will
                be zero (text) or one (binary).  In a RowDescription
                returned from the statement variant of Describe, the
                format code is not yet known and will always be zero.
-->
フィールドに使用される書式コードです。
現在、0（テキスト）または1（バイナリ）のいずれかになります。
RowDescriptionがステートメント用のDescribeから返された場合、書式コードはまだ不明ですので、常に0になります。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
SSLRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877103)
</term>
<listitem>
<para>
<!--
                The <acronym>SSL</acronym> request code.  The value is chosen to contain
                <literal>1234</> in the most significant 16 bits, and <literal>5679</> in the
                least 16 significant bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
-->
<acronym>SSL</acronym>要求コードです。
この値は、最上位16ビットに<literal>1234</>が、下位16ビットに<literal>5679</>を持つように選択されます
（混乱を防ぐため、このコードはプロトコルバージョン番号と同一になってはいけません）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
StartupMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(196608)
</term>
<listitem>
<para>
<!--
                The protocol version number.  The most significant 16 bits are
                the major version number (3 for the protocol described here).
                The least significant 16 bits are the minor version number
                (0 for the protocol described here).
-->
プロトコルバージョン番号です。
最上位16ビットは主バージョン番号（本章で説明したプロトコルでは3）です。
下位16ビットは副バージョン番号（本章で説明したプロトコルでは0）です。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        The protocol version number is followed by one or more pairs of
        parameter name and value strings.  A zero byte is required as a
        terminator after the last name/value pair.
        Parameters can appear in any
        order.  <literal>user</> is required, others are optional.
        Each parameter is specified as:
-->
プロトコルバージョン番号の後に、1つ以上のパラメータ名と値文字列のペアが続きます。
最後の名前と値のペアの後に終端としてゼロバイトが必要です。
パラメータは任意の順番で現れることができます。
<literal>user</>は必須です。
他は省略可能です。
各パラメータは以下のように指定されます。
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The parameter name.  Currently recognized names are:
-->
パラメータ名です。
現在認識される名前を以下に示します。

<variablelist>
<varlistentry>
<term>
                <literal>user</>
</term>
<listitem>
<para>
<!--
                        The database user name to connect as.  Required;
                        there is no default.
-->
接続するデータベースユーザ名です。
必須。
デフォルトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</>
</term>
<listitem>
<para>
<!--
                        The database to connect to.  Defaults to the user name.
-->
接続するデータベースです。
デフォルトはユーザ名です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</>
</term>
<listitem>
<para>
<!--
                        Command-line arguments for the backend.  (This is
                        deprecated in favor of setting individual run-time
                        parameters.)
-->
バックエンド用のコマンドライン引数です
（これは個々の実行時パラメータ設定のため、廃棄予定です）。
</para>
</listitem>
</varlistentry>
</variablelist>

<!--
                In addition to the above, any run-time parameter that can be
                set at backend start time might be listed.  Such settings
                will be applied during backend start (after parsing the
                command-line options if any).  The values will act as
                session defaults.
-->
上記に加え、バックエンドの起動時に設定可能な、任意の実行時パラメータが列挙される可能性があります。
こうした設定は、バックエンド起動時に（もしあればコマンドラインオプションの解析の後に）適用されます。
この値はセッションのデフォルトとして動作します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The parameter value.
-->
パラメータの値です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Sync (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Sync command.
-->
メッセージがSyncコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Terminate (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('X')
</term>
<listitem>
<para>
<!--
                Identifies the message as a termination.
-->
メッセージが終了であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


</variablelist>

</sect1>


<sect1 id="protocol-error-fields">
<!--
<title>Error and Notice Message Fields</title>
-->
<title>エラーおよび警報メッセージフィールド</title>

<para>
<!--
This section describes the fields that can appear in ErrorResponse and
NoticeResponse messages.  Each field type has a single-byte identification
token.  Note that any given field type should appear at most once per
message.
-->
本節では、ErrorResponseおよびNoticeResponseメッセージ内で現れる可能性があるフィールドについて説明します。
それぞれのフィールド種類は、単一バイトの識別子トークンを持ちます。
メッセージ内に与えられる任意のフィールド種類は、多くてもメッセージ当たり1つでなければならないことに注意してください。
</para>

<variablelist>

<varlistentry>
<term>
<literal>S</>
</term>
<listitem>
<para>
<!--
        Severity: the field contents are
        <literal>ERROR</>, <literal>FATAL</>, or
        <literal>PANIC</> (in an error message), or
        <literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
        <literal>INFO</>, or <literal>LOG</> (in a notice message),
        or a localized translation of one of these.  Always present.
-->
深刻度です。
フィールドの内容は<literal>ERROR</>、<literal>FATAL</>、<literal>PANIC</>（エラーメッセージ内）、<literal>WARNING</>、<literal>NOTICE</>、<literal>DEBUG</>、<literal>INFO</>、<literal>LOG</>（警報メッセージ内）、もしくはこれらの1つの地域化された翻訳です。
常に存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>C</>
</term>
<listitem>
<para>
<!--
        Code: the SQLSTATE code for the error (see <xref
        linkend="errcodes-appendix">).  Not localizable.  Always present.
-->
コード、そのエラー用のSQLSTATEコードです（<xref linkend="errcodes-appendix">を参照）。
地域化されません。
常に存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>M</>
</term>
<listitem>
<para>
<!--
        Message: the primary human-readable error message.
        This should be accurate but terse (typically one line).
        Always present.
-->
メッセージ、主に人にわかりやすいエラーメッセージです。
これは正確、簡潔でなければなりません（通常は1行です）。
常に存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>D</>
</term>
<listitem>
<para>
<!--
        Detail: an optional secondary error message carrying more
        detail about the problem.  Might run to multiple lines.
-->
詳細です。
問題のより詳細を説明する省略可能な二次的なエラーメッセージです。
複数行にまたがる可能性があります。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>H</>
</term>
<listitem>
<para>
<!--
        Hint: an optional suggestion what to do about the problem.
        This is intended to differ from Detail in that it offers advice
        (potentially inappropriate) rather than hard facts.
        Might run to multiple lines.
-->
ヒントです。
その問題にどう対応するかを表す省略可能な提言です。
これは、詳細と異なり、事実ではなく提案（不適切な場合もありますが）を提供することを目的としたものです。
複数行にまたがる可能性があります。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>P</>
</term>
<listitem>
<para>
<!--
        Position: the field value is a decimal ASCII integer, indicating
        an error cursor position as an index into the original query string.
        The first character has index 1, and positions are measured in
        characters not bytes.
-->
位置です。
フィールド値は、エラーカーソルの位置を示すもので、元の問い合わせ文字列へのインデックスを10進ASCIIで表した整数です。
先頭の文字がインデックス1になり、位置はバイトではなく文字で数えられます。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>p</>
</term>
<listitem>
<para>
<!--
        Internal position: this is defined the same as the <literal>P</>
        field, but it is used when the cursor position refers to an internally
        generated command rather than the one submitted by the client.
        The <literal>q</> field will always appear when this field appears.
-->
内部的位置です。
これは<literal>P</>と同じ定義ですが、カーソルの位置がクライアントによって発せられたコマンドではなく内部的に生成されたコマンドを参照する場合に使用されます。
このフィールドが現れる時には常に<literal>q</>も現れます。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>q</>
</term>
<listitem>
<para>
<!--
        Internal query: the text of a failed internally-generated command.
        This could be, for example, a SQL query issued by a PL/pgSQL function.
-->
内部的問い合わせ。
失敗した、内部生成のコマンドテキストです。
これは例えば、PL/pgSQL関数によって発行されたSQL問い合わせなどです。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>W</>
</term>
<listitem>
<para>
<!--
        Where: an indication of the context in which the error occurred.
        Presently this includes a call stack traceback of active
        procedural language functions and internally-generated queries.
        The trace is one entry per line, most recent first.
-->
場所です。
エラーが発生したコンテキストを示します。
現在ここには、実行中の手続き言語関数と内部生成問い合わせの呼び出しスタックトレースバックが含まれます。
この追跡情報は、1行当たり1項目として、最も最近のものが初めに現れます。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>s</>
</term>
<listitem>
<para>
<!--
        Schema name: if the error was associated with a specific database
        object, the name of the schema containing that object, if any.
-->
スキーマ名。
エラーが特定のデータベースオブジェクトに関連する場合、そのオブジェクトを含むスキーマ名。
無名でなければ。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>t</>
</term>
<listitem>
<para>
<!--
        Table name: if the error was associated with a specific table, the
        name of the table.  (Refer to the schema name field for the name of
        the table's schema.)
-->
テーブル名。
エラーが特定のテーブルに関連する場合、そのテーブル名。
（スキーマ名フィールドにおいて、そのテーブルのスキーマ名を参照します。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>c</>
</term>
<listitem>
<para>
<!--
        Column name: if the error was associated with a specific table column,
        the name of the column.  (Refer to the schema and table name fields to
        identify the table.)
-->
列名。
エラーが特定のテーブルの列に関連する場合、その列名。
（テーブルを識別するため、スキーマ名とテーブル名のフィールドを参照します。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>d</>
</term>
<listitem>
<para>
<!--
        Data type name: if the error was associated with a specific data type,
        the name of the data type.  (Refer to the schema name field for the
        name of the data type's schema.)
-->
データ型名。
エラーが特定のデータ型に関連する場合、そのデータ型名。
（スキーマ名フィールドにおいて、そのデータ型のスキーマ名を参照します。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>n</>
</term>
<listitem>
<para>
<!--
        Constraint name: if the error was associated with a specific
        constraint, the name of the constraint.  Refer to fields listed above
        for the associated table or domain.  (For this purpose, indexes are
        treated as constraints, even if they weren't created with constraint
        syntax.)
-->
制約名。
エラーが特定の制約に関連する場合、その制約名。
上に列挙したフィールドにおいて、関連するテーブルまたはドメインを参照します。
（この目的のために、制約の構文のもとに作成されていない場合でも、インデックスは制約として扱われます。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>F</>
</term>
<listitem>
<para>
<!--
        File: the file name of the source-code location where the error
        was reported.
-->
ファイルです。
エラーを報告した、ソースコードのファイル名です。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>L</>
</term>
<listitem>
<para>
<!--
        Line: the line number of the source-code location where the error
        was reported.
-->
行です。
エラーを報告した、ソースコードの行番号です。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>R</>
</term>
<listitem>
<para>
<!--
        Routine: the name of the source-code routine reporting the error.
-->
ルーチンです。
エラーを報告した、ソースコードのルーチン名です。
</para>
</listitem>
</varlistentry>

</variablelist>

<note>
 <para>
<!--
  The fields for schema name, table name, column name, data type name, and
  constraint name are supplied only for a limited number of error types;
  see <xref linkend="errcodes-appendix">.  Frontends should not assume that
  the presence of any of these fields guarantees the presence of another
  field.  Core error sources observe the interrelationships noted above, but
  user-defined functions may use these fields in other ways.  In the same
  vein, clients should not assume that these fields denote contemporary
  objects in the current database.
-->
スキーマ名、テーブル名、列名、データ型名および制約名のフィールドは、限られたエラー型のためにしか提供されません。
<xref linkend="errcodes-appendix">を参照してください。
フロントエンドは、これらのフィールドの一部の存在が、他のフィールドの存在も保障すると仮定してはいけません。
上記の相互関係により主なエラーの原因を探す方法がありますが、ユーザが定義した関数は他の方法でこれらのフィールドを利用できるかもしれません。
同様の理由により、クライアントはこれらのフィールドが、現在のデータベースにおける適切なオブジェクトを示すと仮定してはいけません。
 </para>
</note>

<para>
<!--
The client is responsible for formatting displayed information to meet its
needs; in particular it should break long lines as needed.  Newline characters
appearing in the error message fields should be treated as paragraph breaks,
not line breaks.
-->
クライアントには、必要な情報を表示する際、整形する責任があります。
具体的には、必要に応じて長い行を分割しなければなりません。
エラーメッセージフィールド内にある改行文字は、改行ではなく、段落の区切りとして扱わなければなりません。
</para>

</sect1>

<sect1 id="protocol-changes">
<!--
<title>Summary of Changes since Protocol 2.0</title>
-->
<title>プロトコル2.0からの変更点の要約</title>

<para>
<!--
This section provides a quick checklist of changes, for the benefit of
developers trying to update existing client libraries to protocol 3.0.
-->
本節では、既存のクライアントライブラリをプロトコル3.0に更新しようとする開発者向けに、変更点の簡易チェックリストを示します。
</para>

<para>
<!--
The initial startup packet uses a flexible list-of-strings format
instead of a fixed format.  Notice that session default values for run-time
parameters can now be specified directly in the startup packet.  (Actually,
you could do that before using the <literal>options</> field, but given the
limited width of <literal>options</> and the lack of any way to quote
whitespace in the values, it wasn't a very safe technique.)
-->
最初の開始パケットは、固定書式ではなく、柔軟な文字列のリスト書式を使用します。
実行時パラメータのセッションのデフォルト値が直接開始パケット内に指定できるようになった点に注意してください。
（実際、以前でも<literal>options</>フィールドを使用してこれを行うことができましたが、<literal>options</>には長さに制限があること、および値内の空白文字を引用符でくくる方法がないことから、あまり安全な技法ではありませんでした。）
</para>

<para>
<!--
All messages now have a length count immediately following the message type
byte (except for startup packets, which have no type byte).  Also note that
PasswordMessage now has a type byte.
-->
すべてのメッセージが、メッセージ種類バイトの直後にバイト数を持つようになりました
（種類バイトがない開始パケットは例外です）。
また、PasswordMessageが種類バイトを持つようになったことにも注意してください。
</para>

<para>
<!--
ErrorResponse and NoticeResponse ('<literal>E</>' and '<literal>N</>')
messages now contain multiple fields, from which the client code can
assemble an error message of the desired level of verbosity.  Note that
individual fields will typically not end with a newline, whereas the single
string sent in the older protocol always did.
-->
ErrorResponseおよびNoticeResponse（'<literal>E</>'および'<literal>N</>'）メッセージが複数のフィールドを持つようになりました。
これを使用して、クライアントコードは、必要な冗長度に合わせて、エラーメッセージを組み立てることができます。
個々のフィールドが通常改行で終わらないことに注意してください。
単一の文字列を送信する古いプロトコルでは、常に改行で終わっていました。
</para>

<para>
<!--
The ReadyForQuery ('<literal>Z</>') message includes a transaction status
indicator.
-->
ReadyForQuery（'<literal>Z</>'）メッセージに、トランザクション状態指示子が含まれます。
</para>

<para>
<!--
The distinction between BinaryRow and DataRow message types is gone; the
single DataRow message type serves for returning data in all formats.
Note that the layout of DataRow has changed to make it easier to parse.
Also, the representation of binary values has changed: it is no longer
directly tied to the server's internal representation.
-->
BinaryRowとDataRowメッセージ種類間の区別がなくなりました。
1つのDataRowメッセージ種類で、すべての書式で記述されたデータを返すことができます。
DataRowのレイアウトが解析しやすいように変更されたことに注意してください。
またバイナリ値の表現も変更されました。
もはやサーバの内部表現に直接束縛されません。
</para>

<para>
<!--
There is a new <quote>extended query</> sub-protocol, which adds the frontend
message types Parse, Bind, Execute, Describe, Close, Flush, and Sync, and the
backend message types ParseComplete, BindComplete, PortalSuspended,
ParameterDescription, NoData, and CloseComplete.  Existing clients do not
have to concern themselves with this sub-protocol, but making use of it
might allow improvements in performance or functionality.
-->
新しい<quote>拡張問い合わせ</>サブプロトコルがあります。
これにより、フロントエンドメッセージ種類にParse、Execute、Describe、Close、Flush、およびSyncが、バックエンドメッセージ種類にParseComplete、BindComplete、PortalSuspended、ParameterDescription、NoData、およびCloseCompleteが追加されました。
既存のクライアントは、このサブプロトコルを意識する必要はありませんが、これを使用することで、性能や機能を向上させることができます。
</para>

<para>
<!--
<command>COPY</command> data is now encapsulated into CopyData and CopyDone messages.  There
is a well-defined way to recover from errors during <command>COPY</command>.  The special
<quote><literal>\.</></quote> last line is not needed anymore, and is not sent
during <command>COPY OUT</command>.
(It is still recognized as a terminator during <command>COPY IN</command>, but its use is
deprecated and will eventually be removed.)  Binary <command>COPY</command> is supported.
The CopyInResponse and CopyOutResponse messages include fields indicating
the number of columns and the format of each column.
-->
<command>COPY</command>データがCopyDataとCopyDoneメッセージにカプセル化されるようになりました。
<command>COPY</command>中のエラーから復旧するための十分に定義された方法があります。
特別な<quote><literal>\.</></quote>という最後の行はもはや不要で、<command>COPY OUT</command>で送信されません。
（<command>COPY IN</command>ではまだ終端として認識されます。しかし、この使用は廃止予定で、最終的には削除されます。）
バイナリ<command>COPY</command>がサポートされます。
CopyInResponseとCopyOutResponseメッセージは、列数と各列の書式を示すフィールドが含まれます。
</para>

<para>
<!--
The layout of FunctionCall and FunctionCallResponse messages has changed.
FunctionCall can now support passing NULL arguments to functions.  It also
can handle passing parameters and retrieving results in either text or
binary format.  There is no longer any reason to consider FunctionCall a
potential security hole, since it does not offer direct access to internal
server data representations.
-->
FunctionCallとFunctionCallResponseメッセージのレイアウトが変更されました。
FunctionCallは関数へのNULL引数を渡すことができるようになりました。
また、テキストとバイナリ書式のどちらでもパラメータの引き渡しと結果の取り出しを扱うことができます。
サーバの内部データ表現への直接アクセスを提供しなくなりましたので、FunctionCallを潜在的なセキュリティホールとみなす理由はもはやありません。
</para>

<para>
<!--
The backend sends ParameterStatus ('<literal>S</>') messages during connection
startup for all parameters it considers interesting to the client library.
Subsequently, a ParameterStatus message is sent whenever the active value
changes for any of these parameters.
-->
バックエンドは、接続開始時にクライアントライブラリが興味を持つとみなされるすべてのパラメータのためにParameterStatus（'<literal>S</>'）メッセージを送信します。
その後、これらのパラメータのいずれかの実際の値が変更された時は常に、ParameterStatusメッセージが送信されます。
</para>

<para>
<!--
The RowDescription ('<literal>T</>') message carries new table OID and column
number fields for each column of the described row.  It also shows the format
code for each column.
-->
RowDescription（'<literal>T</>'）メッセージは、新規に、記述する各列に対してテーブルのOIDと列番号フィールドを伝えます。
また各列の書式コードも示します。
</para>

<para>
<!--
The CursorResponse ('<literal>P</>') message is no longer generated by
the backend.
-->
CursorResponse（'<literal>P</>'）メッセージはもはやバックエンドで生成されません。
</para>

<para>
<!--
The NotificationResponse ('<literal>A</>') message has an additional string
field, which can carry a <quote>payload</> string passed
from the <command>NOTIFY</command> event sender.
-->
NotificationResponse（'<literal>A</>'）メッセージは、<command>NOTIFY</command>イベントの送信者から渡される<quote>ペイロード</>文字列を伝えることができる追加文字列フィールドを持ちます。
</para>

<para>
<!--
The EmptyQueryResponse ('<literal>I</>') message used to include an empty
string parameter; this has been removed.
-->
EmptyQueryResponse（'<literal>I</>'）メッセージは、空の文字列パラメータを含めるために使用されていました。
これは削除されました。
</para>

</sect1>

</chapter>
