<!-- doc/src/sgml/extend.sgml -->

 <chapter id="extend">
<!--
  <title>Extending <acronym>SQL</acronym></title>
-->
  <title><acronym>SQL</acronym>の拡張</title>

  <indexterm zone="extend">
<!--
   <primary>extending SQL</primary>
-->
   <primary>SQLの拡張</primary>
  </indexterm>

  <para>
<!--
   In  the  sections  that follow, we will discuss how you
   can extend the <productname>PostgreSQL</productname>
   <acronym>SQL</acronym> query language by adding:
-->
本節では以下を追加することで<productname>PostgreSQL</productname>の<acronym>SQL</acronym>問い合わせ言語をどのように拡張できるかを説明します。

   <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
<!--
      functions (starting in <xref linkend="xfunc">)
-->
関数（<xref linkend="xfunc">から）。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      aggregates (starting in <xref linkend="xaggr">)
-->
集約（<xref linkend="xaggr">から）。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      data types (starting in <xref linkend="xtypes">)
-->
データ型（<xref linkend="xtypes">から）。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      operators (starting in <xref linkend="xoper">)
-->
演算子（<xref linkend="xoper">から）。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      operator classes for indexes (starting in <xref linkend="xindex">)
-->
インデックス用演算子クラス（<xref linkend="xindex">から）。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      packages of related objects (starting in <xref linkend="extend-extensions">)
-->
      関連オブジェクトのパッケージ（<xref linkend="extend-extensions">から）。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
<!--
   <title>How Extensibility Works</title>
-->
   <title>拡張の作用法</title>

   <para>
<!--
    <productname>PostgreSQL</productname> is extensible because its operation  is
    catalog-driven.   If  you  are familiar with standard
    relational database systems, you know that  they  store  information
    about  databases,  tables,  columns,  etc., in what are
    commonly known as system catalogs.  (Some systems  call
    this  the data dictionary.)  The catalogs appear to the
    user as tables like any other, but  the  <acronym>DBMS</acronym>  stores
    its  internal  bookkeeping in them.  One key difference
    between <productname>PostgreSQL</productname> and  standard  relational database systems  is
    that <productname>PostgreSQL</productname> stores much more information in its
    catalogs: not only information about tables and  columns,
    but also information about data types, functions, access
    methods, and so on.  These tables can be  modified  by
    the  user, and since <productname>PostgreSQL</productname> bases its operation
    on these tables, this means that <productname>PostgreSQL</productname> can  be
    extended   by   users.    By  comparison,  conventional
    database systems can only be extended by changing hardcoded
    procedures in the source code or by loading modules
    specially written by the <acronym>DBMS</acronym> vendor.
-->
<productname>PostgreSQL</productname>は、自分自身の操作がカタログに定義された方法で駆動されているため拡張が可能です。
もし標準のリレーショナルデータベースシステムに慣れ親しんでいるのであれば、システムカタログとして一般に知られている中に、データベース、テーブル、列などの情報が格納されていることは知っていると思います。
（システムによってはデータディクショナリと呼ぶものもあります。）
このカタログはユーザの目には他のテーブルと同じように見えますが、<acronym>DBMS</acronym>は内部情報をそこに格納しているのです。
<productname>PostgreSQL</productname>と標準的なリレーショナルデータベースシステムの重要な違いは、<productname>PostgreSQL</productname>はカタログにより多くの情報を格納するということです。
テーブルと列に関する情報だけではなく、データ型、関数、アクセスメソッドなどの情報も格納されています。
これらのテーブルはユーザが変更できます。
そして、<productname>PostgreSQL</productname>は操作をこれらのテーブルに基づいて行うので、<productname>PostgreSQL</productname>はユーザによって拡張することができるのです。
これに対して、一般のデータベースシステムでは、ソースコード内にハードコーディングされたプロシージャを変えるか、<acronym>DBMS</acronym>ベンダによって特別に書かれたモジュールをロードしなければ拡張することができません。
   </para>

   <para>
<!--
    The <productname>PostgreSQL</productname> server can moreover
    incorporate user-written code into itself through dynamic loading.
    That is, the user can specify an object code file (e.g., a shared
    library) that implements a new type or function, and
    <productname>PostgreSQL</productname> will load it as required.
    Code written in <acronym>SQL</acronym> is even more trivial to add
    to the server.  This ability to modify its operation <quote>on the
    fly</quote> makes <productname>PostgreSQL</productname> uniquely
    suited for rapid prototyping of new applications and storage
    structures.
-->
さらに<productname>PostgreSQL</productname>サーバは動的ローディングによってユーザの作成したコードを取り入れることができます。
つまり、ユーザが新しい型か関数を実装するオブジェクトコードファイル（例えば共有ライブラリ）を指定することができ、<productname>PostgreSQL</productname>は要求された時にロードします。
<acronym>SQL</acronym>で作成されたコードをサーバに追加するのはさらに簡単です。
このように演算を<quote>その場で</quote>変えることができるため、<productname>PostgreSQL</productname>は新しいアプリケーションや格納構造をラピッドプロトタイプする場合に適しています。
   </para>
  </sect1>

  <sect1 id="extend-type-system">
<!--
   <title>The <productname>PostgreSQL</productname> Type System</title>
-->
   <title><productname>PostgreSQL</productname>の型システム</title>

   <indexterm zone="extend-type-system">
<!--
    <primary>base type</primary>
-->
    <primary>基本型</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
<!--
    <primary>data type</primary>
    <secondary>base</secondary>
-->
    <primary>データ型</primary>
    <secondary>基本</secondary>
   </indexterm>

   <indexterm zone="extend-type-system">
<!--
    <primary>composite type</primary>
-->
    <primary>複合型</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
<!--
    <primary>data type</primary>
    <secondary>composite</secondary>
-->
    <primary>データ型</primary>
    <secondary>複合</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> data types are divided into base
    types, composite types, domains, and pseudo-types.
-->
<productname>PostgreSQL</productname>のデータ型は、基本型、複合型、ドメイン、疑似型に分類されます。
   </para>

   <sect2>
<!--
    <title>Base Types</title>
-->
    <title>基本型</title>

    <para>
<!--
     Base types are those, like <type>int4</type>, that are
     implemented below the level of the <acronym>SQL</> language
     (typically in a low-level language such as C).  They generally
     correspond to what are often known as abstract data types.
     <productname>PostgreSQL</productname> can only operate on such
     types through functions provided by the user and only understands
     the behavior of such types to the extent that the user describes
     them.  Base types are further subdivided into scalar and array
     types.  For each scalar type, a corresponding array type is
     automatically created that can hold variable-size arrays of that
     scalar type.
-->
基本型は<type>int4</type>のように、<acronym>SQL</>言語レベル以下で実装されたものです
（通常はCのような低レベル言語で作成されます）。
一般的にこれらは抽象データ型とも呼ばれるものに対応します。
<productname>PostgreSQL</productname>は、ユーザによって提供された関数を通して、こうした型に対する操作のみが可能です。
そして、こうした型の動作のみをユーザが記述する範囲まで理解することができます。
さらに基本型は、スカラと配列型に分類されます。
各スカラ型に対応する配列型は自動的に作成され、そこにはそのスカラ型の可変長の配列を保持できます。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Composite Types</title>
-->
    <title>複合型</title>

    <para>
<!--
     Composite types, or row types, are created whenever the user
     creates a table. It is also possible to use <xref
     linkend="sql-createtype"> to
     define a <quote>stand-alone</> composite type with no associated
     table.  A composite type is simply a list of types with
     associated field names.  A value of a composite type is a row or
     record of field values.  The user can access the component fields
     from <acronym>SQL</> queries. Refer to <xref linkend="rowtypes">
     for more information on composite types.
-->
ユーザがテーブルを作成すると、複合型、もしくは行型が作成されます。
関連するテーブルを持たない<quote>スタンドアロン</>の複合型を<xref linkend="sql-createtype">を使用して定義することもできます。
複合型は関連したフィールド名を持つ基本型の単なるリストです。
複合型の値は行もしくはフィールド値のレコードです。
ユーザは<acronym>SQL</>問い合わせによってその構成フィールドにアクセスすることができます。
複合型のより詳細については<xref linkend="rowtypes">を参照してください。
    </para>
   </sect2>

   <sect2 id="extend-type-system-domains">
<!--
    <title>Domains</title>
-->
    <title>ドメイン</title>

    <para>
<!--
     A domain is based on a particular base type and for many purposes
     is interchangeable with its base type.  However, a domain can
     have constraints that restrict its valid values to a subset of
     what the underlying base type would allow.
-->
ドメインは、特定の基本型に基づいたもので、多くの目的では、その基本型と交換可能です。
しかし、ドメインは背後にある基本型で許可される範囲内で値の有効範囲を制限する制約を持つことができます。
    </para>

    <para>
<!--
     Domains can be created using the <acronym>SQL</> command
     <xref linkend="sql-createdomain">.
     Their creation and use is not discussed in this chapter.
-->
ドメインは<xref linkend="sql-createdomain"> <acronym>SQL</>コマンドを使用して作成可能です。
ドメインの作成と使用については本章では説明しません。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Pseudo-Types</title>
-->
    <title>疑似型</title>

    <para>
<!--
     There are a few <quote>pseudo-types</> for special purposes.
     Pseudo-types cannot appear as columns of tables or attributes of
     composite types, but they can be used to declare the argument and
     result types of functions.  This provides a mechanism within the
     type system to identify special classes of functions.  <xref
     linkend="datatype-pseudotypes-table"> lists the existing
     pseudo-types.
-->
特殊な目的用に数個の<quote>疑似型</>があります。
疑似型はテーブルの列や複合型の属性として現れることはありません。
しかし、関数の引数や結果型を宣言する際に使用することができます。
これは、型システム内で特殊な関数クラスを識別するための機構を提供します。
<xref linkend="datatype-pseudotypes-table">に既存の疑似型を列挙します。
    </para>
   </sect2>

   <sect2 id="extend-types-polymorphic">
<!--
    <title>Polymorphic Types</title>
-->
    <title>多様型</title>

   <indexterm zone="extend-types-polymorphic">
<!--
    <primary>polymorphic type</primary>
-->
    <primary>多様型</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
<!--
    <primary>polymorphic function</primary>
-->
    <primary>多様関数</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
<!--
    <primary>type</primary>
    <secondary>polymorphic</secondary>
-->
    <primary>型</primary>
    <secondary>多様</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
<!--
    <primary>function</primary>
    <secondary>polymorphic</secondary>
-->
    <primary>関数</primary>
    <secondary>多様</secondary>
   </indexterm>

    <para>
<!--
     Five pseudo-types of special interest are <type>anyelement</>,
     <type>anyarray</>, <type>anynonarray</>, <type>anyenum</>,
     and <type>anyrange</>,
     which are collectively called <firstterm>polymorphic types</>.
     Any function declared using these types is said to be
     a <firstterm>polymorphic function</>.  A polymorphic function can
     operate on many different data types, with the specific data type(s)
     being determined by the data types actually passed to it in a particular
     call.
-->
特殊な用途を持つ疑似型には、<type>anyelement</>と<type>anyarray</>、<type>anynonarray</>、<type>anyenum</>および<type>anyrange</>の５つがあります。
これらはまとめて<firstterm>多様型</>と呼ばれます。
これらの型を使用すると宣言された関数は全て、<firstterm>多様関数</>と呼ばれます。
多様関数は多くの異なるデータ型を操作することができます。
データ型の指定は、特定の呼び出しに実際に渡されるデータ型によって決定されます。
    </para>

    <para>
<!--
     Polymorphic arguments and results are tied to each other and are resolved
     to a specific data type when a query calling a polymorphic function is
     parsed.  Each position (either argument or return value) declared as
     <type>anyelement</type> is allowed to have any specific actual
     data type, but in any given call they must all be the
     <emphasis>same</emphasis> actual type. Each
     position declared as <type>anyarray</type> can have any array data type,
     but similarly they must all be the same type.  And similarly,
     positions declared as <type>anyrange</type> must all be the same range
     type.  Furthermore, if there are
     positions declared <type>anyarray</type> and others declared
     <type>anyelement</type>, the actual array type in the
     <type>anyarray</type> positions must be an array whose elements are
     the same type appearing in the <type>anyelement</type> positions.
     Similarly, if there are positions declared <type>anyrange</type>
     and others declared <type>anyelement</type>, the actual range type in
     the <type>anyrange</type> positions must be a range whose subtype is
     the same type appearing in the <type>anyelement</type> positions.
     <type>anynonarray</> is treated exactly the same as <type>anyelement</>,
     but adds the additional constraint that the actual type must not be
     an array type.
     <type>anyenum</> is treated exactly the same as <type>anyelement</>,
     but adds the additional constraint that the actual type must
     be an enum type.
-->
多様引数と結果は互いに結び付いており、多様関数を呼び出す問い合わせが解析される時に特定のデータ型が決定されます。
<type>anyelement</type>として宣言された位置（引数もしくは戻り値）にはそれぞれ、任意の実データ型を指定することができますが、1つの呼び出しでは、これらはすべて<emphasis>同一の</emphasis>実データ型でなければなりません。
<type>anyarray</type>として宣言された位置には、任意の配列データ型を持つことができます。
しかし、同様にこれらはすべて同じデータ型でなければなりません。
また同様に<type>anyrange</type>として宣言された位置はすべて同じ範囲型でなければなりません。
さらに<type>anyarray</type>と宣言された位置と<type>anyelement</type>と宣言された位置の両方がある場合、<type>anyarray</type>の位置の実際の配列型は、その要素の型が<type>anyelement</type>位置に現れる型と同じでなければなりません。
同様に<type>anyrange</type>と宣言された位置と<type>anyelement</type>と宣言された位置の両方がある場合、<type>anyrange</type>の位置の実際の範囲型は、その範囲の派生元型が<type>anyelement</type>位置に現れる型と同じでなければなりません。
<type>anynonarray</>は、実際の型が配列型であってはならないという制限が加わっている点を除き、<type>anyelement</>とまったく同様に扱われます。
<type>anyenum</>は、実際の型が列挙型でなければならないという制約が加わっている点を除き、<type>anyelement</>とまったく同様に扱われます。
    </para>

    <para>
<!--
     Thus, when more than one argument position is declared with a polymorphic
     type, the net effect is that only certain combinations of actual argument
     types are allowed.  For example, a function declared as
     <literal>equal(anyelement, anyelement)</> will take any two input values,
     so long as they are of the same data type.
-->
このように、2つ以上の引数位置が多様型と宣言されると、全体の効果として、実引数型の特定の組み合わせのみが許されるようになります。
例えば、<literal>equal(anyelement, anyelement)</>と宣言された関数は、2つの引数が同じデータ型である限り、任意の入力値を2つ取ることになります。
    </para>

    <para>
<!--
     When the return value of a function is declared as a polymorphic type,
     there must be at least one argument position that is also polymorphic,
     and the actual data type supplied as the argument determines the actual
     result type for that call.  For example, if there were not already
     an array subscripting mechanism, one could define a function that
     implements subscripting as <literal>subscript(anyarray, integer)
     returns anyelement</>.  This declaration constrains the actual first
     argument to be an array type, and allows the parser to infer the correct
     result type from the actual first argument's type.  Another example
     is that a function declared as <literal>f(anyarray) returns anyenum</>
     will only accept arrays of enum types.
-->
関数の戻り値を多様型として宣言する時、少なくとも1つの引数位置も多様でなければなりません。
そして引数として与えられる実データ型がその呼び出しの実結果型を決定します。
例えば、配列添字機構がなかったとすると、<literal>subscript(anyarray, integer) returns anyelement</>として添字機構を実装する関数を定義できます。
この宣言には、最初の実引数は配列型になり、パーサはこの最初の実引数の型より正しい結果型を推論することができます。
他にも例えば、<literal>f(anyarray) returns anyenum</>と宣言された関数は列挙型の配列のみを受け付けます。
    </para>

    <para>
<!--
     Note that <type>anynonarray</> and <type>anyenum</> do not represent
     separate type variables; they are the same type as
     <type>anyelement</type>, just with an additional constraint.  For
     example, declaring a function as <literal>f(anyelement, anyenum)</>
     is equivalent to declaring it as <literal>f(anyenum, anyenum)</>:
     both actual arguments have to be the same enum type.
-->
<type>anynonarray</>型と<type>anyenum</>型が、別個の型変数を表していないことに注意してください。
これは<type>anyelement</type>と同じ型で、追加の制約が付いているだけです。
例えば、<literal>f(anyelement, anyenum)</>として関数を宣言することは、<literal>f(anyenum, anyenum)</>と宣言することと同一です。
両方の実引数は同じ列挙型でなければなりません。
    </para>

    <para>
<!--
     A variadic function (one taking a variable number of arguments, as in
     <xref linkend="xfunc-sql-variadic-functions">) can be
     polymorphic: this is accomplished by declaring its last parameter as
     <literal>VARIADIC</> <type>anyarray</>.  For purposes of argument
     matching and determining the actual result type, such a function behaves
     the same as if you had written the appropriate number of
     <type>anynonarray</> parameters.
-->
可変長引数の関数（<xref linkend="xfunc-sql-variadic-functions">で説明する可変個の引数を取る関数）を多様とすることができます。
最後のパラメータを<literal>VARIADIC</> <type>anyarray</>と宣言することで実現されます。
引数を一致させ、実際の結果型を決めるために、こうした関数は<type>anynonarray</>パラメータを適切な個数記述した場合と同様に動作します
    </para>
   </sect2>
  </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;

  <sect1 id="extend-extensions">
<!--
   <title>Packaging Related Objects into an Extension</title>
-->
   <title>関連するオブジェクトを拡張としてパッケージ化</title>

   <indexterm zone="extend-extensions">
<!--
    <primary>extension</primary>
-->
    <primary>拡張</primary>
   </indexterm>

   <para>
<!--
    A useful extension to <productname>PostgreSQL</> typically includes
    multiple SQL objects; for example, a new data type will require new
    functions, new operators, and probably new index operator classes.
    It is helpful to collect all these objects into a single package
    to simplify database management.  <productname>PostgreSQL</> calls
    such a package an <firstterm>extension</>.  To define an extension,
    you need at least a <firstterm>script file</> that contains the
    <acronym>SQL</> commands to create the extension's objects, and a
    <firstterm>control file</> that specifies a few basic properties
    of the extension itself.  If the extension includes C code, there
    will typically also be a shared library file into which the C code
    has been built.  Once you have these files, a simple
    <xref linkend="sql-createextension"> command loads the objects into
    your database.
-->
<productname>PostgreSQL</>への有用な拡張は通常、複数のSQLオブジェクトを含んでいます。
例えば、新しいデータ型は新しい関数、新しい演算子、おそらく新しいインデックス演算子クラスを必要とします。
これらのオブジェクトをすべて単一のパッケージとしてまとめることは、データベース管理を単純化するために役に立ちます。
<productname>PostgreSQL</>ではこうしたパッケージを<firstterm>拡張</>とよびます。
拡張を定義するためには、少なくとも、拡張のオブジェクトを作成するための<acronym>SQL</>コマンドを含む<firstterm>スクリプトファイル</>、拡張自身の数個の基本属性を指定する<firstterm>制御ファイル</>が必要です。
また拡張がCコードを含む場合、通常Cコードで構築された共有ライブラリが存在します。
これらのファイルがあれば、単純な<xref linkend="sql-createextension">コマンドがそのオブジェクトをデータベース内に読み込みます。
   </para>

   <para>
<!--
    The main advantage of using an extension, rather than just running the
    <acronym>SQL</> script to load a bunch of <quote>loose</> objects
    into your database, is that <productname>PostgreSQL</> will then
    understand that the objects of the extension go together.  You can
    drop all the objects with a single <xref linkend="sql-dropextension">
    command (no need to maintain a separate <quote>uninstall</> script).
    Even more useful, <application>pg_dump</> knows that it should not
    dump the individual member objects of the extension &mdash; it will
    just include a <command>CREATE EXTENSION</> command in dumps, instead.
    This vastly simplifies migration to a new version of the extension
    that might contain more or different objects than the old version.
    Note however that you must have the extension's control, script, and
    other files available when loading such a dump into a new database.
-->
拡張を使用する主な利点は、<acronym>SQL</>スクリプトを実行するだけでデータベースに<quote>粗な</>なオブジェクトの群をロードできることではなく、<productname>PostgreSQL</>が拡張のオブジェクトをまとまったものと理解できることです。
単一の<xref linkend="sql-dropextension">コマンドでオブジェクトすべてを削除することができます（個々の<quote>アンインストール</>スクリプトを保守する必要はありません）。
もっと有用なことは、<application>pg_dump</>が拡張の個々のメンバオブジェクトを削除してはならないことを把握していることです。
代わりにダンプ内には<command>CREATE EXTENSION</>コマンドだけが含まれます。
これは、古いバージョンよりも多くのまたは異なるオブジェクトを含む可能性がある、拡張の新しいバージョンへの移行を大きく単純化します。
しかし、こうしたダンプを新しいデータベースにロードする際には、拡張の制御ファイル、スクリプトファイル、その他のファイルが利用できるようにしておく必要があります。
   </para>

   <para>
<!--
    <productname>PostgreSQL</> will not let you drop an individual object
    contained in an extension, except by dropping the whole extension.
    Also, while you can change the definition of an extension member object
    (for example, via <command>CREATE OR REPLACE FUNCTION</command> for a
    function), bear in mind that the modified definition will not be dumped
    by <application>pg_dump</>.  Such a change is usually only sensible if
    you concurrently make the same change in the extension's script file.
    (But there are special provisions for tables containing configuration
    data; see below.)
-->
<productname>PostgreSQL</>はユーザに、拡張全体を削除させる以外に、拡張内に含まれる個々のオブジェクトを削除させません。
また、拡張のメンバオブジェクトの定義を変更する（例えば関数では<command>CREATE OR REPLACE FUNCTION</command>を介して変更する）ことはできますが、変更した定義は<application>pg_dump</>によりダンプされないことに留意してください。
こうした変更は通常、同時に拡張のスクリプトファイルにも同じ変更を行った場合のみ認識することができます。
（しかし後述するように設定データを持つテーブルに対しては特殊な準備があります。）
   </para>

   <para>
<!--
    The extension mechanism also has provisions for packaging modification
    scripts that adjust the definitions of the SQL objects contained in an
    extension.  For example, if version 1.1 of an extension adds one function
    and changes the body of another function compared to 1.0, the extension
    author can provide an <firstterm>update script</> that makes just those
    two changes.  The <command>ALTER EXTENSION UPDATE</> command can then
    be used to apply these changes and track which version of the extension
    is actually installed in a given database.
-->
また拡張機構は、拡張に含まれるSQLオブジェクトの定義を調整するパッケージ調整スクリプトを準備しています。
例えば、拡張のバージョン1.1でバージョン1.0と比べて１つの関数を追加し、他の関数本体を変更する場合、拡張の作成者はこれらの２つの変更のみを行う<firstterm>更新スクリプト</>を提供することができます。
そして<command>ALTER EXTENSION UPDATE</>コマンドを使用して、これらの変更を適用し、指定されたデータベース内に実際にインストールされた拡張のバージョンが何かを記録します。
   </para>

   <para>
<!--
    The kinds of SQL objects that can be members of an extension are shown in
    the description of <xref linkend="sql-alterextension">.  Notably, objects
    that are database-cluster-wide, such as databases, roles, and tablespaces,
    cannot be extension members since an extension is only known within one
    database.  (Although an extension script is not prohibited from creating
    such objects, if it does so they will not be tracked as part of the
    extension.)  Also notice that while a table can be a member of an
    extension, its subsidiary objects such as indexes are not directly
    considered members of the extension.
    Another important point is that schemas can belong to extensions, but not
    vice versa: an extension as such has an unqualified name and does not
    exist <quote>within</> any schema.  The extension's member objects,
    however, will belong to schemas whenever appropriate for their object
    types.  It may or may not be appropriate for an extension to own the
    schema(s) its member objects are within.
-->
拡張のメンバとなり得るSQLオブジェクトの種類を<xref linkend="sql-alterextension">で説明します。
拡張は１つのデータベースの中でのみ認識されますので、データベース、ロール、テーブル空間などデータベースクラスタ全体のオブジェクトは拡張のメンバにすることができないことに注意してください。
（拡張のスクリプトでこうしたオブジェクトを生成することは禁止されていませんが、作成したとしても、拡張の一部として記録されません。）
また、テーブルは拡張のメンバになることができますが、インデックスなどそれに付随するオブジェクトは拡張の直接的なメンバとはみなされません。
もう一つの重要な点は、スキーマは拡張に属すことがありますがその逆はないということです。
拡張は非修飾名でいかなるスキーマの<quote>の中に</>も存在しません。
しかし、拡張のメンバオブジェクトはオブジェクトの型が適切であればスキーマに属します。
拡張が自身のメンバオブジェクトが属するスキーマを所有することは適切かも知れませんし、そうでないかも知れません。
   </para>

   <sect2>
<!--
    <title>Extension Files</title>
-->
    <title>拡張のファイル</title>

   <indexterm>
<!--
    <primary>control file</primary>
-->
    <primary>制御ファイル</primary>
   </indexterm>

    <para>
<!--
     The <xref linkend="sql-createextension"> command relies on a control
     file for each extension, which must be named the same as the extension
     with a suffix of <literal>.control</>, and must be placed in the
     installation's <literal>SHAREDIR/extension</literal> directory.  There
     must also be at least one <acronym>SQL</> script file, which follows the
     naming pattern
     <literal><replaceable>extension</>&#045;-<replaceable>version</>.sql</literal>
     (for example, <literal>foo&#045;-1.0.sql</> for version <literal>1.0</> of
     extension <literal>foo</>).  By default, the script file(s) are also
     placed in the <literal>SHAREDIR/extension</literal> directory; but the
     control file can specify a different directory for the script file(s).
-->
<xref linkend="sql-createextension">コマンドは各拡張に関して、拡張と同じ名前に<literal>.control</>という拡張子を持つファイル名である必要がある、制御ファイルに依存します。
また、このファイルはインストレーションの<literal>SHAREDIR/extension</literal>ディレクトリ内に存在しなければなりません。
また少なくとも１つの、<literal><replaceable>extension</>--<replaceable>version</>.sql</literal>という命名規約（例えば<literal>foo</>拡張のバージョン<literal>1.0</>では<literal>foo--1.0.sql</>）に従った<acronym>SQL</>スクリプトファイルが存在しなければなりません。
デフォルトでは、このスクリプトファイルも<literal>SHAREDIR/extension</literal>ディレクトリに格納されますが、制御ファイルでスクリプトファイルを別のディレクトリに指定することができます。

    </para>

    <para>
<!--
     The file format for an extension control file is the same as for the
     <filename>postgresql.conf</> file, namely a list of
     <replaceable>parameter_name</> <literal>=</> <replaceable>value</>
     assignments, one per line.  Blank lines and comments introduced by
     <literal>#</> are allowed.  Be sure to quote any value that is not
     a single word or number.
-->
拡張の制御ファイルのファイル書式は<filename>postgresql.conf</>ファイルと同じです。
すなわち、<replaceable>parameter_name</> <literal>=</> <replaceable>value</>という代入を１行当たり１つ記述します。
空行および<literal>#</>から始まるコメントが許されます。
単一の単語または数字ではない値にはすべて引用符で確実にくくってください。
    </para>

    <para>
<!--
     A control file can set the following parameters:
-->
制御ファイルは以下のパラメータを設定することができます。
    </para>

    <variablelist>
     <varlistentry>
      <term><varname>directory</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        The directory containing the extension's <acronym>SQL</> script
        file(s).  Unless an absolute path is given, the name is relative to
        the installation's <literal>SHAREDIR</literal> directory.  The
        default behavior is equivalent to specifying
        <literal>directory = 'extension'</>.
-->
拡張の<acronym>SQL</>スクリプトファイルを含むディレクトリです。
絶対パスで指定されていない限り、この名前はインストレーションの<literal>SHAREDIR</literal>ディレクトリからの相対パスになります。
デフォルトの動作は<literal>directory = 'extension'</>と指定した場合と同じです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>default_version</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        The default version of the extension (the one that will be installed
        if no version is specified in <command>CREATE EXTENSION</>).  Although
        this can be omitted, that will result in <command>CREATE EXTENSION</>
        failing if no <literal>VERSION</> option appears, so you generally
        don't want to do that.
-->
拡張のデフォルトのバージョン（<command>CREATE EXTENSION</>でバージョン指定がない場合にインストールされるバージョン）です。
これは省略することができますが、その場合<literal>VERSION</>オプションがない<command>CREATE EXTENSION</>は失敗します。
ですので通常省略しようとは思わないでしょう。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>comment</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        A comment (any string) about the extension.  Alternatively,
        the comment can be set by means of the <xref linkend="sql-comment">
        command in the script file.
-->
拡張に関するコメント（任意の文字列）です。
この他の方法として、スクリプトファイル内で<xref linkend="sql-comment">コマンドを使用してコメントを設定することができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>encoding</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        The character set encoding used by the script file(s).  This should
        be specified if the script files contain any non-ASCII characters.
        Otherwise the files will be assumed to be in the database encoding.
-->
スクリプトファイルで使用される文字セット符号化方式です。
スクリプトファイルに何らかの非ASCII文字が含まれる場合に指定しなければなりません。
指定がなければ、ファイルはデータベース符号化方式であると仮定されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        The value of this parameter will be substituted for each occurrence
        of <literal>MODULE_PATHNAME</> in the script file(s).  If it is not
        set, no substitution is made.  Typically, this is set to
        <literal>$libdir/<replaceable>shared_library_name</></literal> and
        then <literal>MODULE_PATHNAME</> is used in <command>CREATE
        FUNCTION</> commands for C-language functions, so that the script
        files do not need to hard-wire the name of the shared library.
-->
このパラメータの値でスクリプトファイル内の<literal>MODULE_PATHNAME</>の出現箇所が置換されます。
設定されていない場合は置換は行われません。
通常これは、スクリプトファイル内で共有ライブラリの名前を直接書き込む必要がなくなるように<literal>$libdir/<replaceable>shared_library_name</></literal>に設定され、C言語関数では<command>CREATE FUNCTION</>コマンド中で<literal>MODULE_PATHNAME</>を使用します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>requires</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        A list of names of extensions that this extension depends on,
        for example <literal>requires = 'foo, bar'</literal>.  Those
        extensions must be installed before this one can be installed.
-->
拡張が依存する拡張の名前のリストです。
例えば<literal>requires = 'foo, bar'</literal>です。
対象の拡張がインストールできるようになる前に、これらの拡張がインストールされていなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
<!--
        If this parameter is <literal>true</> (which is the default),
        only superusers can create the extension or update it to a new
        version.  If it is set to <literal>false</>, just the privileges
        required to execute the commands in the installation or update script
        are required.
-->
このパラメータが<literal>true</>（デフォルト）の場合、スーパーユーザのみが拡張を作成または新しいバージョンに更新することができます。
<literal>false</>に設定されている場合は、インストレーション内でコマンドを実行するまたはスクリプトを更新するために必要な権限のみが必要とされます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
<!--
        An extension is <firstterm>relocatable</> if it is possible to move
        its contained objects into a different schema after initial creation
        of the extension.  The default is <literal>false</>, i.e. the
        extension is not relocatable.
        See below for more information.
-->
拡張を最初に作成した後に拡張により含まれるオブジェクトを別のスキーマに移動することができる場合、拡張は<firstterm>再配置可能</>です。
デフォルトは<literal>false</>、つまり、拡張は再配置可能ではありません。
詳しくは後で説明します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>schema</varname> (<type>string</type>)</term>
      <listitem>
       <para>
<!--
        This parameter can only be set for non-relocatable extensions.
        It forces the extension to be loaded into exactly the named schema
        and not any other.  See below for more information.
-->
このパラメータは再配置可能ではない拡張に対してのみ設定することができます。
拡張が指名したスキーマのみにロードされ、他にはロードされないことを強制します。
詳しくは後で説明します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
<!--
     In addition to the primary control file
     <literal><replaceable>extension</>.control</literal>,
     an extension can have secondary control files named in the style
     <literal><replaceable>extension</>&#045;-<replaceable>version</>.control</literal>.
     If supplied, these must be located in the script file directory.
     Secondary control files follow the same format as the primary control
     file.  Any parameters set in a secondary control file override the
     primary control file when installing or updating to that version of
     the extension.  However, the parameters <varname>directory</> and
     <varname>default_version</> cannot be set in a secondary control file.
-->
主制御ファイル<literal><replaceable>extension</>.control</literal>に加え、拡張は<literal><replaceable>extension</>--<replaceable>version</>.control</literal>という形の名前の副制御ファイルを持つことができます。
これらを提供する場合は、スクリプトファイルディレクトリに格納しなければなりません。
副制御ファイルは主制御ファイルと同じ書式に従います。
拡張の対応するバージョンをインストールまたは更新する時、副制御ファイル内で設定されるパラメータはいずれも、主制御ファイルを上書きします。
しかし<varname>directory</>および<varname>default_version</>パラメータは副制御ファイルで設定することはできません。
    </para>

    <para>
<!--
     An extension's <acronym>SQL</> script files can contain any SQL commands,
     except for transaction control commands (<command>BEGIN</>,
     <command>COMMIT</>, etc) and commands that cannot be executed inside a
     transaction block (such as <command>VACUUM</>).  This is because the
     script files are implicitly executed within a transaction block.
-->
拡張の<acronym>SQL</>スクリプトファイルにはトランザクション制御コマンド（<command>BEGIN</>、<command>COMMIT</>など）およびトランザクションブロックの内側で実行することができないコマンド（<command>VACUUM</>など）を除く任意のSQLコマンドを含めることができます。
スクリプトファイルが暗黙的にトランザクションブロック内で実行されるためです。
    </para>

    <para>
<!--
     An extension's <acronym>SQL</> script files can also contain lines
     beginning with <literal>\echo</>, which will be ignored (treated as
     comments) by the extension mechanism.  This provision is commonly used
     to throw an error if the script file is fed to <application>psql</>
     rather than being loaded via <command>CREATE EXTENSION</> (see example
     script below).  Without that, users might accidentally load the
     extension's contents as <quote>loose</> objects rather than as an
     extension, a state of affairs that's a bit tedious to recover from.
-->
拡張の<acronym>SQL</>スクリプトファイルには、<literal>\echo</>から始まる行を含めることができます。
この行は拡張の機構では無視されます（コメントとして扱われます）。
これは、このスクリプトが<command>CREATE EXTENSION</>（後述のスクリプト例を参照）ではなく<application>psql</>に渡された場合にエラーを発生するために一般的に使用するために用意されたものです。
これがないと、ユーザは間違って拡張としてではなく、<quote>まとまっていない</>オブジェクトとして拡張の内容をロードしてしまい、復旧が多少困難な状態になる可能性があります。
    </para>

    <para>
<!--
     While the script files can contain any characters allowed by the specified
     encoding, control files should contain only plain ASCII, because there
     is no way for <productname>PostgreSQL</> to know what encoding a
     control file is in.  In practice this is only an issue if you want to
     use non-ASCII characters in the extension's comment.  Recommended
     practice in that case is to not use the control file <varname>comment</>
     parameter, but instead use <command>COMMENT ON EXTENSION</>
     within a script file to set the comment.
-->
スクリプトファイルは指定した符号化方式で認められる任意の文字を含めることができますが、<productname>PostgreSQL</>が制御ファイルの符号化方式が何かを把握する方法がありませんので、制御ファイルにはASCII文字のみを含めなければなりません。
実際には、拡張のコメントに非ASCII文字を含めたい場合にのみ、これが問題になります。
このような場合には、制御ファイルの<varname>comment</>を使用せず、代わりにコメントを設定するためにスクリプトファイル内で<command>COMMENT ON EXTENSION</>を使用することを勧めます。
    </para>

   </sect2>

   <sect2>
<!--
    <title>Extension Relocatability</title>
-->
    <title>拡張の再配置性</title>

    <para>
<!--
     Users often wish to load the objects contained in an extension into a
     different schema than the extension's author had in mind.  There are
     three supported levels of relocatability:
-->
ユーザは拡張に含まれるオブジェクトを拡張の作成者が考えていたスキーマとは別のスキーマにロードしたいとよく考えます。
再配置性に関して３つのレベルがサポートされます。
    </para>

    <itemizedlist>
     <listitem>
      <para>
<!--
       A fully relocatable extension can be moved into another schema
       at any time, even after it's been loaded into a database.
       This is done with the <command>ALTER EXTENSION SET SCHEMA</>
       command, which automatically renames all the member objects into
       the new schema.  Normally, this is only possible if the extension
       contains no internal assumptions about what schema any of its
       objects are in.  Also, the extension's objects must all be in one
       schema to begin with (ignoring objects that do not belong to any
       schema, such as procedural languages).  Mark a fully relocatable
       extension by setting <literal>relocatable = true</> in its control
       file.
-->
完全な再配置可能な拡張は、いつでも、データベースにロードされた後であっても、他のスキーマに移動させることができます。
これは、自動的にすべてのメンバオブジェクトを新しいスキーマに名前を変更する、<command>ALTER EXTENSION SET SCHEMA</>を用いて行います。
通常これは、拡張がオブジェクトが含まれるスキーマが何かに関して内部的な仮定を持たない場合のみ可能です。
また、拡張のオブジェクト（手続き言語など何らかのスキーマに属さないオブジェクトは無視して）はすべて最初に１つのスキーマ内に存在しなければなりません。
制御ファイル内で<literal>relocatable = true</>と設定することで、完全な再配置可能と印付けます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       An extension might be relocatable during installation but not
       afterwards.  This is typically the case if the extension's script
       file needs to reference the target schema explicitly, for example
       in setting <literal>search_path</> properties for SQL functions.
       For such an extension, set <literal>relocatable = false</> in its
       control file, and use <literal>@extschema@</> to refer to the target
       schema in the script file.  All occurrences of this string will be
       replaced by the actual target schema's name before the script is
       executed.  The user can set the target schema using the
       <literal>SCHEMA</> option of <command>CREATE EXTENSION</>.
-->
拡張はインストール処理の間再配置可能ですが、その後再配置することはできません。
通常これは、拡張のスクリプトファイルが、SQL関数用の<literal>search_path</>属性の設定など、対象のスキーマを明示的に参照する必要がある場合です。
こうした拡張では、制御ファイルで<literal>relocatable = false</>と設定し、スクリプトファイル内で対象のスキーマを参照するために<literal>@extschema@</>を設定してください。
この文字列の出現箇所はすべて、スクリプトが実行される前に、実際の対象のスキーマ名に置換されます。
ユーザは<command>CREATE EXTENSION</>の<literal>SCHEMA</>オプションを使用して対象のスキーマを設定することができます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If the extension does not support relocation at all, set
       <literal>relocatable = false</> in its control file, and also set
       <literal>schema</> to the name of the intended target schema.  This
       will prevent use of the <literal>SCHEMA</> option of <command>CREATE
       EXTENSION</>, unless it specifies the same schema named in the control
       file.  This choice is typically necessary if the extension contains
       internal assumptions about schema names that can't be replaced by
       uses of <literal>@extschema@</>.  The <literal>@extschema@</>
       substitution mechanism is available in this case too, although it is
       of limited use since the schema name is determined by the control file.
-->
拡張が再配置をまったくサポートしない場合、制御ファイルで<literal>relocatable = false</>を設定し、かつ、<literal>schema</>を意図している対象スキーマの名前に設定してください。
これは、制御ファイル内で指定されたスキーマと同じ名前が指定されていない限り、<command>CREATE EXTENSION</>の<literal>SCHEMA</>オプションの指定を阻止します。
この選択は通常、拡張が<literal>@extschema@</>を使用して置き換えることができないスキーマ名について内部的な仮定を持つ場合に必要です。
<literal>@extschema@</>置換機構はこの場合でも使用することができますが、スキーマ名が制御ファイルによって決定されますので、用途は限定されます。
      </para>
     </listitem>
    </itemizedlist>

    <para>
<!--
     In all cases, the script file will be executed with
     <xref linkend="guc-search-path"> initially set to point to the target
     schema; that is, <command>CREATE EXTENSION</> does the equivalent of
     this:
-->
すべての場合において、スクリプトファイルは対象のスキーマを指し示すようにあらかじめ設定した<xref linkend="guc-search-path">を用いて実行されます。
つまり<command>CREATE EXTENSION</>は以下と同じことを行います。
<programlisting>
SET LOCAL search_path TO @extschema@;
</programlisting>
<!--
     This allows the objects created by the script file to go into the target
     schema.  The script file can change <varname>search_path</> if it wishes,
     but that is generally undesirable.  <varname>search_path</> is restored
     to its previous setting upon completion of <command>CREATE EXTENSION</>.
-->
これによりスクリプトファイルで作成されるオブジェクトを対象のスキーマ内に格納することができます。
スクリプトファイルは要望に応じて<varname>search_path</>を変更することができますが、一般的には望まれません。
<command>CREATE EXTENSION</>の実行後、<varname>search_path</>は以前の設定に戻されます。
    </para>

    <para>
<!--
     The target schema is determined by the <varname>schema</> parameter in
     the control file if that is given, otherwise by the <literal>SCHEMA</>
     option of <command>CREATE EXTENSION</> if that is given, otherwise the
     current default object creation schema (the first one in the caller's
     <varname>search_path</>).  When the control file <varname>schema</>
     parameter is used, the target schema will be created if it doesn't
     already exist, but in the other two cases it must already exist.
-->
対象のスキーマは制御ファイル内の<varname>schema</>パラメータがあればこのパラメータにより決定されます。
このパラメータがなければ、<command>CREATE EXTENSION</>の<literal>SCHEMA</>があればこの値で決まり、これ以外の場合は現在のデフォルトのオブジェクト生成用スキーマ（呼び出し元の<varname>search_path</>の最初のもの）になります。
制御ファイルの<varname>schema</>パラメータが使用される時、対象のスキーマが存在しない場合は作成されますが、これ以外の２つの場合ではすでに存在しなければなりません。
    </para>

    <para>
<!--
     If any prerequisite extensions are listed in <varname>requires</varname>
     in the control file, their target schemas are appended to the initial
     setting of <varname>search_path</>.  This allows their objects to be
     visible to the new extension's script file.
-->
何らかの事前に必要な拡張が制御ファイル内の<varname>requires</varname>に列挙されていた場合、それらの対象スキーマが<varname>search_path</>の初期設定に追加されます。
これにより新しい拡張のスクリプトファイルからそれらのオブジェクトが可視になります。
    </para>

    <para>
<!--
     Although a non-relocatable extension can contain objects spread across
     multiple schemas, it is usually desirable to place all the objects meant
     for external use into a single schema, which is considered the extension's
     target schema.  Such an arrangement works conveniently with the default
     setting of <varname>search_path</> during creation of dependent
     extensions.
-->
再配置不可能な拡張は複数スキーマにまたがるオブジェクトを含めることができますが、通常、外部使用を意図したオブジェクトはすべて単一スキーマに格納することが望まれます。
この単一スキーマが拡張の対象のスキーマとみなされます。
こうした調整は依存する拡張を作成する間、デフォルトの<varname>search_path</>設定を都合に合わせて扱います。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Extension Configuration Tables</title>
-->
    <title>拡張設定テーブル</title>

    <para>
<!--
     Some extensions include configuration tables, which contain data that
     might be added or changed by the user after installation of the
     extension.  Ordinarily, if a table is part of an extension, neither
     the table's definition nor its content will be dumped by
     <application>pg_dump</>.  But that behavior is undesirable for a
     configuration table; any data changes made by the user need to be
     included in dumps, or the extension will behave differently after a dump
     and reload.
-->
一部の拡張は、拡張をインストールした後でユーザにより追加または変更される可能性があるデータを持つ設定テーブルを含みます。
通常、テーブルが拡張の一部である場合、テーブル定義もその内容も<application>pg_dump</>によりダンプされません。
しかしこの振舞いは設定テーブルの場合望まれません。
ユーザによってなされたデータ変更はダンプ内に含まれなければなりません。
さもないとダンプしリストアした後で拡張の動作が変わってしまいます。
    </para>

   <indexterm>
    <primary>pg_extension_config_dump</primary>
   </indexterm>

    <para>
<!--
     To solve this problem, an extension's script file can mark a table
     it has created as a configuration table, which will cause
     <application>pg_dump</> to include the table's contents (not its
     definition) in dumps.  To do that, call the function
     <function>pg_extension_config_dump(regclass, text)</> after creating the
     table, for example
-->
この問題を解消するために、拡張のスクリプトファイルでは設定テーブルとして作成されるテーブルに印を付け、<application>pg_dump</>にテーブルの内容をダンプに含める（定義は含まれません）ようにさせることができます。
このためには、以下の例のようにテーブルを作成した後に<function>pg_extension_config_dump(regclass, text)</>関数を呼び出してください。
<programlisting>
CREATE TABLE my_config (key text, value text);

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
</programlisting>
<!--
     Any number of tables can be marked this way.
-->
任意数のテーブルをこの方法で印付けることができます。
    </para>

    <para>
<!--
     When the second argument of <function>pg_extension_config_dump</> is
     an empty string, the entire contents of the table are dumped by
     <application>pg_dump</>.  This is usually only correct if the table
     is initially empty as created by the extension script.  If there is
     a mixture of initial data and user-provided data in the table,
     the second argument of <function>pg_extension_config_dump</> provides
     a <literal>WHERE</> condition that selects the data to be dumped.
     For example, you might do
-->
<function>pg_extension_config_dump</>の第２引数が空文字列である場合、テーブルのすべての内容が<application>pg_dump</>によりダンプされます。
これは、拡張のスクリプトによって作成された初期段階においてテーブルが空である場合のみ正しいものです。
テーブルの中で初期データとユーザが提供したデータが混在する場合、<function>pg_extension_config_dump</>の第２引数においてダンプすべきデータを選択する<literal>WHERE</>条件を提供します。
以下に例を示します。
<programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</programlisting>
<!--
     and then make sure that <structfield>standard_entry</> is true only
     in the rows created by the extension's script.
-->
このようにした後、拡張のスクリプトで作成される行のみで<structfield>standard_entry</>が確実に真になるようにします。
    </para>

    <para>
<!--
     More complicated situations, such as initially-provided rows that might
     be modified by users, can be handled by creating triggers on the
     configuration table to ensure that modified rows are marked correctly.
-->
初期状態で提供される行がユーザによって変更されるようなもっと複雑な状況では、設定テーブルに対するトリガを作成して、変更された行が正しく印付けられることを確実にするように取り扱うことができます。
    </para>

    <para>
<!--
     You can alter the filter condition associated with a configuration table
     by calling <function>pg_extension_config_dump</> again.  (This would
     typically be useful in an extension update script.)  The only way to mark
     a table as no longer a configuration table is to dissociate it from the
     extension with <command>ALTER EXTENSION ... DROP TABLE</>.
-->
<function>pg_extension_config_dump</>を再度呼び出すことにより、設定テーブルに関連付いたフィルタ条件を変更することができます。
（通常これは拡張の更新スクリプト内で役に立つでしょう。）
設定ファイルからテーブルを取り除くように印付ける方法は、<command>ALTER EXTENSION ... DROP TABLE</>を用いてテーブルを拡張から分離するしかありません。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Extension Updates</title>
-->
    <title>拡張の更新</title>

    <para>
<!--
     One advantage of the extension mechanism is that it provides convenient
     ways to manage updates to the SQL commands that define an extension's
     objects.  This is done by associating a version name or number with
     each released version of the extension's installation script.
     In addition, if you want users to be able to update their databases
     dynamically from one version to the next, you should provide
     <firstterm>update scripts</> that make the necessary changes to go from
     one version to the next.  Update scripts have names following the pattern
     <literal><replaceable>extension</>&#045;-<replaceable>oldversion</>&#045;-<replaceable>newversion</>.sql</literal>
     (for example, <literal>foo&#045;-1.0&#045;-1.1.sql</> contains the commands to modify
     version <literal>1.0</> of extension <literal>foo</> into version
     <literal>1.1</>).
-->
拡張機構の１つの利点は、拡張のオブジェクトを定義するSQLコマンドの更新を簡便に管理する方法を提供していることです。
これは、拡張のインストール用スクリプトのリリース版それぞれにバージョン名称またはバージョン番号を関連付けることで行われます。
さらに、ユーザにあるバージョンから次のバージョンへ動的にデータベースを更新させることができるようにしたい場合、あるバージョンから次のバージョンまでの間に行われる必要な変更を行う<firstterm>更新スクリプト</>を提供しなければなりません。
更新スクリプトは<literal><replaceable>extension</>--<replaceable>oldversion</>--<replaceable>newversion</>.sql</literal>というパターンに従った名前（例えば、<literal>foo--1.0--1.1.sql</>は<literal>foo</>拡張のバージョン<literal>1.0</>からバージョン<literal>1.1</>に変更するコマンドを含みます。）を持たなければなりません。
    </para>

    <para>
<!--
     Given that a suitable update script is available, the command
     <command>ALTER EXTENSION UPDATE</> will update an installed extension
     to the specified new version.  The update script is run in the same
     environment that <command>CREATE EXTENSION</> provides for installation
     scripts: in particular, <varname>search_path</> is set up in the same
     way, and any new objects created by the script are automatically added
     to the extension.
-->
適切な更新スクリプトが利用可能である場合、<command>ALTER EXTENSION UPDATE</>コマンドはインストール済みの拡張を指定した新しいバージョンへ更新します。
更新スクリプトは、<command>CREATE EXTENSION</>がインストール用スクリプト向けに提供する環境と同じ環境で実行されます。
具体的には<varname>search_path</>は同じ方法で設定され、スクリプトにより作成される新しいオブジェクトはすべて自動的に拡張に追加されます。
    </para>

    <para>
<!--
     If an extension has secondary control files, the control parameters
     that are used for an update script are those associated with the script's
     target (new) version.
-->
拡張が副制御ファイルを持つ場合、更新スクリプトで使用される制御パラメータは、スクリプトの対象の（新しい）バージョンに関連付けされたものになります。
    </para>

    <para>
<!--
     The update mechanism can be used to solve an important special case:
     converting a <quote>loose</> collection of objects into an extension.
     Before the extension mechanism was added to
     <productname>PostgreSQL</productname> (in 9.1), many people wrote
     extension modules that simply created assorted unpackaged objects.
     Given an existing database containing such objects, how can we convert
     the objects into a properly packaged extension?  Dropping them and then
     doing a plain <command>CREATE EXTENSION</> is one way, but it's not
     desirable if the objects have dependencies (for example, if there are
     table columns of a data type created by the extension).  The way to fix
     this situation is to create an empty extension, then use <command>ALTER
     EXTENSION ADD</> to attach each pre-existing object to the extension,
     then finally create any new objects that are in the current extension
     version but were not in the unpackaged release.  <command>CREATE
     EXTENSION</> supports this case with its <literal>FROM</> <replaceable
     class="parameter">old_version</> option, which causes it to not run the
     normal installation script for the target version, but instead the update
     script named
     <literal><replaceable>extension</>&#045;-<replaceable>old_version</>&#045;-<replaceable>target_version</>.sql</literal>.
     The choice of the dummy version name to use as <replaceable
     class="parameter">old_version</> is up to the extension author, though
     <literal>unpackaged</> is a common convention.  If you have multiple
     prior versions you need to be able to update into extension style, use
     multiple dummy version names to identify them.
-->
更新機構を使用して、オブジェクトの<quote>粗</>集合から拡張に変換するという、特別かつ重大な状況を解消することができます。
拡張機構が<productname>PostgreSQL</productname>に（9.1で）追加されるようになる前では、パッケージ化されずに単に詰めあわされたオブジェクトを作成する拡張モジュールを多くのユーザが作成していました。
こうしたオブジェクトを持つデータベースが存在する場合、どのようにすればこれらのオブジェクトを適切にパッケージ化された拡張に変換できるでしょうか？
削除した後で普通に<command>CREATE EXTENSION</>を行うことも１つの方法ですが、オブジェクトに依存関係がある（例えば拡張により作成されたデータ型のテーブル列が存在する場合など）場合は好まれません。
こうした状況を解消する方法は、空の拡張を作成し、<command>ALTER EXTENSION ADD</>を使用して、既存のオブジェクトそれぞれを拡張に関連づけ、最後にパッケージ化されていないリリースに存在しないが現在のバージョンの拡張には存在する新しいオブジェクトを作成するという方法です。
<command>CREATE EXTENSION</>は<literal>FROM</> <replaceable class="parameter">old_version</>オプションでこの状況をサポートします。
この場合、通常のインストール用スクリプトは実行されず、代わりに<literal><replaceable>extension</>--<replaceable>old_version</>--<replaceable>target_version</>.sql</literal>という名前の更新スクリプトが実行されるようになります。
<replaceable>old_version</>として使用するダミーのバージョン名の選択は拡張の作成者に任せられていますが、<literal>unpackaged</>がよく使われる規約です。
拡張形式に更新できるようにしたい過去のバージョンが複数存在する場合、それらを識別できるように複数のダミーバージョン番号を使用していください。
    </para>

    <para>
<!--
     <command>ALTER EXTENSION</> is able to execute sequences of update
     script files to achieve a requested update.  For example, if only
     <literal>foo&#045;-1.0&#045;-1.1.sql</> and <literal>foo&#045;-1.1&#045;-2.0.sql</> are
     available, <command>ALTER EXTENSION</> will apply them in sequence if an
     update to version <literal>2.0</> is requested when <literal>1.0</> is
     currently installed.
-->
<command>ALTER EXTENSION</>は、要求される更新を実現するために更新スクリプトを連続して実行することができます。
例えば<literal>foo--1.0--1.1.sql</>と<literal>foo--1.1--2.0.sql</>のみが利用可能であるとすると、現在<literal>1.0</>がインストールされている時にバージョン<literal>2.0</>への更新が要求された場合、<command>ALTER EXTENSION</>はこれらを順番に適用します。
    </para>

    <para>
<!--
     <productname>PostgreSQL</> doesn't assume anything about the properties
     of version names: for example, it does not know whether <literal>1.1</>
     follows <literal>1.0</>.  It just matches up the available version names
     and follows the path that requires applying the fewest update scripts.
     (A version name can actually be any string that doesn't contain
     <literal>&#045;-</> or leading or trailing <literal>-</>.)
-->
<productname>PostgreSQL</>はバージョン名称の特性についてまったく仮定を行いません。
例えば<literal>1.0</>の次が<literal>1.1</>であるかどうかを把握しません。
これは利用可能なバージョン名をかみ合わせ、もっとも少ない数の更新スクリプトを適用するために必要な経路を続けるだけです。
（バージョン名には、<literal>--</>を含まず先頭または最後に<literal>-</>が付かなければ、任意の文字を取ることができます。）
    </para>

    <para>
<!--
     Sometimes it is useful to provide <quote>downgrade</> scripts, for
     example <literal>foo&#045;-1.1&#045;-1.0.sql</> to allow reverting the changes
     associated with version <literal>1.1</>.  If you do that, be careful
     of the possibility that a downgrade script might unexpectedly
     get applied because it yields a shorter path.  The risky case is where
     there is a <quote>fast path</> update script that jumps ahead several
     versions as well as a downgrade script to the fast path's start point.
     It might take fewer steps to apply the downgrade and then the fast
     path than to move ahead one version at a time.  If the downgrade script
     drops any irreplaceable objects, this will yield undesirable results.
-->
<quote>ダウングレード</>スクリプトを提供することが便利な場合があります。
例えば<literal>foo--1.1--1.0.sql</>は、バージョン<literal>1.1</>に関連した変更を元に戻すことができます。
この場合、ダウングレードスクリプトがより短いパスを生成するために、予期せず適用されてしまう可能性に注意してください。
複数のバージョンをまたがって更新する<quote>近道</>更新スクリプトと近道の開始バージョンへのダウングレードスクリプトが存在する場合に危険性があります。
ダウングレードしてから近道となる更新スクリプトを実行する方が、バージョンを１つずつ進めるよりも少ない処理で済んでしまうかもしれません。
ダウングレードスクリプトが取り返しがつかないオブジェクトを何か削除してしまう場合、望まない結果になってしまいます。
    </para>

    <para>
<!--
     To check for unexpected update paths, use this command:
-->
想定外の更新経路かどうかを検査するためには、以下のコマンドを使用してください。
<programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</>');
</programlisting>
<!--
     This shows each pair of distinct known version names for the specified
     extension, together with the update path sequence that would be taken to
     get from the source version to the target version, or <literal>NULL</> if
     there is no available update path.  The path is shown in textual form
     with <literal>&#045;-</> separators.  You can use
     <literal>regexp_split_to_array(path,'&#045;-')</> if you prefer an array
     format.
-->
これは指定した拡張の個々の既知のバージョン名の組み合わせをそれぞれ、元のバージョンから対象のバージョンへ進む時に取られる更新経路順、またはもし利用できる更新経路がなければ<literal>NULL</>を付けて、表示します。
経路は<literal>--</>を区切り文字として使用したテキスト形式で表示されます。
配列形式の方が良ければ<literal>regexp_split_to_array(path,'--')</>を使用することができます。

    </para>
   </sect2>

   <sect2>
<!--
    <title>Extension Example</title>
-->
    <title>拡張の例</title>

    <para>
<!--
     Here is a complete example of an <acronym>SQL</>-only
     extension, a two-element composite type that can store any type of value
     in its slots, which are named <quote>k</> and <quote>v</>.  Non-text
     values are automatically coerced to text for storage.
-->
ここでは、<acronym>SQL</>のみの拡張の完全な例を示します。
<quote>k</>と<quote>v</>という名称の２つの要素からなる複合型であり、そのスロットには任意の型の値を格納することができるものです。
格納の際テキスト以外の値は自動的にテキストに変換されます。
    </para>

    <para>
<!--
     The script file <filename>pair&#045;-1.0.sql</> looks like this:
-->
<filename>pair--1.0.sql</>スクリプトファイルは以下のようになります。

<programlisting><![CDATA[
]]><!--
&#045;- complain if script is sourced in psql, rather than via CREATE EXTENSION
--><![CDATA[
-- スクリプトが、CREATE EXTENSION経由ではなく、psqlのソースとして使われた場合には文句を言う
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);
]]>
</programlisting>
    </para>

    <para>
<!--
     The control file <filename>pair.control</> looks like this:
-->
<filename>pair.control</>制御ファイルは以下のようになります。

<programlisting>
# pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true
</programlisting>
    </para>

    <para>
<!--
     While you hardly need a makefile to install these two files into the
     correct directory, you could use a <filename>Makefile</> containing this:
-->
これらの２つのファイルを正しいディレクトリにインストールするためにメークファイルを作成する必要はほとんどありませんが、以下を含む<filename>Makefile</>を使用することができます。

<programlisting>
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>

<!--
     This makefile relies on <acronym>PGXS</acronym>, which is described
     in <xref linkend="extend-pgxs">.  The command <literal>make install</>
     will install the control and script files into the correct
     directory as reported by <application>pg_config</>.
-->
このメークファイルは<xref linkend="extend-pgxs">で説明する<acronym>PGXS</acronym>に依存します。
<literal>make install</>コマンドは制御ファイルとスクリプトファイルを<application>pg_config</>で報告される正しいディレクトリにインストールします。
    </para>

    <para>
<!--
     Once the files are installed, use the
     <xref linkend="sql-createextension"> command to load the objects into
     any particular database.
-->
ファイルがインストールされた後、<xref linkend="sql-createextension">コマンドを使用してオブジェクトを任意の特定のデータベースにロードしてください。
    </para>
   </sect2>
  </sect1>

  <sect1 id="extend-pgxs">
<!--
   <title>Extension Building Infrastructure</title>
-->
   <title>拡張構築基盤</title>

   <indexterm zone="extend-pgxs">
    <primary>pgxs</primary>
   </indexterm>

   <para>
<!--
    If you are thinking about distributing your
    <productname>PostgreSQL</> extension modules, setting up a
    portable build system for them can be fairly difficult.  Therefore
    the <productname>PostgreSQL</> installation provides a build
    infrastructure for extensions, called <acronym>PGXS</acronym>, so
    that simple extension modules can be built simply against an
    already installed server.  <acronym>PGXS</acronym> is mainly intended
    for extensions that include C code, although it can be used for
    pure-SQL extensions too.  Note that <acronym>PGXS</acronym> is not
    intended to be a universal build system framework that can be used
    to build any software interfacing to <productname>PostgreSQL</>;
    it simply automates common build rules for simple server extension
    modules.  For more complicated packages, you might need to write your
    own build system.
-->
<productname>PostgreSQL</>拡張モジュールの配布を考えているのであれば、移植可能な構築システムを準備することはかなり難しいものになるかもしれません。
このため<productname>PostgreSQL</>インストレーションは単純な拡張モジュールをすでにインストールされているサーバに対して簡単に構築することができるように、<acronym>PGXS</acronym>と呼ばれる拡張向けの構築基盤を提供します。
<acronym>PGXS</acronym>は主にCコードを含む拡張を意図していますが、SQLのみからなる拡張でも使用することができます。
<acronym>PGXS</acronym>が<productname>PostgreSQL</>と相互に作用する任意のソフトウェアを構築するために使用できるような万能な構築システムを意図したものではないことに注意してください。
これは単に、単純なサーバ拡張用の一般的な構築規則を自動化するものです。
より複雑なパッケージでは、独自の構築システムを作成する必要があるかもしれません。
   </para>

   <para>
<!--
    To use the <acronym>PGXS</acronym> infrastructure for your extension,
    you must write a simple makefile.
    In the makefile, you need to set some variables
    and include the global <acronym>PGXS</acronym> makefile.
    Here is an example that builds an extension module named
    <literal>isbn_issn</literal>, consisting of a shared library containing
    some C code, an extension control file, a SQL script, and a documentation
    text file:
-->
独自の拡張で<acronym>PGXS</acronym>基盤を使用するためには、簡単なメークファイルを作成する必要があります。
このメークファイルの中で、いくつか変数を設定し、大域的な<acronym>PGXS</acronym>メークファイルをインクルードする必要があります。
以下に<literal>isbn_issn</literal>という名称の拡張モジュールを構築する例を示します。
このモジュールはいくつかのCコードを含む共有ライブラリ、拡張の制御ファイル、SQLスクリプト、ドキュメントテキストファイルから構成されます。
<programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>
<!--
    The last three lines should always be the same.  Earlier in the
    file, you assign variables or add custom
    <application>make</application> rules.
-->
最後の３行は常に同じです。
ファイルのこの前に変数の設定と独自の<application>make</application>ルールを記載してください。
   </para>

   <para>
<!--
    Set one of these three variables to specify what is built:
-->
以下の３個の変数の１つを構築対象に指定してください。

    <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>
<!--
        list of shared-library objects to be built from source files with same
        stem (do not include library suffixes in this list)
-->
同じ家系のソースファイルから構築される共有ライブラリのリストです。
（このリストにはライブラリ接頭辞を含めないでください。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <para>
<!--
        a shared library to build from multiple source files
        (list object files in <varname>OBJS</varname>)
-->
複数のソースファイルから構築される共有ライブラリです。
（<varname>OBJS</varname>にオブジェクトファイルを列挙します。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <para>
<!--
        an executable program to build
        (list object files in <varname>OBJS</varname>)
-->
構築する実行プログラムです。
（<varname>OBJS</varname>にオブジェクトファイルを列挙します。）
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    The following variables can also be set:
-->
以下の変数も設定することができます。

    <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <para>
<!--
        extension name(s); for each name you must provide an
        <literal><replaceable>extension</replaceable>.control</literal> file,
        which will be installed into
        <literal><replaceable>prefix</replaceable>/share/extension</literal>
-->
拡張の名前です。
各名前に対して、<literal><replaceable>prefix</replaceable>/share/extension</literal>にインストールされる<literal><replaceable>extension</replaceable>.control</literal>を提供しなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <para>
<!--
        subdirectory of <literal><replaceable>prefix</>/share</literal>
        into which DATA and DOCS files should be installed
        (if not set, default is <literal>extension</literal> if
        <varname>EXTENSION</varname> is set,
        or <literal>contrib</literal> if not)
-->
DATAおよびDOCSファイルのインストール先となるはずの<literal><replaceable>prefix</>/share</literal>副ディレクトリです。
（設定がない場合、デフォルトは<varname>EXTENSION</varname>が設定されている場合は<literal>extension</literal>に、設定されていない場合は<literal>contrib</literal>になります。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <para>
<!--
        random files to install into <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>
-->
<literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>にインストールされる様々なファイルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <para>
<!--
        random files to install into
        <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>,
        which need to be built first
-->
<literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>にインストールされる、最初に構築しなければならない様々なファイルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <para>
<!--
        random files to install under
        <literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>
-->
<literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>以下にインストールされる様々なファイルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <para>
<!--
        random files to install under
        <literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
-->
<literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>以下にインストールされる様々なファイルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <para>
<!--
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>
-->
<literal><replaceable>prefix</replaceable>/bin</literal>にインストールされるスクリプトファイルです（バイナリファイルではありません）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <para>
<!--
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>,
        which need to be built first
-->
<literal><replaceable>prefix</replaceable>/bin</literal>にインストールされる、最初に構築しなければならないスクリプトファイルです（バイナリファイルではありません）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <para>
<!--
        list of regression test cases (without suffix), see below
-->
リグレッション試験ケース（接尾辞がない）のリストです。
後述します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS_OPTS</varname></term>
      <listitem>
       <para>
<!--
        additional switches to pass to <application>pg_regress</>
-->
<application>pg_regress</>に渡す追加オプションです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <para>
<!--
        extra files to remove in <literal>make clean</literal>
-->
<literal>make clean</literal>で削除される追加ファイルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <para>
<!--
        will be added to <varname>CPPFLAGS</varname>
-->
<varname>CPPFLAGS</varname>に追加されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <para>
<!--
        will be added to <varname>PROGRAM</varname> link line
-->
<varname>PROGRAM</varname>のリンク行に追加されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <para>
<!--
        will be added to <varname>MODULE_big</varname> link line
-->
<varname>MODULE_big</varname>リンク行に追加されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <para>
<!--
        path to <application>pg_config</> program for the
        <productname>PostgreSQL</productname> installation to build against
        (typically just <literal>pg_config</> to use the first one in your
        <varname>PATH</>)
-->
構築対象の<productname>PostgreSQL</productname>インストレーション用の<application>pg_config</>プログラムへのパスです。
（通常は<varname>PATH</>内の最初に見つかる<literal>pg_config</>が単純に使用されます）
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    Put this makefile as <literal>Makefile</literal> in the directory
    which holds your extension. Then you can do
    <literal>make</literal> to compile, and then <literal>make
    install</literal> to install your module.  By default, the extension is
    compiled and installed for the
    <productname>PostgreSQL</productname> installation that
    corresponds to the first <command>pg_config</command> program
    found in your <varname>PATH</>.  You can use a different installation by
    setting <varname>PG_CONFIG</varname> to point to its
    <command>pg_config</command> program, either within the makefile
    or on the <literal>make</literal> command line.
-->
このメークファイルを<literal>Makefile</literal>として拡張を保管するディレクトリ内に保管してください。
その後コンパイルするために<literal>make</literal>を、モジュールをインストールするために<literal>make install</literal>を行うことができます。
デフォルトでは、<varname>PATH</>の中で最初に見つかる<command>pg_config</command>プログラムが対応する<productname>PostgreSQL</productname>インストレーション用に拡張はコンパイルされ、インストールされます。
メークファイルまたは<literal>make</literal>のコマンドラインのいずれかで<varname>PG_CONFIG</varname>を別の<command>pg_config</command>プログラムを指し示すように設定することで、別のインストレーションを使用することができます。
   </para>

   <para>
<!--
    You can also run <literal>make</literal> in a directory outside the source
    tree of your extension, if you want to keep the build directory separate.
    This procedure is also called a
    <indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>
    build.  Here's how:
-->
構築ディレクトリを別にしておきたいのであれば、拡張のソースツリーの外のディレクトリで<literal>make</literal>を実行することもできます。
この方法は<indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>構築とも呼ばれます。
以下にやり方を示します。
<programlisting>
mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install
</programlisting>
   </para>

   <para>
<!--
    Alternatively, you can set up a directory for a VPATH build in a similar
    way to how it is done for the core code. One way to do this is using the
    core script <filename>config/prep_buildtree</>. Once this has been done
    you can build by setting the <literal>make</literal> variable
    <varname>VPATH</varname> like this:
-->
あるいは、コアコードと同様な方法でVPATH構築用のディレクトリを設定できます。
そのようにする1つの方法は、コアスクリプト<filename>config/prep_buildtree</>を使うことです。
一度そうすれば、<literal>make</literal>変数<varname>VPATH</varname>を以下のように設定することで、構築できます。
<programlisting>
make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install
</programlisting>
<!--
    This procedure can work with a greater variety of directory layouts.
-->
この方法はより様々なディレクトリのレイアウトで機能します。
   </para>

   <para>
<!--
    The scripts listed in the <varname>REGRESS</> variable are used for
    regression testing of your module, which can be invoked by <literal>make
    installcheck</literal> after doing <literal>make install</>.  For this to
    work you must have a running <productname>PostgreSQL</productname> server.
    The script files listed in <varname>REGRESS</> must appear in a
    subdirectory named <literal>sql/</literal> in your extension's directory.
    These files must have extension <literal>.sql</literal>, which must not be
    included in the <varname>REGRESS</varname> list in the makefile.  For each
    test there should also be a file containing the expected output in a
    subdirectory named <literal>expected/</literal>, with the same stem and
    extension <literal>.out</literal>.  <literal>make installcheck</literal>
    executes each test script with <application>psql</>, and compares the
    resulting output to the matching expected file.  Any differences will be
    written to the file <literal>regression.diffs</literal> in <command>diff
    -c</command> format.  Note that trying to run a test that is missing its
    expected file will be reported as <quote>trouble</quote>, so make sure you
    have all expected files.
-->
<varname>REGRESS</>変数に列挙されたスクリプトは、<literal>make install</>を実行した後で<literal>make installcheck</literal>によって呼び出すことができる、作成したモジュールのリグレッション試験で使用されます。
これが動作するためには、<productname>PostgreSQL</productname>サーバが実行していなければなりません。
<varname>REGRESS</>変数に列挙されたスクリプトは、拡張のディレクトリ内の<literal>sql/</literal>という名前の副ディレクトリ内に存在しなければなりません。
これらのファイルは<literal>.sql</literal>という拡張子を持たなければなりません。
この拡張子はメークファイル内の<varname>REGRESS</varname>リストには含まれません。
また試験ごとに<literal>expected/</literal>という名前の副ディレクトリ内に想定出力を内容として含む、同じステムに<literal>.out</literal>拡張子を付けた名前のファイルがなければなりません。
<literal>make installcheck</literal>は<application>psql</>を用いて各試験スクリプトを実行し、結果出力が想定ファイルに一致するかどうか比較します。
何らかの差異は<command>diff -c</command>書式で<literal>regression.diffs</literal>に書き出されます。
想定ファイルがない試験を実行しようとすると<quote>問題</quote>として報告されます。
このためすべての想定ファイルがあることを確認してください。
   </para>

   <tip>
    <para>
<!--
     The easiest way to create the expected files is to create empty files,
     then do a test run (which will of course report differences).  Inspect
     the actual result files found in the <literal>results/</literal>
     directory, then copy them to <literal>expected/</literal> if they match
     what you expect from the test.
-->
想定ファイルを作成する最も簡単な方法は、空のファイルを作成し、試験を実行する（当然差異が報告されます）ことです。
<literal>results/</literal>ディレクトリ内で見つかる実際の結果ファイルを確認し、テストの想定結果と合致するのであれば、<literal>expected/</literal>にコピーしてください。
    </para>

   </tip>
  </sect1>

 </chapter>
