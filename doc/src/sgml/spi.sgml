<!-- doc/src/sgml/spi.sgml -->

<chapter id="spi">
<!--
 <title>Server Programming Interface</title>
-->
 <title>サーバプログラミングインタフェース</title>

 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>

 <para>
<!--
  The <firstterm>Server Programming Interface</firstterm>
  (<acronym>SPI</acronym>) gives writers of user-defined
  <acronym>C</acronym> functions the ability to run
  <acronym>SQL</acronym> commands inside their functions.
  <acronym>SPI</acronym> is a set of
  interface functions to simplify access to the parser, planner,
  and executor. <acronym>SPI</acronym> also does some
  memory management.
-->
<FirstTerm>サーバプログラミングインタフェース</FirstTerm>（<Acronym>SPI</Acronym>）は、ユーザ定義の<Acronym>C</Acronym>関数から<Acronym>SQL</Acronym>問い合わせを実行する機能をユーザに提供します。
<acronym>SPI</acronym>はパーサ、プランナ、エクゼキュータへのアクセスを単純化したインタフェース関数の集合です。
また、<acronym>SPI</acronym>は多少のメモリ管理を行います。
 </para>

 <note>
  <para>
<!--
   The available procedural languages provide various means to
   execute SQL commands from procedures.  Most of these facilities are
   based on SPI, so this documentation might be of use for users
   of those languages as well.
-->
利用可能な手続き言語は、プロシージャからSQLコマンドを実行するための各種手段を提供します。
これらのほとんどは、SPIを基にしていますので、この文書はこれらの言語のユーザにとっても有用な場合があります。
  </para>
 </note>

 <para>
<!--
  To avoid misunderstanding we'll use the term <quote>function</quote>
  when we speak of <acronym>SPI</acronym> interface functions and
  <quote>procedure</quote> for a user-defined C-function that is
  using <acronym>SPI</acronym>.
-->
誤解を防ぐために、これ以降、<quote>関数</quote>を<Acronym>SPI</Acronym>インタフェース関数の意味で、<quote>プロシージャ</quote>を<Acronym>SPI</Acronym>を呼び出すユーザ定義のC関数の意味で使うことにします。
 </para>

 <para>
<!--
  Note that if a command invoked via SPI fails, then control will not be
  returned to your procedure.  Rather, the
  transaction or subtransaction in which your procedure executes will be
  rolled back.  (This might seem surprising given that the SPI functions mostly
  have documented error-return conventions.  Those conventions only apply
  for errors detected within the SPI functions themselves, however.)
  It is possible to recover control after an error by establishing your own
  subtransaction surrounding SPI calls that might fail.  This is not currently
  documented because the mechanisms required are still in flux.
-->
コマンドがSPIの失敗を起こした場合、その制御はプロシージャには戻らないことに注意してください。
それどころか、プロシージャを実行していたトランザクションもしくは副トランザクションはロールバックされます
（これはSPI関数のほとんどでエラーを返す規約があることから奇妙に思われるかもしれません。
しかし、こうした規約はSPI関数自身でエラーを検知した時にのみ適用されるものです）。
失敗する可能性があるSPI呼び出しを囲む副トランザクションを独自に用意することで、エラーの後の制御を戻すことができます。
要求される機構がまだ流動的であるため、これはまだ文書化されていません。
 </para>

 <para>
<!--
  <acronym>SPI</acronym> functions return a nonnegative result on
  success (either via a returned integer value or in the global
  variable <varname>SPI_result</varname>, as described below).  On
  error, a negative result or <symbol>NULL</symbol> will be returned.
-->
<acronym>SPI</acronym>関数は成功時に非負の結果を（戻り値、もしくは後述の<varname>SPI_result</varname>グローバル変数の中に）返します。
エラー時、負の結果もしくは<symbol>NULL</symbol>を返します。
 </para>

 <para>
<!--
  Source code files that use SPI must include the header file
  <filename>executor/spi.h</filename>.
-->
SPIを使用するソースコードファイルでは<filename>executor/spi.h</filename>ヘッダファイルをincludeしなければなりません。
 </para>


<sect1 id="spi-interface">
<!--
 <title>Interface Functions</title>
-->
 <title>インタフェース関数</title>

 <refentry id="spi-spi-connect">
  <indexterm><primary>SPI_connect</primary></indexterm>

  <refmeta>
   <refentrytitle>SPI_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>SPI_connect</refname>
<!--
   <refpurpose>connect a procedure to the SPI manager</refpurpose>
-->
   <refpurpose>SPIマネージャにプロシージャを接続する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_connect(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_connect</function> opens a connection from a
   procedure invocation to the SPI manager.  You must call this
   function if you want to execute commands through SPI.  Some utility
   SPI functions can be called from unconnected procedures.
-->
<function>SPI_connect</function>はプロシージャ呼び出しからSPIマネージャへの接続を開きます。
SPIを経由してコマンドを実行させる場合、この関数を呼び出さなければなりません。
SPIユーティリティ関数の中には、未接続のプロシージャから呼び出し可能なものがあります。
  </para>

  <para>
<!--
   If your procedure is already connected,
   <function>SPI_connect</function> will return the error code
   <returnvalue>SPI_ERROR_CONNECT</returnvalue>.  This could happen if
   a procedure that has called <function>SPI_connect</function>
   directly calls another procedure that calls
   <function>SPI_connect</function>.  While recursive calls to the
   <acronym>SPI</acronym> manager are permitted when an SQL command
   called through SPI invokes another function that uses
   <acronym>SPI</acronym>, directly nested calls to
   <function>SPI_connect</function> and
   <function>SPI_finish</function> are forbidden.
   (But see <function>SPI_push</function> and <function>SPI_pop</function>.)
-->
既にプロシージャが接続済みの場合、<function>SPI_connect</function>は<returnValue>SPI_ERROR_CONNECT</returnValue>エラーを返します。
これは、<function>SPI_connect</function>を呼び出したプロシージャが、直接それ自身で<function>SPI_connect</function>を呼び出す別のプロシージャを呼び出す場合に起こります。
SPIを経由して呼び出されるSQLコマンドが<acronym>SPI</acronym>を使用する他の関数を呼び出す場合、<acronym>SPI</acronym>マネージャの再帰的な呼び出しは許可されていますが、<acronym>SPI_connect</acronym>と<acronym>SPI_finish</acronym>を直接入れ子に呼び出すことは禁止されています
（しかし、<function>SPI_push</function>および<function>SPI_pop</function>を参照してください。）
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_CONNECT</symbol></term>
    <listitem>
     <para>
<!--
      on success
-->
成功した場合。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
    <listitem>
     <para>
<!--
      on error
-->
エラーが発生した場合。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-finish">
 <indexterm><primary>SPI_finish</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_finish</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_finish</refname>
<!--
  <refpurpose>disconnect a procedure from the SPI manager</refpurpose>
-->
  <refpurpose>プロシージャをSPIマネージャから切断する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_finish(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_finish</function> closes an existing connection to
   the SPI manager.  You must call this function after completing the
   SPI operations needed during your procedure's current invocation.
   You do not need to worry about making this happen, however, if you
   abort the transaction via <literal>elog(ERROR)</literal>.  In that
   case SPI will clean itself up automatically.
-->
<function>SPI_finish</function>は既存のSPIマネージャへの接続を切断します。
プロシージャの現在の呼び出し期間内で必要なSPI操作が完了した後この関数を呼び出さなければなりません。
しかし、<literal>elog(ERROR)</literal>経由でトランザクションを中断させる場合は、この関数が何を行うかを気にする必要はありません。
その場合、SPIは自動的に自身を整理します。
  </para>

  <para>
<!--
   If <function>SPI_finish</function> is called without having a valid
   connection, it will return <symbol>SPI_ERROR_UNCONNECTED</symbol>.
   There is no fundamental problem with this; it means that the SPI
   manager has nothing to do.
-->
<function>SPI_finish</function>が、有効な接続がない状態で呼び出された場合、<symbol>SPI_ERROR_UNCONNECTED</symbol>が返されます。
この場合根本的な問題はありません。SPIマネージャは特に行うことがないことを意味します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_FINISH</symbol></term>
    <listitem>
     <para>
<!--
      if properly disconnected
-->
適切に切断された場合。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
    <listitem>
     <para>
<!--
      if called from an unconnected procedure
-->
未接続のプロシージャから呼び出された場合。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-push">
 <indexterm><primary>SPI_push</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_push</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_push</refname>
<!--
  <refpurpose>push SPI stack to allow recursive SPI usage</refpurpose>
-->
  <refpurpose>再帰的にSPIを使用できるようにSPIスタックをプッシュする</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_push(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_push</function> should be called before executing another
   procedure that might itself wish to use SPI.
   After <function>SPI_push</function>, SPI is no longer in a
   <quote>connected</> state, and SPI function calls will be rejected unless
   a fresh <function>SPI_connect</function> is done.  This ensures a clean
   separation between your procedure's SPI state and that of another procedure
   you call.  After the other procedure returns, call
   <function>SPI_pop</function> to restore access to your own SPI state.
-->
<function>SPI_push</function>は、それ自体がSPIを使用する可能性がある他のプロシージャを実行する前に呼び出されなければなりません。
<function>SPI_push</function>の後、SPIは<quote>接続</>状態ではなくなります。
新しく<function>SPI_connect</function>を実行しない限り、SPI関数の呼び出しは拒絶されます。
これにより確実にプロシージャのSPI状態と呼び出した別のプロシージャのSPI状態を明確に分離できます。
他のプロシージャから復帰した後に<function>SPI_pop</function>を呼び出して、そのプロシージャのSPI状態にアクセスを戻してください。
  </para>

  <para>
<!--
   Note that <function>SPI_execute</function> and related functions
   automatically do the equivalent of <function>SPI_push</function> before
   passing control back to the SQL execution engine, so it is not necessary
   for you to worry about this when using those functions.
   Only when you are directly calling arbitrary code that might contain
   <function>SPI_connect</function> calls do you need to issue
   <function>SPI_push</function> and <function>SPI_pop</function>.
-->
<function>SPI_execute</function>とその関連関数は、制御をSQL実行エンジンに戻す前に自動的に<function>SPI_push</function>同等の処理を行うことに注意してください。
ですので、こうした関数を使用する際には気にする必要はありません。
<function>SPI_connect</function>呼び出しを行う可能性がある任意のコードを直接呼び出す場合のみ、<function>SPI_push</function>と<function>SPI_pop</function>を呼び出さなければなりません。
  </para>
 </refsect1>

</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pop">
 <indexterm><primary>SPI_pop</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_pop</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_pop</refname>
<!--
  <refpurpose>pop SPI stack to return from recursive SPI usage</refpurpose>
-->
  <refpurpose>再帰的なSPIの使用から復帰できるようにSPIスタックをポップする</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_pop(void)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_pop</function> pops the previous environment from the
   SPI call stack.  See <function>SPI_push</function>.
-->
<function>SPI_pop</function>は、SPI呼び出しスタックから以前の環境をポップします。
<function>SPI_push</function>を参照してください。
  </para>
 </refsect1>

</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute">
 <indexterm><primary>SPI_execute</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execute</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute</refname>
<!--
  <refpurpose>execute a command</refpurpose>
-->
  <refpurpose>コマンドを実行する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_execute</function> executes the specified SQL command
   for <parameter>count</parameter> rows.  If <parameter>read_only</parameter>
   is <literal>true</>, the command must be read-only, and execution overhead
   is somewhat reduced.
-->
<function>SPI_execute</function>は指定したSQLコマンドを、<parameter>count</parameter>行分実行します。
<parameter>read_only</parameter>が<literal>true</>の場合、そのコマンドは読み取りのみでなければなりませんが、多少のオーバーヘッドが削減されます。
  </para>

  <para>
<!--
   This function can only be called from a connected procedure.
-->
この関数は接続済みのプロシージャからのみ呼び出し可能です。
  </para>

  <para>
<!--
   If <parameter>count</parameter> is zero then the command is executed
   for all rows that it applies to.  If <parameter>count</parameter>
   is greater than zero, then no more than <parameter>count</parameter> rows
   will be retrieved; execution stops when the count is reached, much like
   adding a <literal>LIMIT</literal> clause to the query. For example,
-->
<parameter>count</parameter>が0の場合、そのコマンドを、適用される全ての行に対して実行します。
<parameter>count</parameter>が0より多ければ、<parameter>count</parameter>を超えない数の行が取り出されます。
問い合わせに<literal>LIMIT</literal>句と追加するの同じように、countに達すれば、実行は止まります。
例えば、
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
<!--
   will retrieve at most 5 rows from the table.  Note that such a limit
   is only effective when the command actually returns rows.  For example,
-->
は、テーブルから多くても5行しか取り出しません。
この制限はコマンドが実際に行を返した場合にのみ有効なことに注意して下さい。
例えば
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
<!--
   inserts all rows from <structname>bar</>, ignoring the
   <parameter>count</parameter> parameter.  However, with
-->
は、<parameter>count</parameter>パラメータを無視して、<structname>bar</>からすべての行を挿入します。
しかし、
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
<!--
   at most 5 rows would be inserted, since execution would stop after the
   fifth <literal>RETURNING</> result row is retrieved.
-->
は、5番目の<literal>RETURNING</>の結果行を取り出した後に実行が止まりますので、多くても5行を挿入するだけです。
  </para>

  <para>
<!--
   You can pass multiple commands in one string;
   <function>SPI_execute</function> returns the
   result for the command executed last.  The <parameter>count</parameter>
   limit applies to each command separately (even though only the last
   result will actually be returned).  The limit is not applied to any
   hidden commands generated by rules.
-->
複数のコマンドを1つの文字列として渡すことができます。
<function>SPI_execute</function>は最後に実行したコマンドの結果を返します。
<parameter>count</parameter>制限は（最後の結果が返されただけだとしても）それぞれのコマンドに独立に適用されます。
この制限はルールによって生成される隠れたコマンドには適用されません。
  </para>

  <para>
<!--
   When <parameter>read_only</parameter> is <literal>false</>,
   <function>SPI_execute</function> increments the command
   counter and computes a new <firstterm>snapshot</> before executing each
   command in the string.  The snapshot does not actually change if the
   current transaction isolation level is <literal>SERIALIZABLE</> or <literal>REPEATABLE READ</>, but in
   <literal>READ COMMITTED</> mode the snapshot update allows each command to
   see the results of newly committed transactions from other sessions.
   This is essential for consistent behavior when the commands are modifying
   the database.
-->
<parameter>read_only</parameter>が<literal>false</>の場合、文字列内の各コマンドを実行する前に<function>SPI_execute</function>はコマンドカウンタを増分し、新しい<firstterm>スナップショット</>を作成します。
このスナップショットは、現在のトランザクション隔離レベルが<literal>SERIALIZABLE</>または<literal>REPEATABLE READ</>の場合は変更されません。
しかし、<literal>READ COMMITTED</>モードでは、このスナップショットは更新され、他のセッションで新しくコミットされたトランザクションの結果を各コマンドから参照できます。
これは、そのコマンドがデータベースを変更する場合、一貫性の維持に重要です。
  </para>

  <para>
<!--
   When <parameter>read_only</parameter> is <literal>true</>,
   <function>SPI_execute</function> does not update either the snapshot
   or the command counter, and it allows only plain <command>SELECT</>
   commands to appear in the command string.  The commands are executed
   using the snapshot previously established for the surrounding query.
   This execution mode is somewhat faster than the read/write mode due
   to eliminating per-command overhead.  It also allows genuinely
   <firstterm>stable</> functions to be built: since successive executions
   will all use the same snapshot, there will be no change in the results.
-->
<parameter>read_only</parameter>が<literal>true</>の場合は、<function>SPI_execute</function>はスナップショットもコマンドカウンタも更新しません。
さらに、普通の<command>SELECT</>コマンドのみをコマンド文字列内に記述することができます。
このコマンドは、その前後の問い合わせによって事前に確立済みのスナップショットを使用して実行されます。
この実行モードは読み書きモードよりもコマンドごとのオーバーヘッドが省略される分多少高速です。
また、これにより本当に<firstterm>安定（stable）</>な関数を構築することができます。
つまり、連続した実行は全て同じスナップショットを使用しますので、結果は変わることがないということです。
  </para>

  <para>
<!--
   It is generally unwise to mix read-only and read-write commands within
   a single function using SPI; that could result in very confusing behavior,
   since the read-only queries would not see the results of any database
   updates done by the read-write queries.
-->
一般的に、SPIを使用する1つの関数内で読み取りのみコマンドと読み書きコマンドを混在させることは勧めません。
読み取りのみの問い合わせでは、読み書き問い合わせでなされたデータベースの更新結果を参照しないため、非常に混乱した動作に陥ることがあります。
  </para>

  <para>
<!--
   The actual number of rows for which the (last) command was executed
   is returned in the global variable <varname>SPI_processed</varname>.
   If the return value of the function is <symbol>SPI_OK_SELECT</symbol>,
   <symbol>SPI_OK_INSERT_RETURNING</symbol>,
   <symbol>SPI_OK_DELETE_RETURNING</symbol>, or
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>,
   then you can use the
   global pointer <literal>SPITupleTable *SPI_tuptable</literal> to
   access the result rows.  Some utility commands (such as
   <command>EXPLAIN</>) also return row sets, and <literal>SPI_tuptable</>
   will contain the result in these cases too. Some utility commands
   (<command>COPY</>, <command>CREATE TABLE AS</>) don't return a row set, so
   <literal>SPI_tuptable</> is NULL, but they still return the number of
   rows processed in <varname>SPI_processed</>.
-->
（最後の）コマンドが実行した実際の行数は、<varname>SPI_processed</varname>グローバル変数に返されます。
関数の戻り値が<symbol>SPI_OK_SELECT</symbol>、<symbol>SPI_OK_INSERT_RETURNING</symbol>、<symbol>SPI_OK_DELETE_RETURNING</symbol>、または<symbol>SPI_OK_UPDATE_RETURNING</symbol>の場合、<literal>SPITupleTable *SPI_tuptable</literal>グローバルポインタを使用して、結果の行にアクセスすることができます。
また、一部のユーティリティコマンド（<command>EXPLAIN</>など）は行セットを返しますが、この場合も<literal>SPI_tuptable</>にはその結果が含まれます。
一部のユーティリティコマンド（<command>COPY</>, <command>CREATE TABLE AS</>）は行セットを返しません。
このため<literal>SPI_tuptable</>はNULLですが、<varname>SPI_processed</>の中で処理行数を返します。
  </para>

  <para>
<!--
   The structure <structname>SPITupleTable</structname> is defined
   thus:
-->
<structname>SPITupleTable</structname>構造体は以下のように定義されています。
<programlisting>
typedef struct
{
<!--
    MemoryContext tuptabcxt;    /* memory context of result table */
    uint32      alloced;        /* number of alloced vals */
    uint32      free;           /* number of free vals */
    TupleDesc   tupdesc;        /* row descriptor */
    HeapTuple  *vals;           /* rows */
-->
    MemoryContext tuptabcxt;    /* 結果テーブルのメモリコンテキスト */
    uint32      alloced;        /* 割り当て済みのvalsの数 */
    uint32      free;           /* 解放されたvalsの数 */
    TupleDesc   tupdesc;        /* 行記述子 */
    HeapTuple  *vals;           /* 行 */
} SPITupleTable;
</programlisting>
<!--
   <structfield>vals</> is an array of pointers to rows.  (The number
   of valid entries is given by <varname>SPI_processed</varname>.)
   <structfield>tupdesc</> is a row descriptor which you can pass to
   SPI functions dealing with rows.  <structfield>tuptabcxt</>,
   <structfield>alloced</>, and <structfield>free</> are internal
   fields not intended for use by SPI callers.
-->
<structfield>vals</>が行へのポインタの配列です
（有効な項目数は<varname>SPI_processed</varname>で判明します）。
<structfield>tupdesc</>は行を扱うSPI関数に渡すことができる行記述子です。
<structfield>tuptabcxt</>、<structfield>alloced</>、<structfield>free</>はSPI呼び出し元での使用を意図していない内部的なフィールドです。
  </para>

  <para>
<!--
   <function>SPI_finish</function> frees all
   <structname>SPITupleTable</>s allocated during the current
   procedure.  You can free a particular result table earlier, if you
   are done with it, by calling <function>SPI_freetuptable</function>.
-->
<function>SPI_finish</function>は、現在のプロシージャで割り当てられた<structname>SPITupleTable</>をすべて解放します。
<function>SPI_freetuptable</function>を呼び出して解放する場合、特定の結果テーブルを早めに解放することができます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      string containing command to execute
-->
実行するコマンドを含む文字列。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to return,
      or <literal>0</> for no limit
-->
返される行の最大数。無制限なら0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   If the execution of the command was successful then one of the
   following (nonnegative) values will be returned:
-->
コマンドの実行に成功した場合、以下のいずれかの（非負の）値が返されます。

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
      <para>
<!--
       if a <command>SELECT</command> (but not <command>SELECT
       INTO</>) was executed
-->
<command>SELECT</command>（<command>SELECT INTO</>を除く）が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <para>
<!--
       if a <command>SELECT INTO</command> was executed
-->
<command>SELECT INTO</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <para>
<!--
       if an <command>INSERT</command> was executed
-->
<command>INSERT</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <para>
<!--
       if a <command>DELETE</command> was executed
-->
<command>DELETE</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <para>
<!--
       if an <command>UPDATE</command> was executed
-->
<command>UPDATE</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <para>
<!--
       if an <command>INSERT RETURNING</command> was executed
-->
<command>INSERT RETURNING</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <para>
<!--
       if a <command>DELETE RETURNING</command> was executed
-->
<command>DELETE RETURNING</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <para>
<!--
       if an <command>UPDATE RETURNING</command> was executed
-->
<command>UPDATE RETURNING</command>が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <para>
<!--
       if a utility command (e.g., <command>CREATE TABLE</command>)
       was executed
-->
ユーティリティコマンド（<command>CREATE TABLE</command>など）が実行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <para>
<!--
       if the command was rewritten into another kind of command (e.g.,
       <command>UPDATE</command> became an <command>INSERT</command>) by a <link linkend="rules">rule</link>.
-->
<link linkend="rules">ルール</link>によって（例えば、<command>UPDATE</command>が<command>INSERT</command>になったような）あるコマンドが他の種類のコマンドに書き換えられた場合です。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   On error, one of the following negative values is returned:
-->
エラーの場合、以下のいずれかの負の値が返されます。

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
<!--
       if <parameter>command</parameter> is <symbol>NULL</symbol> or
       <parameter>count</parameter> is less than 0
-->
<parameter>command</parameter>が<symbol>NULL</symbol>、あるいは<parameter>count</parameter>が0未満の場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <para>
<!--
       if <command>COPY TO stdout</> or <command>COPY FROM stdin</>
       was attempted
-->
<command>COPY TO stdout</>あるいは<command>COPY FROM stdin</>が試行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <para>
<!--
       if a transaction manipulation command was attempted
       (<command>BEGIN</>,
       <command>COMMIT</>,
       <command>ROLLBACK</>,
       <command>SAVEPOINT</>,
       <command>PREPARE TRANSACTION</>,
       <command>COMMIT PREPARED</>,
       <command>ROLLBACK PREPARED</>,
       or any variant thereof)
-->
トランザクション操作を行うコマンド（<command>BEGIN</>、<command>COMMIT</>、<command>ROLLBACK</>、<command>SAVEPOINT</>、<command>PREPARE TRANSACTION</>、<command>COMMIT PREPARED</>、<command>ROLLBACK PREPARED</>、およびこれらの亜種）が試行された場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <para>
<!--
       if the command type is unknown (shouldn't happen)
-->
コマンド種類が不明な場合（起きてはなりません）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
<!--
       if called from an unconnected procedure
-->
未接続なプロシージャから呼び出された場合。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注意</title>

  <para>
<!--
   All SPI query-execution functions set both
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> (just the pointer, not the contents
   of the structure).  Save these two global variables into local
   procedure variables if you need to access the result table of
   <function>SPI_execute</function> or another query-execution function
   across later calls.
-->
SPI問い合わせ実行関数はすべて<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>の両方を変更します（ポインタのみで、構造体の内容は変更しません）。
<function>SPI_exec</function>や他の問い合わせ実行関数の結果テーブルを後の呼び出しでまたがってアクセスしたいのであれば、これら2つのグローバル変数を局所的なプロシージャ変数に保存してください。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-exec">
 <indexterm><primary>SPI_exec</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_exec</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_exec</refname>
<!--
  <refpurpose>execute a read/write command</refpurpose>
-->
  <refpurpose>読み書きコマンドを実行する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_exec</function> is the same as
   <function>SPI_execute</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</>.
-->
<function>SPI_exec</function>は、常に<parameter>read_only</parameter>パラメータを<literal>false</>とした<function>SPI_execute</function>と同じです。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      string containing command to execute
-->
実行するコマンドを含む文字列。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to return,
      or <literal>0</> for no limit
-->
返される行の最大数。無制限なら0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   See <function>SPI_execute</function>.
-->
<function>SPI_execute</function>を参照してください。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-with-args">
 <indexterm><primary>SPI_execute_with_args</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execute_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_with_args</refname>
<!--
  <refpurpose>execute a command with out-of-line parameters</refpurpose>
-->
  <refpurpose>行外のパラメータを持つコマンドを実行する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_execute_with_args</function> executes a command that might
   include references to externally supplied parameters.  The command text
   refers to a parameter as <literal>$<replaceable>n</></literal>, and
   the call specifies data types and values for each such symbol.
   <parameter>read_only</parameter> and <parameter>count</parameter> have
   the same interpretation as in <function>SPI_execute</function>.
-->
<function>SPI_execute_with_args</function>は外部から供給されるパラメータへの参照を含むコマンドを実行します。
コマンドテキストはパラメータを<literal>$<replaceable>n</></literal>として参照し、呼び出しはこうしたシンボル毎にデータ型と値を指定します。
<parameter>read_only</parameter>と<parameter>count</parameter>は<function>SPI_execute</function>と同じ解釈をします。
  </para>

  <para>
<!--
   The main advantage of this routine compared to
   <function>SPI_execute</function> is that data values can be inserted
   into the command without tedious quoting/escaping, and thus with much
   less risk of SQL-injection attacks.
-->
<function>SPI_execute</function>と比較して、このルーチンの主たる利点は、データ値を面倒な引用やエスケープを要せずコマンドに埋め込むことができることで、従ってSQLインジェクション攻撃の危険性を軽減します。
  </para>

  <para>
<!--
   Similar results can be achieved with <function>SPI_prepare</> followed by
   <function>SPI_execute_plan</function>; however, when using this function
   the query plan is always customized to the specific parameter values
   provided.
   For one-time query execution, this function should be preferred.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
-->
後に<function>SPI_execute_plan</function>が続いた<function>SPI_prepare</>でも同様の結果が得られますが、この関数を使用するときには、提供された特定のパラメータ値に対して問い合わせ計画が必ずカスタマイズされます。
１回限りの問い合わせ実行に対しては、この関数を選ぶべきです。
多くの異なったパラメータを持つ同一のコマンドを実行する場合、再計画のコストと独自計画による利益に依存して、どちらか一方の方法がより早くなります。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      command string
-->
コマンド文字列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
-->
入力パラメータ（<literal>$1</>、<literal>$2</>など）の数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
-->
パラメータのデータ型の<acronym>OID</acronym>を含む、<parameter>nargs</parameter>長の配列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
-->
実パラメータ値を含む、<parameter>nargs</parameter>長の配列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
-->
どのパラメータがnullかを記述する、<parameter>nargs</parameter>長の配列
     </para>

     <para>
<!--
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
-->
<parameter>nulls</parameter>が<symbol>NULL</symbol>であれば、<function>SPI_execute_with_args</function>はどのパラメータもnullでないと看做します。
さもなければ、<parameter>nulls</parameter>配列の各項目は、対応するパラメータが非NULLならば<literal>'&nbsp;'</>、対応するパラメータがNULLならば<literal>'n'</>です。
（後者の場合、<parameter>values</parameter>内の対応する値は注意されません。）
<parameter>nulls</parameter>はテキスト文字列ではなく単なる配列であることに注意してください。
<literal>'\0'</>終端は必要ありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to return,
      or <literal>0</> for no limit
-->
返される行の最大数。無制限なら0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The return value is the same as for <function>SPI_execute</function>.
-->
戻り値は<function>SPI_execute</function>と同じです。
  </para>

  <para>
<!--
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
-->
成功した場合<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>は<function>SPI_execute</function>と同様に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare">
 <indexterm><primary>SPI_prepare</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_prepare</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare</refname>
<!--
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
-->
  <refpurpose>文を準備する。文の実行はまだ行わない</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_prepare</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   The prepared statement can later be executed repeatedly using
   <function>SPI_execute_plan</function>.
-->
<function>SPI_prepare</function>は指定したコマンド用の準備済み文を作成し、それを返します。
しかし、そのコマンドは実行しません。
その準備済み文は<function>SPI_execute_plan</function>を使って後で繰り返し実行できます。
  </para>

  <para>
<!--
   When the same or a similar command is to be executed repeatedly, it
   is generally advantageous to perform parse analysis only once, and
   might furthermore be advantageous to re-use an execution plan for the
   command.
   <function>SPI_prepare</function> converts a command string into a
   prepared statement that encapsulates the results of parse analysis.
   The prepared statement also provides a place for caching an execution plan
   if it is found that generating a custom plan for each execution is not
   helpful.
-->
同じ、あるいは類似のコマンドが繰り返し実行される場合、一度だけ解析を計画作成を行うことには一般に利点があります。
また、コマンドの実行計画を再利用することにはさらに利点があるかも知れません。
<function>SPI_prepare</function>はコマンド文字列を、解析結果をカプセル化した準備済み文に変換します。
実行の度に独自計画を生成するのが役に立たないと分かった場合には、準備済み文は実行計画をキャッシュする場所も提供します。
  </para>

  <para>
<!--
   A prepared command can be generalized by writing parameters
   (<literal>$1</>, <literal>$2</>, etc.) in place of what would be
   constants in a normal command.  The actual values of the parameters
   are then specified when <function>SPI_execute_plan</function> is called.
   This allows the prepared command to be used over a wider range of
   situations than would be possible without parameters.
-->
プリペアドコマンドは、通常のコマンド内の定数となる場所を（<literal>$1</>、<literal>$2</>などの）パラメータで記述することで一般化することができます。
そしてパラメータの実際の値は、<function>SPI_execute_plan</function> が呼び出される時に指定されます。
これにより、プリペアドコマンドは、パラメータがない場合に比べ、より広範な状況で使用できるようになります。
  </para>

  <para>
<!--
   The statement returned by <function>SPI_prepare</function> can be used
   only in the current invocation of the procedure, since
   <function>SPI_finish</function> frees memory allocated for such a
   statement.  But the statement can be saved for longer using the functions
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
-->
<function>SPI_finish</function>は文用に割り当てられたメモリを解放しますので、<function>SPI_prepare</function>で返される文は、そのプロシージャの現在の呼び出し内でのみ使用することができます。
しかし、関数<function>SPI_keepplan</function>や<function>SPI_saveplan</function>を使用して長期間文を保存することもできます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      command string
-->
コマンド文字列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
-->
入力パラメータ（<literal>$1</>、<literal>$2</>など）の数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
<!--
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
-->
パラメータのデータ型の<acronym>OID</acronym>を持つ配列へのポインタ
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <function>SPI_prepare</function> returns a non-null pointer to an
   <type>SPIPlan</>, which is an opaque struct representing a prepared
   statement.  On error, <symbol>NULL</symbol> will be returned,
   and <varname>SPI_result</varname> will be set to one of the same
   error codes used by <function>SPI_execute</function>, except that
   it is set to <symbol>SPI_ERROR_ARGUMENT</symbol> if
   <parameter>command</parameter> is <symbol>NULL</symbol>, or if
   <parameter>nargs</> is less than 0, or if <parameter>nargs</> is
   greater than 0 and <parameter>argtypes</> is <symbol>NULL</symbol>.
-->
<function>SPI_prepare</function>は<type>SPIPlan</>への非NULLのポインタを返します。
ここで<type>SPIPlan</>は準備済み文を表すopaque構造体です
エラーの場合、<symbol>NULL</symbol>が返され、<function>SPI_execute</function>で使用されるエラーコードと同じコードの1つが<varname>SPI_result</varname>に設定されます。
しかし、<parameter>command</parameter>が<symbol>NULL</symbol>の場合や、<parameter>nargs</>が0未満の場合、<parameter>nargs</>が0より大きくかつ<parameter>argtypes</>が<symbol>NULL</symbol>の場合は、<symbol>SPI_ERROR_ARGUMENT</symbol>に設定されます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注意</title>

  <para>
<!--
   If no parameters are defined, a generic plan will be created at the
   first use of <function>SPI_execute_plan</function>, and used for all
   subsequent executions as well.  If there are parameters, the first few uses
   of <function>SPI_execute_plan</function> will generate custom plans
   that are specific to the supplied parameter values.  After enough uses
   of the same prepared statement, <function>SPI_execute_plan</function> will
   build a generic plan, and if that is not too much more expensive than the
   custom plans, it will start using the generic plan instead of re-planning
   each time.  If this default behavior is unsuitable, you can alter it by
   passing the <literal>CURSOR_OPT_GENERIC_PLAN</> or
   <literal>CURSOR_OPT_CUSTOM_PLAN</> flag to
   <function>SPI_prepare_cursor</function>, to force use of generic or custom
   plans respectively.
-->
パラメータが定義されていなければ、<function>SPI_execute_plan</function>が最初に使用された時に一般的な計画が作成され、以降の実行すべてでも利用されます。
パラメータがあれば、始めの何回かの<function>SPI_execute_plan</function>の使用で、与えられたパラメータの値に固有の独自計画が作成されます。
同じ準備済み文が十分に使用された後、<function>SPI_execute_plan</function>は一般的な計画を作成し、独自計画よりもそれほど高価でなければ、毎回再計画する代わりに一般的な計画を使い始めるようになります。
このデフォルトの動作が不適切であれば、<function>SPI_prepare_cursor</function>に<literal>CURSOR_OPT_GENERIC_PLAN</>または<literal>CURSOR_OPT_CUSTOM_PLAN</>フラグを設定することで、それぞれ一般的な計画か独自計画を強制的に利用するよう変更できます。
  </para>

  <para>
<!--
   Although the main point of a prepared statement is to avoid repeated parse
   analysis and planning of the statement, <productname>PostgreSQL</> will
   force re-analysis and re-planning of the statement before using it
   whenever database objects used in the statement have undergone
   definitional (DDL) changes since the previous use of the prepared
   statement.  Also, if the value of <xref linkend="guc-search-path"> changes
   from one use to the next, the statement will be re-parsed using the new
   <varname>search_path</>.  (This latter behavior is new as of
   <productname>PostgreSQL</productname> 9.3.)  See <xref
   linkend="sql-prepare"> for more information about the behavior of prepared
   statements.
-->
プリペアド文の主要な利点は、文の解析処理と計画作成処理の繰り返しを防止することですが、<productname>PostgreSQL</>では、以前にそのプリペアド文を使用してから、文の中で使用されているデータベースオブジェクトが定義（DDL）の変更を受けた時は常に再解析処理と計画再作成処理を強制します。
また、一度使用してから<xref linkend="guc-search-path">の値が変わった場合も、文は新しい<varname>search_path</>を使用して再解析されます。
（後者の振る舞いは<productname>PostgreSQL</productname> 9.3の時に追加されました。）
プリペアド文の動作については<xref linkend="sql-prepare">を参照してください。
  </para>

  <para>
<!--
   This function should only be called from a connected procedure.
-->
この関数は接続済みのプロシージャからのみ呼び出してください。
  </para>

  <para>
<!--
   <type>SPIPlanPtr</> is declared as a pointer to an opaque struct type in
   <filename>spi.h</>.  It is unwise to try to access its contents
   directly, as that makes your code much more likely to break in
   future revisions of <productname>PostgreSQL</productname>.
-->
<type>SPIPlanPtr</>は<filename>spi.h</>内でopaque構造体型へのポインタとして宣言されています。
たいていの場合将来のバージョンの<productname>PostgreSQL</productname>でそのコードが壊れてしまうため、この内容に直接アクセスすることは避けてください。
  </para>

  <para>
<!--
   The name <type>SPIPlanPtr</> is somewhat historical, since the data
   structure no longer necessarily contains an execution plan.
-->
そのデータ構造はもはや実行計画を含むとは限りませんので、<type>SPIPlanPtr</>という名前はいくらか歴史的なものです。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-cursor">
 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_prepare_cursor</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
<!--
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
-->
  <refpurpose>文を準備する。まだ実行は行わない</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_prepare_cursor</function> is identical to
   <function>SPI_prepare</function>, except that it also allows specification
   of the planner's <quote>cursor options</> parameter.  This is a bit mask
   having the values shown in <filename>nodes/parsenodes.h</filename>
   for the <structfield>options</> field of <structname>DeclareCursorStmt</>.
   <function>SPI_prepare</function> always takes the cursor options as zero.
-->
<function>SPI_prepare_cursor</function>は、プランナの<quote>カーソルオプション</>パラメータを指定できる点を除き、<function>SPI_prepare</function>と同じです。
これは<structname>DeclareCursorStmt</>の<structfield>options</>フィールド用に<filename>nodes/parsenodes.h</filename>で示された値を持つビットマスクです。
<function>SPI_prepare</function>では常にカーソルオプションをゼロとして扱います。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      command string
-->
コマンド文字列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
-->
入力パラメータ（<literal>$1</>、<literal>$2</>など）の数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
<!--
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
-->
パラメータのデータ型の<acronym>OID</acronym>を持つ配列へのポインタ
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
<!--
      integer bit mask of cursor options; zero produces default behavior
-->
カーソルオプションの整数ビットマスク。
ゼロはデフォルトの動作を引き起こします
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <function>SPI_prepare_cursor</function> has the same return conventions as
   <function>SPI_prepare</function>.
-->
<function>SPI_prepare_cursor</function>は<function>SPI_prepare</function>と同じ戻り値の規則を持ちます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

  <para>
<!--
   Useful bits to set in <parameter>cursorOptions</> include
   <symbol>CURSOR_OPT_SCROLL</symbol>,
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>,
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>,
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>, and
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>.  Note in particular that
   <symbol>CURSOR_OPT_HOLD</symbol> is ignored.
-->
<parameter>cursorOptions</>に指定できるビットには、<symbol>CURSOR_OPT_SCROLL</symbol>、<symbol>CURSOR_OPT_NO_SCROLL</symbol>、<symbol>CURSOR_OPT_FAST_PLAN</symbol>、<symbol>CURSOR_OPT_GENERIC_PLAN</symbol>、<symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>があります。
特に<symbol>CURSOR_OPT_HOLD</symbol>は無視される点に注意してください。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-params">
 <indexterm><primary>SPI_prepare_params</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_prepare_params</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_prepare_params</refname>
<!--
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
-->
  <refpurpose>文を準備する。まだ実行は行わない</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_prepare_params</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   This function is equivalent to <function>SPI_prepare_cursor</function>,
   with the addition that the caller can specify parser hook functions
   to control the parsing of external parameter references.
-->
<function>SPI_prepare_params</function>は指定したコマンドの準備済み文を作成し返します。
しかしそのコマンドを実行しません。
この関数は<function>SPI_prepare_cursor</function>と同じですが、呼び出し元が外部パラメータ参照の解析を制御するパーサフック関数を指定できる点が追加されています。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      command string
-->
コマンド文字列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
     <para>
<!--
      Parser hook setup function
-->
パーサフック設定関数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
     <para>
<!--
      pass-through argument for <parameter>parserSetup</parameter>
-->
<parameter>parserSetup</parameter>に渡される引数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
<!--
      integer bit mask of cursor options; zero produces default behavior
-->
カーソルオプションの整数ビットマスク。
ゼロはデフォルトの動作を引き起こします
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <function>SPI_prepare_params</function> has the same return conventions as
   <function>SPI_prepare</function>.
-->
<function>SPI_prepare_params</function>は<function>SPI_prepare</function>と同じ戻り値の規則を持ちます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargcount">
 <indexterm><primary>SPI_getargcount</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getargcount</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getargcount</refname>
<!--
  <refpurpose>return the number of arguments needed by a statement
  prepared by <function>SPI_prepare</function></refpurpose>
-->
  <refpurpose>
<function>SPI_prepare</function>により準備した文に必要とされる引数の数を返す
  </refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_getargcount</function> returns the number of arguments needed
   to execute a statement prepared by <function>SPI_prepare</function>.
-->
<function>SPI_getargcount</function>は、<function>SPI_prepare</function>により準備された文を実行する時に必要とされる引数の数を返します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文です。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>
  <para>
<!--
    The count of expected arguments for the <parameter>plan</parameter>.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and -1 is returned.
-->
<parameter>plan</parameter>で想定される引数の数です。
<parameter>plan</parameter>が<symbol>NULL</symbol>または無効な場合は<varname>SPI_result</varname>に<symbol>SPI_ERROR_ARGUMENT</symbol>が設定され、-1が返されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargtypeid">
 <indexterm><primary>SPI_getargtypeid</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getargtypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getargtypeid</refname>
<!--
  <refpurpose>return the data type OID for an argument of
  a statement prepared by <function>SPI_prepare</function></refpurpose>
-->
  <refpurpose>
<function>SPI_prepare</function>で準備された文で指定される引数のデータ型のOIDを返す
  </refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_getargtypeid</function> returns the OID representing the type
   for the <parameter>argIndex</parameter>'th argument of a statement prepared by
   <function>SPI_prepare</function>. First argument is at index zero.
-->
<function>SPI_getargtypeid</function>は、<function>SPI_prepare</function>で準備された文における<parameter>argIndex</parameter>番目の引数の型を表すOIDを返します。
インデックス0は最初の引数を示します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>argIndex</parameter></literal></term>
    <listitem>
     <para>
<!--
      zero based index of the argument
-->
0から始まる引数のインデックス
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>
  <para>
<!--
    The type OID of the argument at the given index.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or <parameter>argIndex</parameter> is less than 0 or
    not less than the number of arguments declared for the
    <parameter>plan</parameter>,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and <symbol>InvalidOid</symbol> is returned.
-->
指定したインデックスにおける引数の型OIDです。
<parameter>plan</parameter>が<symbol>NULL</symbol>または無効、あるいは<parameter>argIndex</parameter>が0未満、<parameter>plan</parameter>で宣言された引数の数以上の場合、<varname>SPI_result</varname>に<symbol>SPI_ERROR_ARGUMENT</symbol>が設定され、<symbol>InvalidOid</symbol>が返されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-is-cursor-plan">
 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_is_cursor_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
<!--
  <refpurpose>return <symbol>true</symbol> if a statement
  prepared by <function>SPI_prepare</function> can be used with
  <function>SPI_cursor_open</function></refpurpose>
-->
  <refpurpose>
<function>SPI_prepare</function>で準備された文が<function>SPI_cursor_open</function>で使用できる場合に<symbol>true</symbol>を返す
  </refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_is_cursor_plan</function> returns <symbol>true</symbol>
   if a statement prepared by <function>SPI_prepare</function> can be passed
   as an argument to <function>SPI_cursor_open</function>, or
   <symbol>false</symbol> if that is not the case. The criteria are that the
   <parameter>plan</parameter> represents one single command and that this
   command returns tuples to the caller; for example, <command>SELECT</>
   is allowed unless it contains an <literal>INTO</> clause, and
   <command>UPDATE</> is allowed only if it contains a <literal>RETURNING</>
   clause.
-->
<function>SPI_prepare</function>で準備済み文が<function>SPI_cursor_open</function>への引数として渡すことができる場合、<function>SPI_is_cursor_plan</function>は<symbol>true</symbol>を返します。
渡すことができない場合は<symbol>false</symbol>を返します。
この基準は、<parameter>plan</parameter>が単一のコマンドであり、かつ、そのコマンドが呼び出し元にタプルを返すことです。
例えば、<literal>INTO</>句を含んでいない<command>SELECT</>は可能です。
そして、<literal>RETURNING</>句を含む場合のみ<command>UPDATE</>も可能です。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>
  <para>
<!--
    <symbol>true</symbol> or <symbol>false</symbol> to indicate if the
    <parameter>plan</parameter> can produce a cursor or not, with
    <varname>SPI_result</varname> set to zero.
    If it is not possible to determine the answer (for example,
    if the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or if called when not connected to SPI), then
    <varname>SPI_result</varname> is set to a suitable error code
    and <symbol>false</symbol> is returned.
-->
<parameter>plan</parameter>がカーソルを生成することができるかどうかを示す<symbol>true</symbol>もしくは<symbol>false</symbol>です。
そして<varname>SPI_result</varname>をゼロに設定します。
解答を決定することができない場合（例えば<parameter>plan</parameter>が<symbol>NULL</symbol>、または無効な場合、もしくはSPI未接続時に呼び出された場合）は<varname>SPI_result</varname>に適切なエラーコードが設定され、<symbol>false</symbol>が返されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan">
 <indexterm><primary>SPI_execute_plan</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execute_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan</refname>
<!--
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
-->
  <refpurpose><function>SPI_prepare</function>で準備された文を実行する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_execute_plan</function> executes a statement prepared by
   <function>SPI_prepare</function> or one of its siblings.
   <parameter>read_only</parameter> and
   <parameter>count</parameter> have the same interpretation as in
   <function>SPI_execute</function>.
-->
<function>SPI_execute_plan</function>は、<function>SPI_prepare</function>もしくは類似の関数で準備された文を実行します。
<parameter>read_only</parameter>と<parameter>count</parameter>は<function>SPI_execute</function>と同様の解釈がなされます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
<!--
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
-->
実パラメータ値の配列。
文の引数の数と同じ長さでなければなりません
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
<!--
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
-->
どのパラメータがNULLであるかを示す配列。
文の引数の数と同じ長さでなければなりません。
     </para>

     <para>
<!--
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_plan</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
-->
<parameter>nulls</parameter>が<symbol>NULL</symbol>の場合、<function>SPI_execute_plan</function>はすべてのパラメータがNULLではないとみなします。
さもなければ、<parameter>nulls</parameter>配列の各項目は、対応するパラメータが非NULLならば<literal>'&nbsp;'</>、対応するパラメータがNULLならば<literal>'n'</>です。
（後者の場合、<parameter>values</parameter>内の対応する値は注意されません。）
<parameter>nulls</parameter>はテキスト文字列ではなく単なる配列であることに注意してください。
<literal>'\0'</>終端は必要ありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to return,
      or <literal>0</> for no limit
-->
返される行の最大数。無制限なら0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The return value is the same as for <function>SPI_execute</function>,
   with the following additional possible error (negative) results:
-->
戻り値は、<function>SPI_execute</function>同様のものに加え、以下のエラー（負）の結果を取ることがあります。

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
<!--
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
       or <parameter>count</parameter> is less than 0
-->
<parameter>plan</parameter>が<symbol>NULL</symbol>または無効、あるいは、<parameter>count</parameter>が0未満の場合
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
<!--
       if <parameter>values</parameter> is <symbol>NULL</symbol> and
       <parameter>plan</parameter> was prepared with some parameters
-->
<parameter>values</parameter>が<symbol>NULL</symbol>、かつ、<parameter>plan</parameter>がパラメータ付きで準備された場合
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
-->
成功時、<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>が<function>SPI_execute</function>同様に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-with-paramlist">
 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
<!--
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
-->
  <refpurpose><function>SPI_prepare</function>で準備された文を実行する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_execute_plan_with_paramlist</function> executes a statement
   prepared by <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_execute_plan</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</>.
-->
<function>SPI_execute_plan_with_paramlist</function>は<function>SPI_prepare</function>で準備された文を実行します。
この関数は<function>SPI_execute_plan</function>と同じですが、問い合わせに渡されるパラメータ値に関する情報が別途存在する点が異なります。
<literal>ParamListInfo</>表現は、すでに利用可能な形式で値を渡すために便利です。
また<literal>ParamListInfo</>で指定されたフック関数経由での動的なパラメータ群の使用をサポートします。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
<!--
      data structure containing parameter types and values; NULL if none
-->
パラメータの型と値からなるデータ構造。
なければヌル。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to return,
      or <literal>0</> for no limit
-->
返される行の最大数。無制限なら0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The return value is the same as for <function>SPI_execute_plan</function>.
-->
戻り値は<function>SPI_execute_plan</function>と同じです。
  </para>

  <para>
<!--
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute_plan</function> if successful.
-->
成功時、<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>が<function>SPI_execute_plan</function>同様に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execp">
 <indexterm><primary>SPI_execp</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_execp</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_execp</refname>
<!--
  <refpurpose>execute a statement in read/write mode</refpurpose>
-->
  <refpurpose>読み書きモードで文を実行する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_execp</function> is the same as
   <function>SPI_execute_plan</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</>.
-->
<function>SPI_execp</function>は、常に<parameter>read_only</parameter>パラメータを<literal>false</>とした<function>SPI_execute_plan</function>と同じです。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
<!--
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
-->
実パラメータ値の配列。
文の引数の数と同じ長さでなければなりません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
<!--
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
-->
どのパラメータがNULLであるかを示す配列。
文の引数の数と同じ長さでなければなりません。
     </para>

     <para>
<!--
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execp</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
-->
<parameter>nulls</parameter>が<symbol>NULL</symbol>の場合、<function>SPI_execp</function>はすべてのパラメータがNULLではないとみなします。
さもなければ、<parameter>nulls</parameter>配列の各項目は、対応するパラメータが非NULLならば<literal>'&nbsp;'</>、対応するパラメータがNULLならば<literal>'n'</>です。
（後者の場合、<parameter>values</parameter>内の対応する値は注意されません。）
<parameter>nulls</parameter>はテキスト文字列ではなく単なる配列であることに注意してください。
<literal>'\0'</>終端は必要ありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to return,
      or <literal>0</> for no limit
-->
返される行の最大数。無制限なら0。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   See <function>SPI_execute_plan</function>.
-->
<function>SPI_execute_plan</function>を参照してください。
  </para>

  <para>
<!--
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
-->
成功時、<function>SPI_execute</function>同様に<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>が設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open">
 <indexterm><primary>SPI_cursor_open</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open</refname>
<!--
  <refpurpose>set up a cursor using a statement created with <function>SPI_prepare</function></refpurpose>
-->
  <refpurpose><function>SPI_prepare</function>で作成された文を使用したカーソルを設定する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_open</function> sets up a cursor (internally,
   a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.  The parameters have the same
   meanings as the corresponding parameters to
   <function>SPI_execute_plan</function>.
-->
<function>SPI_cursor_open</function>は、<function>SPI_prepare</function>によって準備された文を実行するカーソル（内部的にはポータル）を設定します。
このパラメータは<function>SPI_execute_plan</function>の対応するパラメータと同じ意味を持ちます。
  </para>

  <para>
<!--
   Using a cursor instead of executing the statement directly has two
   benefits.  First, the result rows can be retrieved a few at a time,
   avoiding memory overrun for queries that return many rows.  Second,
   a portal can outlive the current procedure (it can, in fact, live
   to the end of the current transaction).  Returning the portal name
   to the procedure's caller provides a way of returning a row set as
   result.
-->
文を直接実行するのではなくカーソルを使用することには2つの利点があります。
1つ目は、結果行を一度に少なく取り出し、多くの行を返す問い合わせでのメモリの過使用を防ぐことができる点です。
2つ目は、ポータルは現在のプロシージャの外部でも有効である点です（実際、現在のトランザクションの終端まで有効とすることができます）。
プロシージャの呼び出し元にポータルの名前を返すことで、結果として行セットを返す手段を提供します。
  </para>

  <para>
<!--
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
-->
渡されるパラメータデータはカーソルのポータルにコピーされます。
そのため、カーソルが存在している間にそのデータを解放することができます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
<!--
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
-->
ポータルの名前、あるいはシステムに名前を決定させる場合は<symbol>NULL</symbol>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
<!--
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
-->
実パラメータ値の配列。
文の引数の数と同じ長さでなければなりません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
<!--
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
-->
どのパラメータがNULLであるかを示す配列。
文の引数の数と同じ長さでなければなりません。
     </para>

     <para>
<!--
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
-->
<parameter>nulls</parameter>が<symbol>NULL</>の場合、<function>SPI_curcor_open</function>は全てのパラメータがNULLではないとみなします。
さもなければ、<parameter>nulls</parameter>配列の各項目は、対応するパラメータが非NULLならば<literal>'&nbsp;'</>、対応するパラメータがNULLならば<literal>'n'</>です。
（後者の場合、<parameter>values</parameter>内の対応する値は注意されません。）
<parameter>nulls</parameter>はテキスト文字列ではなく単なる配列であることに注意してください。
<literal>'\0'</>終端は必要ありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
-->
カーソルを含むポータルへのポインタ。
戻り値の規約にはエラーを表すものがないことに注意してください。
エラーはすべて<function>elog</>経由で報告されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-args">
 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
<!--
  <refpurpose>set up a cursor using a query and parameters</refpurpose>
-->
  <refpurpose>問い合わせとパラメータを使ってカーソルを設定する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_open_with_args</function> sets up a cursor
   (internally, a portal) that will execute the specified query.
   Most of the parameters have the same meanings as the corresponding
   parameters to <function>SPI_prepare_cursor</function>
   and <function>SPI_cursor_open</function>.
-->
<function>SPI_cursor_open_with_args</function>は特定の問い合わせを実行するカーソル（内部的にはポータル）を設定します。
ほとんどのパラメータは<function>SPI_prepare_cursor</function>と<function>SPI_cursor_open</function>に対応するパラメータと同じ意味を持っています。
  </para>

  <para>
<!--
   For one-time query execution, this function should be preferred
   over <function>SPI_prepare_cursor</function> followed by
   <function>SPI_cursor_open</function>.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
-->
１回限りの問い合わせ実行に対しては、後に<function>SPI_cursor_open</function>が続いた<function>SPI_prepare_cursor</function>よりも、この関数を選ぶべきです。
多くの異なったパラメータを持つ同一のコマンドを実行する場合、再計画のコストと独自計画による利益に依存して、どちらか一方の方法がより早くなります。
  </para>

  <para>
<!--
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
-->
渡されたパラメータデータはカーソルのポータルにコピーされますので、カーソルが存在している間は解放することができます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
<!--
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
-->
ポータルの名前、またはシステムに名前を選択させる<symbol>NULL</symbol>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
     <para>
<!--
      command string
-->
コマンド文字列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of input parameters (<literal>$1</>, <literal>$2</>, etc.)
-->
入力パラメータ（<literal>$1</>、<literal>$2</>など）の数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
-->
パラメータのデータ型の<acronym>OID</acronym>を含む、<parameter>nargs</parameter>長の配列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
-->
実パラメータ値を含む、<parameter>nargs</parameter>長の配列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
-->
どのパラメータがnullかを記述する、<parameter>nargs</parameter>長の配列
     </para>

     <para>
<!--
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding parameter
      value is non-null, or <literal>'n'</> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</> terminator.
-->
<parameter>nulls</parameter>が<symbol>NULL</symbol>であれば、<function>SPI_cursor_open_with_args</function>はどのパラメータもnullでないとみなします。
さもなければ、<parameter>nulls</parameter>配列の各項目は、対応するパラメータが非NULLならば<literal>'&nbsp;'</>、対応するパラメータがNULLならば<literal>'n'</>です。
（後者の場合、<parameter>values</parameter>内の対応する値は注意されません。）
<parameter>nulls</parameter>はテキスト文字列ではなく単なる配列であることに注意してください。
<literal>'\0'</>終端は必要ありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
     <para>
<!--
      integer bit mask of cursor options; zero produces default behavior
-->
カーソルオプションの整数ビットマスク。ゼロの場合はデフォルトの動作
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
-->
カーソルを含んだポータルへのポインタ。
エラーを返す規約がないことに注意してください。
すべてのエラーは<function>elog</>で報告されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-paramlist">
 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
<!--
  <refpurpose>set up a cursor using parameters</refpurpose>
-->
  <refpurpose>パラメータを使ってカーソルを設定する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_open_with_paramlist</function> sets up a cursor
   (internally, a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_cursor_open</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</>.
-->
<function>SPI_cursor_open_with_paramlist</function>は<function>SPI_prepare</function>で準備された文を実行するカーソル(内部的にはポータル)を設定します。
この関数は<function>SPI_cursor_open</function>と同じですが、問い合わせに渡されるパラメータ値に関する情報が別途存在することが異なります。
<literal>ParamListInfo</>表現は、すでに利用可能な形式で値を渡すために便利です。
また<literal>ParamListInfo</>で指定されたフック関数経由での動的なパラメータ群の使用をサポートします。
  </para>

  <para>
<!--
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
-->
渡されるパラメータデータはカーソルのポータルにコピーされます。
そのため、カーソルが存在している間にそのデータを解放することができます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
<!--
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
-->
ポータルの名前、あるいはシステムに名前を決定させる場合は<symbol>NULL</symbol>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      prepared statement (returned by <function>SPI_prepare</function>)
-->
（<function>SPI_prepare</function>で返される）準備済み文
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
     <para>
<!--
      data structure containing parameter types and values; NULL if none
-->
パラメータの型と値からなるデータ構造。
なければヌル。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!--
     <para><literal>true</> for read-only execution</para>
-->
     <para>
読み取りのみの実行の場合<literal>true</>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</>.
-->
カーソルを含むポータルへのポインタ。
戻り値の規約にはエラーを表すものがないことに注意してください。
エラーはすべて<function>elog</>経由で報告されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-find">
 <indexterm><primary>SPI_cursor_find</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_find</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_find</refname>
<!--
  <refpurpose>find an existing cursor by name</refpurpose>
-->
  <refpurpose>既存のカーソルを名前で検索する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_find</function> finds an existing portal by
   name.  This is primarily useful to resolve a cursor name returned
   as text by some other function.
-->
<function>SPI_cursor_find</function>は既存のカーソルを名前で検索します。
これは主に、他の何らかの関数でテキストとして返されたカーソル名の名前解決の際に使用されます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
     <para>
<!--
      name of the portal
-->
ポータルの名前
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   pointer to the portal with the specified name, or
   <symbol>NULL</symbol> if none was found
-->
指定された名前のポータルへのポインタ。見つからない場合は<symbol>NULL</symbol>です。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-fetch">
 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
<!--
  <refpurpose>fetch some rows from a cursor</refpurpose>
-->
  <refpurpose>カーソルから数行を取り出す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to a subset of the SQL command
   <command>FETCH</> (see <function>SPI_scroll_cursor_fetch</function>
   for more functionality).
-->
<function>SPI_cursor_fetch</function>はカーソルから数行を取り出します。
これは、<command>FETCH</> SQLコマンドと部分的に等価です。
（詳細機能については<function>SPI_scroll_cursor_fetch</function>を参照してください。）
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
<!--
      portal containing the cursor
-->
カーソルを持つポータル
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <para>
<!--
      true for fetch forward, false for fetch backward
-->
前方方向の取り出しの場合、真。後方方向の場合は偽。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to fetch
-->
取り出す最大行数。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
-->
成功時、<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>が<function>SPI_execute</function>同様に設定されます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

  <para>
<!--
   Fetching backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
-->
カーソルの計画が <symbol>CURSOR_OPT_SCROLL</symbol>オプションを付けて作成されなかった場合、後方方向の取り出しは失敗する可能性があります。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-move">
 <indexterm><primary>SPI_cursor_move</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_move</refname>
<!--
  <refpurpose>move a cursor</refpurpose>
-->
  <refpurpose>カーソルを移動する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to a subset of the SQL command
   <command>MOVE</> (see <function>SPI_scroll_cursor_move</function>
   for more functionality).
-->
<function>SPI_cursor_move</function>はカーソル内で、数行を飛ばします。
これは<command>MOVE</> SQLコマンドと部分的に等価です。
（詳細機能については<function>SPI_scroll_cursor_move</function>を参照してください。）
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
<!--
      portal containing the cursor
-->
カーソルを持つポータル
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
     <para>
<!--
      true for move forward, false for move backward
-->
前方方向の移動の場合、真。後方方向の場合は偽。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      maximum number of rows to move
-->
移動する最大行数。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

  <para>
<!--
   Moving backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
-->
カーソルの計画が<symbol>CURSOR_OPT_SCROLL</symbol>オプション付きで作成されなかった場合、後方方向への移動は失敗する可能性があります。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-fetch">
 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
<!--
  <refpurpose>fetch some rows from a cursor</refpurpose>
-->
  <refpurpose>カーソルから一部の行を取り出す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_scroll_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to the SQL command <command>FETCH</>.
-->
<function>SPI_scroll_cursor_fetch</function>はカーソルから行の一部を取り出します。
これはSQLコマンド<command>FETCH</>と等価です。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
<!--
      portal containing the cursor
-->
カーソルを含むポータル
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
     <para>
<!--
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
-->
<symbol>FETCH_FORWARD</symbol>、<symbol>FETCH_BACKWARD</symbol>、<symbol>FETCH_ABSOLUTE</symbol>、<symbol>FETCH_RELATIVE</symbol>のいずれか
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of rows to fetch for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to fetch for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to fetch for
      <symbol>FETCH_RELATIVE</symbol>
-->
<symbol>FETCH_FORWARD</symbol>または<symbol>FETCH_BACKWARD</symbol>では取り出す行数。
<symbol>FETCH_ABSOLUTE</symbol>では取り出す行の絶対番号。
<symbol>FETCH_RELATIVE</symbol>では取り出す行の相対的番号。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
-->
成功時、<function>SPI_execute</function>同様に<varname>SPI_processed</varname>と<varname>SPI_tuptable</varname>が設定されます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

  <para>
<!--
   See the SQL <xref linkend="sql-fetch"> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
-->
<parameter>direction</parameter>パラメータおよび<parameter>count</parameter>パラメータの解釈の詳細についてはSQL <xref linkend="sql-fetch">コマンドを参照してください。
  </para>

  <para>
<!--
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
-->
カーソルの計画が<symbol>CURSOR_OPT_SCROLL</symbol>オプション付きで作成されていない場合、<symbol>FETCH_FORWARD</symbol>以外の方向値は失敗する可能性があります。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-move">
 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
<!--
  <refpurpose>move a cursor</refpurpose>
-->
  <refpurpose>カーソルを移動する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_scroll_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to the SQL command
   <command>MOVE</>.
-->
<function>SPI_scroll_cursor_move</function>はカーソル内の行の一部を飛ばします。
これはSQLコマンド<command>MOVE</>と等価です。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
<!--
      portal containing the cursor
-->
カーソルを含むポータル
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
     <para>
<!--
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
-->
<symbol>FETCH_FORWARD</symbol>、<symbol>FETCH_BACKWARD</symbol>、<symbol>FETCH_ABSOLUTE</symbol>、<symbol>FETCH_RELATIVE</symbol>のいずれか
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of rows to move for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to move to for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to move to for
      <symbol>FETCH_RELATIVE</symbol>
-->
<symbol>FETCH_FORWARD</symbol>または<symbol>FETCH_BACKWARD</symbol>では移動する行数。
<symbol>FETCH_ABSOLUTE</symbol>では移動する行の絶対番号。
<symbol>FETCH_RELATIVE</symbol>では移動する行の相対的番号。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <varname>SPI_processed</varname> is set as in
   <function>SPI_execute</function> if successful.
   <varname>SPI_tuptable</varname> is set to <symbol>NULL</>, since
   no rows are returned by this function.
-->
成功時、<function>SPI_execute</function>同様に<varname>SPI_processed</varname>が設定されます。
この関数は行を返しませんので、<varname>SPI_tuptable</varname>は<symbol>NULL</>に設定されます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

  <para>
<!--
   See the SQL <xref linkend="sql-fetch"> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
-->
<parameter>direction</parameter>パラメータおよび<parameter>count</parameter>パラメータの解釈の詳細についてはSQL <xref linkend="sql-fetch">コマンドを参照してください。
  </para>

  <para>
<!--
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
-->
カーソルの計画が<symbol>CURSOR_OPT_SCROLL</symbol>オプション付きで作成されていない場合、<symbol>FETCH_FORWARD</symbol>以外の方向値は失敗する可能性があります。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-close">
 <indexterm><primary>SPI_cursor_close</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_cursor_close</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_cursor_close</refname>
<!--
  <refpurpose>close a cursor</refpurpose>
-->
  <refpurpose>カーソルを閉じる</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_cursor_close</function> closes a previously created
   cursor and releases its portal storage.
-->
<function>SPI_cursor_close</function>は事前に作成されたカーソルを閉じ、そのポータル用の領域を解放します。
  </para>

  <para>
<!--
   All open cursors are closed automatically at the end of a
   transaction.  <function>SPI_cursor_close</function> need only be
   invoked if it is desirable to release resources sooner.
-->
トランザクションの終了時に全ての開いているカーソルが自動的に閉ざされます。
<function>SPI_cursor_close</function>は、リソースの解放をより早めに行いたい場合にのみ呼び出す必要があります。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
     <para>
<!--
      portal containing the cursor
-->
カーソルを持つポータル
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-keepplan">
 <indexterm><primary>SPI_keepplan</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_keepplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_keepplan</refname>
<!--
  <refpurpose>save a prepared statement</refpurpose>
-->
  <refpurpose>準備済み文を保持する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_keepplan</function> saves a passed statement (prepared by
   <function>SPI_prepare</function>) so that it will not be freed
   by <function>SPI_finish</function> nor by the transaction manager.
   This gives you the ability to reuse prepared statements in the subsequent
   invocations of your procedure in the current session.
-->
<function>SPI_keepplan</function>は渡された（<function>SPI_prepare</function>で準備された）文を<function>SPI_finish</function>とトランザクションマネージャで解放されないメモリ内に保存します。
これは、現在のセッションにおける、その後のプロシージャの呼び出しで準備済み文を再利用できる機能を提供します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      the prepared statement to be saved
-->
保存する準備済み文
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
-->
成功時は0。
<parameter>plan</parameter>が<symbol>NULL</symbol>または無効な場合は<symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注意</title>

  <para>
<!--
   The passed-in statement is relocated to permanent storage by means
   of pointer adjustment (no data copying is required).  If you later
   wish to delete it, use <function>SPI_freeplan</function> on it.
-->
渡された文はポインタの調整により永続的記憶領域に再配置されます(データコピーは不要です)。
後ほど削除したければ、<function>SPI_freeplan</function>を実行してください。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-saveplan">
 <indexterm><primary>SPI_saveplan</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_saveplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_saveplan</refname>
<!--
  <refpurpose>save a prepared statement</refpurpose>
-->
  <refpurpose>準備済み文を保存する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_saveplan</function> copies a passed statement (prepared by
   <function>SPI_prepare</function>) into memory that will not be freed
   by <function>SPI_finish</function> nor by the transaction manager,
   and returns a pointer to the copied statement.  This gives you the
   ability to reuse prepared statements in the subsequent invocations of
   your procedure in the current session.
-->
<function>SPI_saveplan</function>は渡された（<function>SPI_prepare</function>で準備された）文を<function>SPI_finish</function>とトランザクションマネージャで解放されないメモリ内にコピーします。
そして、コピーした文のポインタを返します。
これは、現在のセッションにおける、その後のプロシージャの呼び出しで準備済み文を再利用できる機能を提供します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      the prepared statement to be saved
-->
保存する準備済み文
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   Pointer to the copied statement; or <symbol>NULL</symbol> if unsuccessful.
   On error, <varname>SPI_result</varname> is set thus:
-->
コピーした文へのポインタ。
失敗した場合は<symbol>NULL</symbol>です。
エラー時、<varname>SPI_result</varname>は以下のように設定されます。

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
<!--
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid
-->
<parameter>plan</parameter>が<symbol>NULL</symbol>、または無効な場合
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
<!--
       if called from an unconnected procedure
-->
未接続のプロシージャから呼び出された場合
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
  <title>注意</title>

  <para>
<!--
   The originally passed-in statement is not freed, so you might wish to do
   <function>SPI_freeplan</function> on it to avoid leaking memory
   until <function>SPI_finish</>.
-->
渡された元の文は解放されません。
ですので、<function>SPI_finish</>を行うまでのメモリリークを防ぎたければ<function>SPI_freeplan</function>を実行してください。
  </para>

  <para>
<!--
   In most cases, <function>SPI_keepplan</function> is preferred to this
   function, since it accomplishes largely the same result without needing
   to physically copy the prepared statement's data structures.
-->
準備済み文のデータ構造を物理的にコピーする必要なく、ほとんど同じ結果をもたらしますので、たいていの場合、この関数よりも<function>SPI_keepplan</function>の方が好ましいです。
  </para>
 </refsect1>
</refentry>

</sect1>

<sect1 id="spi-interface-support">
<!--
 <title>Interface Support Functions</title>
-->
 <title>インタフェースサポート関数</title>

 <para>
<!--
  The functions described here provide an interface for extracting
  information from result sets returned by <function>SPI_execute</> and
  other SPI functions.
-->
以下で説明する関数は、<function>SPI_execute</>や他のSPI関数で返される結果セットから情報を取り出すためのインタフェースを提供します。
 </para>

 <para>
<!--
  All functions described in this section can be used by both
  connected and unconnected procedures.
-->
本節で説明する関数は全て、接続、未接続のプロシージャのどちらからでも使用することができます。
 </para>

<!-- *********************************************** -->

<refentry id="spi-spi-fname">
 <indexterm><primary>SPI_fname</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_fname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_fname</refname>
<!--
  <refpurpose>determine the column name for the specified column number</refpurpose>
-->
  <refpurpose>指定した列番号に対する列名を決定する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_fname</function> returns a copy of the column name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
-->
<function>SPI_fname</function> は指定した列の列名のコピーを返します
（名前のコピーが不要になった場合<function>pfree</function>を使用してその領域を解放することができます）。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row description
-->
入力行の記述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
<!--
      column number (count starts at 1)
-->
（1から始まる）列番号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The column name; <symbol>NULL</symbol> if
   <parameter>colnumber</parameter> is out of range.
   <varname>SPI_result</varname> set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
-->
列の名前です。
<parameter>colnumber</parameter>が範囲外の場合は<symbol>NULL</symbol>です。
エラー時、<varname>SPI_result</varname>は<symbol>SPI_ERROR_NOATTRIBUTE</symbol>に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-fnumber">
 <indexterm><primary>SPI_fnumber</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_fnumber</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_fnumber</refname>
<!--
  <refpurpose>determine the column number for the specified column name</refpurpose>
-->
  <refpurpose>指定した列名から列番号を決定する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_fnumber</function> returns the column number for the
   column with the specified name.
-->
<function>SPI_fnumber</function>は指定した名前の列の列番号を返します。
  </para>

  <para>
<!--
   If <parameter>colname</parameter> refers to a system column (e.g.,
   <literal>oid</>) then the appropriate negative column number will
   be returned.  The caller should be careful to test the return value
   for exact equality to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> to
   detect an error; testing the result for less than or equal to 0 is
   not correct unless system columns should be rejected.
-->
<parameter>colname</parameter>が（<literal>oid</>などの）システム列を参照する場合、適切な負の列番号が返されます。
呼び出し元は、エラーを検知するために戻り値が<symbol>SPI_ERROR_NOATTRIBUTE</symbol>と正確に同一であるかどうかを注意して検査しなければなりません。
システム列を拒絶させたくなければ、結果が0あるいは0未満かを検査するという方法は、正しくありません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row description
-->
入力行の記述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>colname</parameter></literal></term>
    <listitem>
     <para>
<!--
      column name
-->
列名
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   Column number (count starts at 1), or
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> if the named column was not
   found.
-->
（1から始まる）列番号。
指定された名前の列が見つからなければ、<symbol>SPI_ERROR_NOATTRIBUTE</symbol>です。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getvalue">
 <indexterm><primary>SPI_getvalue</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getvalue</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getvalue</refname>
<!--
  <refpurpose>return the string value of the specified column</refpurpose>
-->
  <refpurpose>指定された列の文字列値を返す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_getvalue</function> returns the string representation
   of the value of the specified column.
-->
<function>SPI_getvalue</function>は指定された列の値の文字列表現を返します。
  </para>

  <para>
<!--
   The result is returned in memory allocated using
   <function>palloc</function>.  (You can use
   <function>pfree</function> to release the memory when you don't
   need it anymore.)
-->
結果は、<function>palloc</function>を使用して割り当てられたメモリ内に返されます
（不要になった段階で、<function>pfree</function>を使用してメモリを解放することができます）。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row to be examined
-->
検査対象の入力行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row description
-->
入力行の記述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
<!--
      column number (count starts at 1)
-->
（1から始まる）列番号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   Column value, or <symbol>NULL</symbol> if the column is null,
   <parameter>colnumber</parameter> is out of range
   (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>), or no output function is
   available (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>).
-->
列の値。
列がNULLの場合、あるいは<parameter>colnumber</parameter>が範囲外の場合は<symbol>NULL</symbol>です（<varname>SPI_result</varname>が<symbol>SPI_ERROR_NOATTRIBUTE</symbol>に設定されます）。
利用できる出力関数が存在しない場合は、<symbol>NULL</symbol>です
（<varname>SPI_result</varname>が<symbol>SPI_ERROR_NOOUTFUNC</symbol>に設定されます）。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getbinval">
 <indexterm><primary>SPI_getbinval</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getbinval</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getbinval</refname>
<!--
  <refpurpose>return the binary value of the specified column</refpurpose>
-->
  <refpurpose>指定した列のバイナリ値を返す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_getbinval</function> returns the value of the
   specified column in the internal form (as type <type>Datum</type>).
-->
<function>SPI_getbinval</function> は指定された列の値を内部形式で（<type>Datum</type>として）返します。
  </para>

  <para>
<!--
   This function does not allocate new space for the datum.  In the
   case of a pass-by-reference data type, the return value will be a
   pointer into the passed row.
-->
この関数はデータ用に新しい領域を確保しません。
参照渡しのデータ型の場合、戻り値は渡された行の内部を示すポインタとなります。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row to be examined
-->
対象とする入力行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row description
-->
入力行の記述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
<!--
      column number (count starts at 1)
-->
（1から始まる）列番号
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool * <parameter>isnull</parameter></literal></term>
    <listitem>
     <para>
<!--
      flag for a null value in the column
-->
列のNULL値についてのフラグ
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The binary value of the column is returned.  The variable pointed
   to by <parameter>isnull</parameter> is set to true if the column is
   null, else to false.
-->
列のバイナリ値が返されます。
<parameter>isnull</parameter>で指し示される変数は、列がNULLならば真に、さもなくば、偽に設定されます。
  </para>

  <para>
<!--
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
-->
エラー時、<varname>SPI_result</varname>は<symbol>SPI_ERROR_NOATTRIBUTE</symbol>に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettype">
 <indexterm><primary>SPI_gettype</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_gettype</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_gettype</refname>
<!--
  <refpurpose>return the data type name of the specified column</refpurpose>
-->
  <refpurpose>指定された列のデータ型名を返す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_gettype</function> returns a copy of the data type name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
-->
<function>SPI_gettype</function>は指定された列のデータ型名のコピーを返します
（不要になった段階で、<function>pfree</function>を使用して名前のコピーを解放することができます）。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row description
-->
入力行の記述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
<!--
      column number (count starts at 1)
-->
（1から始まる）列番号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The data type name of the specified column, or
   <symbol>NULL</symbol> on error.  <varname>SPI_result</varname> is
   set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
-->
指定された列のデータ型名。
エラー時は<symbol>NULL</symbol>です。
エラー時、<varname>SPI_result</varname>は<symbol>SPI_ERROR_NOATTRIBUTE</symbol>に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettypeid">
 <indexterm><primary>SPI_gettypeid</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_gettypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_gettypeid</refname>
<!--
  <refpurpose>return the data type <acronym>OID</acronym> of the specified column</refpurpose>
-->
  <refpurpose>指定された列のデータ型の<acronym>OID</acronym>を返す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_gettypeid</function> returns the
   <acronym>OID</acronym> of the data type of the specified column.
-->
   <function>SPI_gettypeid</function>は指定された列のデータ型の<acronym>OID</acronym>を返します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      input row description
-->
入力行の記述
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
     <para>
<!--
      column number (count starts at 1)
-->
（1から始まる）列番号
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The <acronym>OID</acronym> of the data type of the specified column
   or <symbol>InvalidOid</symbol> on error.  On error,
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>.
-->
指定された列のデータ型の<acronym>OID</acronym>です。
エラー時は<symbol>InvalidOid</symbol>です。
エラー時、<varname>SPI_result</varname>は<symbol>SPI_ERROR_NOATTRIBUTE</symbol>に設定されます。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getrelname">
 <indexterm><primary>SPI_getrelname</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getrelname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getrelname</refname>
<!--
  <refpurpose>return the name of the specified relation</refpurpose>
-->
  <refpurpose>指定されたリレーションの名前を返す</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_getrelname</function> returns a copy of the name of the
   specified relation.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
-->
<function>SPI_getrelname</function>は指定リレーションの名前のコピーを返します
（不要になった段階で、<function>pfree</function>を使用して名前のコピーを解放することができます）。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
<!--
      input relation
-->
入力リレーション
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The name of the specified relation.
-->
指定されたリレーションの名前です。
  </para>
 </refsect1>
</refentry>

<refentry id="spi-spi-getnspname">
 <indexterm><primary>SPI_getnspname</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_getnspname</refname>
<!--
  <refpurpose>return the namespace of the specified relation</refpurpose>
-->
  <refpurpose>指定されたリレーションの名前空間を返す。</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_getnspname</function> returns a copy of the name of
   the namespace that the specified <structname>Relation</structname>
   belongs to. This is equivalent to the relation's schema. You should
   <function>pfree</function> the return value of this function when
   you are finished with it.
-->
<function>SPI_getnspname</function>は、指定した<structname>Relation</structname>が属する名前空間名のコピーを返します。
これはリレーションのスキーマと同じです。
作業終了時に、この関数の戻り値に対して<function>pfree</function>を行わなければなりません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
<!--
      input relation
-->
入力リレーション
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   The name of the specified relation's namespace.
-->
指定したリレーションの名前空間の名称です。
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-memory">
<!--
  <title>Memory Management</title>
-->
  <title>メモリ管理</title>

  <para>
    <indexterm>
<!--
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
-->
     <primary>メモリコンテキスト</primary>
     <secondary>SPI内部の</secondary>
    </indexterm>
<!--
   <productname>PostgreSQL</productname> allocates memory within
   <firstterm>memory contexts</firstterm>, which provide a convenient method of
   managing allocations made in many different places that need to
   live for differing amounts of time.  Destroying a context releases
   all the memory that was allocated in it.  Thus, it is not necessary
   to keep track of individual objects to avoid memory leaks; instead
   only a relatively small number of contexts have to be managed.
   <function>palloc</function> and related functions allocate memory
   from the <quote>current</> context.
-->
<productname>PostgreSQL</productname>は、<firstterm>メモリコンテキスト</firstterm>内にメモリを確保します。
これは、様々な場所で、必要な有効期間がそれぞれ異なるような割り当てを管理する便利な方法を提供します。
コンテキストを破壊することで、そこで割り当てられた全てのメモリを解放します。
したがって、メモリリークを防ぐための個々のオブジェクトの追跡を維持することは不要です。
その代わり、相対的に少量のコンテキストを管理する必要があります。
<function>palloc</function>と関連する関数は<quote>現在の</>コンテキストからメモリを確保します。
  </para>

  <para>
<!--
   <function>SPI_connect</function> creates a new memory context and
   makes it current.  <function>SPI_finish</function> restores the
   previous current memory context and destroys the context created by
   <function>SPI_connect</function>.  These actions ensure that
   transient memory allocations made inside your procedure are
   reclaimed at procedure exit, avoiding memory leakage.
-->
<function>SPI_connect</function>は新しくメモリコンテキストを作成し、それを現在のコンテキストとします。
<function>SPI_finish</function>は直前の現在のメモリコンテキストを戻し、<function>SPI_connect</function>で作成されたコンテキストを破壊します。
これらの動作により、プロシージャ内で割り当てが行われる一時的なメモリがプロシージャの終了時に回収され、メモリリークが防止されることが保証されます。
  </para>

  <para>
<!--
   However, if your procedure needs to return an object in allocated
   memory (such as a value of a pass-by-reference data type), you
   cannot allocate that memory using <function>palloc</function>, at
   least not while you are connected to SPI.  If you try, the object
   will be deallocated by <function>SPI_finish</function>, and your
   procedure will not work reliably.  To solve this problem, use
   <function>SPI_palloc</function> to allocate memory for your return
   object.  <function>SPI_palloc</function> allocates memory in the
   <quote>upper executor context</quote>, that is, the memory context
   that was current when <function>SPI_connect</function> was called,
   which is precisely the right context for a value returned from your
   procedure.
-->
しかし、（参照渡しのデータ型の値といった）プロシージャが割り当てられたメモリ内のオブジェクトを返す必要がある場合、少なくともSPIに接続していない期間は、<function>palloc</function>を使用してメモリを確保することができません。
これを試行すると、そのオブジェクトは<function>SPI_finish</function>で解放されてしまい、プロシージャは正しく動作しないでしょう。
この問題を解決するには、<function>SPI_palloc</function>を使用して、戻り値となるオブジェクト用のメモリを確保してください。
<function>SPI_palloc</function>は<quote>上位エクゼキュータコンテキスト</quote>内にメモリを割り当てます。
このメモリコンテキストは、<function>SPI_connect</function>が呼び出された時点において現在のコンテキストだったものであり、プロシージャの戻り値用のコンテキストとしてまさに正しいものです。
  </para>

  <para>
<!--
   If <function>SPI_palloc</function> is called while the procedure is
   not connected to SPI, then it acts the same as a normal
   <function>palloc</function>.  Before a procedure connects to the
   SPI manager, the current memory context is the upper executor
   context, so all allocations made by the procedure via
   <function>palloc</function> or by SPI utility functions are made in
   this context.
-->
プロシージャがSPIに未接続な状態で<function>SPI_palloc</function> が呼び出されると、普通の<function>palloc</function>と同じように動作します。
プロシージャがSPIマネージャに接続する前では、現在のメモリコンテキストは上位エクゼキュータコンテキストであり、そのため、プロシージャから<function>palloc</function>やSPIユーティリティ関数経由で割り当てられた全ては、このコンテキストで作成されます。
  </para>

  <para>
<!--
   When <function>SPI_connect</function> is called, the private
   context of the procedure, which is created by
   <function>SPI_connect</function>, is made the current context.  All
   allocations made by <function>palloc</function>,
   <function>repalloc</function>, or SPI utility functions (except for
   <function>SPI_copytuple</function>,
   <function>SPI_returntuple</function>,
   <function>SPI_modifytuple</function>, and
   <function>SPI_palloc</function>) are made in this context.  When a
   procedure disconnects from the SPI manager (via
   <function>SPI_finish</function>) the current context is restored to
   the upper executor context, and all allocations made in the
   procedure memory context are freed and cannot be used any more.
-->
<function>SPI_connect</function>が呼び出されると、<function>SPI_connect</function>によって作成されるプロシージャ固有のコンテキストが現在のコンテキストに作成されます。
<function>palloc</function>、<function>repalloc</function>、SPIユーティリティ関数（<function>SPI_copytuple</function>、<function>SPI_returntuple</function>、<function>SPI_modifytuple</function>、<function>SPI_palloc</function>は除きます）によって作成される割り当ては全て、このコンテキスト内に作成されます。
プロシージャがSPIマネージャから（<function>SPI_finish</function>経由で）切断した時、現在のコンテキストは上位エクゼキュータコンテキストに戻され、プロシージャメモリコンテキスト内で割り当てられたメモリは全て解放され、二度と使用することができません。
  </para>

  <para>
<!--
   All functions described in this section can be used by both
   connected and unconnected procedures.  In an unconnected procedure,
   they act the same as the underlying ordinary server functions
   (<function>palloc</>, etc.).
-->
本節で説明する関数は全て、接続状態、未接続状態のどちらのプロシージャから使用することができます。
未接続のプロシージャでは、背後にある通常のサーバ関数（<function>palloc</>など）と同様に動作します。
  </para>

<!-- *********************************************** -->

<refentry id="spi-spi-palloc">
 <indexterm><primary>SPI_palloc</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_palloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_palloc</refname>
<!--
  <refpurpose>allocate memory in the upper executor context</refpurpose>
-->
  <refpurpose>上位エクゼキュータコンテキスト内にメモリを割り当てる</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_palloc</function> allocates memory in the upper
   executor context.
-->
<function>SPI_palloc</function>は上位エクゼキュータコンテキスト内にメモリを割り当てます。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <para>
<!--
      size in bytes of storage to allocate
-->
割り当てる領域のバイト数
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   pointer to new storage space of the specified size
-->
指定サイズの新しい格納領域へのポインタ
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-realloc">
 <indexterm><primary>SPI_repalloc</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_repalloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_repalloc</refname>
<!--
  <refpurpose>reallocate memory in the upper executor context</refpurpose>
-->
  <refpurpose>上位エクゼキュータコンテキスト内にメモリを再割り当てる</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_repalloc</function> changes the size of a memory
   segment previously allocated using <function>SPI_palloc</function>.
-->
<function>SPI_repalloc</function>は、以前に<function>SPI_palloc</function>を使用して割り当てられたメモリセグメントのサイズを変更します。
  </para>

  <para>
<!--
   This function is no longer different from plain
   <function>repalloc</function>.  It's kept just for backward
   compatibility of existing code.
-->
この関数はもはや通常の<function>repalloc</function>とは異なるものではありません。
単に既存コードの後方互換性のために保持されています。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <para>
<!--
      pointer to existing storage to change
-->
変更する既存の領域へのポインタ
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
     <para>
<!--
      size in bytes of storage to allocate
-->
割り当てる領域のバイト数
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   pointer to new storage space of specified size with the contents
   copied from the existing area
-->
指定サイズに新規に割り当てられ、既存領域の内容をコピーした領域へのポインタ
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pfree">
 <indexterm><primary>SPI_pfree</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_pfree</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_pfree</refname>
<!--
  <refpurpose>free memory in the upper executor context</refpurpose>
-->
  <refpurpose>上位エクゼキュータコンテキスト内のメモリを解放する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_pfree</function> frees memory previously allocated
   using <function>SPI_palloc</function> or
   <function>SPI_repalloc</function>.
-->
<function>SPI_pfree</function>は、以前に<function>SPI_palloc</function>や<function>SPI_repalloc</function>を使用して割り当てられたメモリを解放します。
  </para>

  <para>
<!--
   This function is no longer different from plain
   <function>pfree</function>.  It's kept just for backward
   compatibility of existing code.
-->
この関数はもはや通常の<function>pfree</function>とは異なるものではありません。
単に既存コードの後方互換性のために保持されています。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
     <para>
<!--
      pointer to existing storage to free
-->
解放する既存の領域へのポインタ
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-copytuple">
 <indexterm><primary>SPI_copytuple</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_copytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_copytuple</refname>
<!--
  <refpurpose>make a copy of a row in the upper executor context</refpurpose>
-->
  <refpurpose>上位エクゼキュータ内に行のコピーを作成する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_copytuple</function> makes a copy of a row in the
   upper executor context.  This is normally used to return a modified
   row from a trigger.  In a function declared to return a composite
   type, use <function>SPI_returntuple</function> instead.
-->
<function>SPI_copytuple</function>は上位エクゼキュータコンテキスト内に行のコピーを作成します。
これは通常、トリガから変更した行を返す時に使用されます。
複合型を返すものと宣言された関数では、代わりに<function>SPI_returntuple</function>を使用してください。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
<!--
      row to be copied
-->
コピーされる行
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   the copied row; <symbol>NULL</symbol> only if
   <parameter>tuple</parameter> is <symbol>NULL</symbol>
-->
コピーされた行。
<parameter>tuple</parameter>が<symbol>NULL</symbol>の場合のみ<symbol>NULL</symbol>です。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-returntuple">
 <indexterm><primary>SPI_returntuple</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_returntuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_returntuple</refname>
<!--
  <refpurpose>prepare to return a tuple as a Datum</refpurpose>
-->
  <refpurpose>Datumとしてタプルを返す準備をする</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_returntuple</function> makes a copy of a row in
   the upper executor context, returning it in the form of a row type <type>Datum</type>.
   The returned pointer need only be converted to <type>Datum</type> via <function>PointerGetDatum</function>
   before returning.
-->
<function>SPI_returntuple</function>は上位エクゼキュータコンテキスト内に行の複製を作成し、それを行型の<type>Datum</type>形式で返します。
返されるポインタは、返す前に<function>PointerGetDatum</function>を使用して<type>Datum</type>に変換することのみが必要です。
  </para>

  <para>
<!--
   Note that this should be used for functions that are declared to return
   composite types.  It is not used for triggers; use
   <function>SPI_copytuple</> for returning a modified row in a trigger.
-->
この関数は複合型を返すものと宣言された関数に対して使用しなければなりません。
トリガでは使用されません。
トリガで変更された行を返すには<function>SPI_copytuple</>を使用してください。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
<!--
      row to be copied
-->
コピーされる行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
     <para>
<!--
      descriptor for row (pass the same descriptor each time for most
      effective caching)
-->
行の記述子（最も効率的にキャッシュを行えるように毎回同一の記述子を渡してください）
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   <type>HeapTupleHeader</type> pointing to copied row;
   <symbol>NULL</symbol> only if
   <parameter>row</parameter> or <parameter>rowdesc</parameter> is
   <symbol>NULL</symbol>
-->
コピーされた行を指し示す<type>HeapTupleHeader</type>です。
<parameter>row</parameter>もしくは<parameter>rowdesc</parameter>が<symbol>NULL</symbol>の場合のみ<symbol>NULL</symbol>が返ります。
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-modifytuple">
 <indexterm><primary>SPI_modifytuple</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_modifytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_modifytuple</refname>
<!--
  <refpurpose>create a row by replacing selected fields of a given row</refpurpose>
-->
  <refpurpose>与えられた行の選択フィールドを置き換えた行を作成する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_modifytuple</function> creates a new row by
   substituting new values for selected columns, copying the original
   row's columns at other positions.  The input row is not modified.
-->
<function>SPI_modifytuple</function>は、選択された列は新しい値で置き換え、その他の位置は元の行の列をコピーした、新しい行を作成します。
入力行は変更されません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
     <para>
<!--
      Used only as the source of the row descriptor for the row.
      (Passing a relation rather than a row descriptor is a
      misfeature.)
-->
行の行記述子のソースとしてのみ使用されます。
（行記述子ではなくリレーションを渡すことは設計ミスです。）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
<!--
      row to be modified
-->
変更される行
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>ncols</parameter></literal></term>
    <listitem>
     <para>
<!--
      number of columns to be changed
-->
変更された列数
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int * <parameter>colnum</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>ncols</parameter>, containing the numbers
      of the columns that are to be changed (column numbers start at 1)
 -->
変更される列番号を含む、<parameter>ncols</parameter>長のの配列（列番号は1から始まります）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>ncols</parameter>, containing the
      new values for the specified columns
-->
指定された列の新しい値を含む、<parameter>ncols</parameter>長の配列
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
     <para>
<!--
      an array of length <parameter>ncols</parameter>, describing which
      new values are null
-->
新しい値のどれがNULLかを記述する、<parameter>ncols</parameter>長の配列
     </para>

     <para>
<!--
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_modifytuple</function> assumes that no new values
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</> if the corresponding new value is
      non-null, or <literal>'n'</> if the corresponding new value is
      null.  (In the latter case, the actual value in the corresponding
      <parameter>values</parameter> entry doesn't matter.)  Note that
      <parameter>nulls</parameter> is not a text string, just an array: it
      does not need a <literal>'\0'</> terminator.
-->
<parameter>nulls</parameter>が<symbol>NULL</symbol>であれば、<function>SPI_modifytuple</function>はどの新しい値もnullでないとみなします。
さもなければ、<parameter>nulls</parameter>配列の各項目は、対応するパラメータが非NULLならば<literal>'&nbsp;'</>、対応するパラメータがNULLならば<literal>'n'</>です。
（後者の場合、<parameter>values</parameter>内の対応する値は注意されません。）
<parameter>nulls</parameter>はテキスト文字列ではなく単なる配列であることに注意してください。
<literal>'\0'</>終端は必要ありません。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   new row with modifications, allocated in the upper executor
   context; <symbol>NULL</symbol> only if <parameter>row</parameter>
   is <symbol>NULL</symbol>
-->
変更された新しい行。上位エクゼキュータコンテキストに割り当てられます。
<parameter>row</parameter>が<symbol>NULL</symbol>の場合のみ<symbol>NULL</symbol>です。
  </para>

  <para>
<!--
   On error, <varname>SPI_result</varname> is set as follows:
-->
エラー時、<varname>SPI_result</varname>が以下のように設定されます。
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
<!--
       if <parameter>rel</> is <symbol>NULL</>, or if
       <parameter>row</> is <symbol>NULL</>, or if <parameter>ncols</>
       is less than or equal to 0, or if <parameter>colnum</> is
       <symbol>NULL</>, or if <parameter>values</> is <symbol>NULL</>.
-->
<parameter>rel</>が<symbol>NULL</>の場合、<parameter>row</>が<symbol>NULL</>の場合、<parameter>ncols</>が0以下の場合、<parameter>colnum</>が<symbol>NULL</>の場合、<parameter>values</>が<symbol>NULL</>の場合。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
<!--
       if <parameter>colnum</> contains an invalid column number (less
       than or equal to 0 or greater than the number of column in
       <parameter>row</>)
-->
<parameter>colnum</>が無効な列番号を持つ場合
（0以下、<parameter>row</>の列数以上）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetuple">
 <indexterm><primary>SPI_freetuple</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_freetuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freetuple</refname>
<!--
  <refpurpose>free a row allocated in the upper executor context</refpurpose>
-->
  <refpurpose>上位エクゼキュータコンテキスト内に割り当てられた行を解放する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_freetuple</function> frees a row previously allocated
   in the upper executor context.
-->
<function>SPI_freetuple</function>は以前に上位エクゼキュータコンテキスト内に割り当てられた行を解放します。
  </para>

  <para>
<!--
   This function is no longer different from plain
   <function>heap_freetuple</function>.  It's kept just for backward
   compatibility of existing code.
-->
この関数はもはや通常の<function>heap_freetuple</function>とは異なるものではありません。
単に既存コードの後方互換性のために保持されています。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
     <para>
<!--
      row to free
-->
解放する行
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetupletable">
 <indexterm><primary>SPI_freetuptable</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_freetuptable</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freetuptable</refname>
<!--
  <refpurpose>free a row set created by <function>SPI_execute</> or a similar
  function</refpurpose>
-->
  <refpurpose><function>SPI_execute</>や類似の関数によって生成された行セットを解放する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_freetuptable</function> frees a row set created by a
   prior SPI command execution function, such as
   <function>SPI_execute</>.  Therefore, this function is often called
   with the global variable <varname>SPI_tuptable</varname> as
   argument.
-->
<function>SPI_freetuptable</function>は、以前に<function>SPI_execute</>などのSPIコマンド実行関数によって作成された行セットを解放します。
そのため、この関数はよく<varname>SPI_tuptable</varname>グローバル変数を引数として呼び出されます。
  </para>

  <para>
<!--
   This function is useful if a SPI procedure needs to execute
   multiple commands and does not want to keep the results of earlier
   commands around until it ends.  Note that any unfreed row sets will
   be freed anyway at <function>SPI_finish</>.
   Also, if a subtransaction is started and then aborted within execution
   of a SPI procedure, SPI automatically frees any row sets created while
   the subtransaction was running.
-->
この関数はSPIプロシージャが複数のコマンドを実行する必要があり、かつ、初期のコマンドの結果を終わりまで保持したくない場合に有用です。
解放されない行セットは、<function>SPI_finish</>時に全て解放されることに注意してください。
また副トランザクションが始まった後SPIプロシージャの実行中にアボートした場合、SPIは自動的に副トランザクションが実行中に作成された行セットすべてを解放します。
  </para>

  <para>
<!--
   Beginning in <productname>PostgreSQL</> 9.3,
   <function>SPI_freetuptable</function> contains guard logic to protect
   against duplicate deletion requests for the same row set.  In previous
   releases, duplicate deletions would lead to crashes.
-->
<productname>PostgreSQL</> 9.3から<function>SPI_freetuptable</function>には同一行セットに対して重複する削除要求から保護する保護ロジックが含まれます。
過去のリリースでは重複する削除がクラッシュをもたらすかもしれませんでした。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
    <listitem>
     <para>
<!--
      pointer to row set to free, or NULL to do nothing
-->
解放する行セットへのポインタ。または何も行わないことを示すNULL。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freeplan">
 <indexterm><primary>SPI_freeplan</primary></indexterm>

 <refmeta>
  <refentrytitle>SPI_freeplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

 <refnamediv>
  <refname>SPI_freeplan</refname>
<!--
  <refpurpose>free a previously saved prepared statement</refpurpose>
-->
  <refpurpose>以前に保存した準備済み文を解放する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <function>SPI_freeplan</function> releases a prepared statement
   previously returned by <function>SPI_prepare</function> or saved by
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
-->
<function>SPI_freeplan</function>は、以前に<function>SPI_prepare</function>から返された、あるいは<function>SPI_keepplan</function>や<function>SPI_saveplan</function>で保存された準備済み文を解放します。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Arguments</title>
-->
  <title>引数</title>

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
     <para>
<!--
      pointer to statement to free
-->
解放する文へのポインタ
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Return Value</title>
-->
  <title>戻り値</title>

  <para>
<!--
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
-->
成功時は0。
<parameter>plan</parameter>が<symbol>NULL</symbol>または無効な場合、<symbol>SPI_ERROR_ARGUMENT</symbol>です。
  </para>
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-visibility">
<!--
  <title>Visibility of Data Changes</title>
-->
  <title>データ変更の可視性</title>

  <para>
<!--
   The following rules govern the visibility of data changes in
   functions that use SPI (or any other C function):
-->
SPI（や他の任意のC関数）を使用する関数内のデータの可視性は、以下の規則に従います。

   <itemizedlist>
    <listitem>
     <para>
<!--
      During the execution of an SQL command, any data changes made by
      the command are invisible to the command itself.  For
      example, in:
-->
SQLコマンドの実行中、そのコマンドで行われたデータ変更はそのコマンドからは不可視です。
例えば、
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
<!--
      the inserted rows are invisible to the <command>SELECT</command>
      part.
-->
では、挿入された行は<command>SELECT</command>部からは不可視です。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Changes made by a command C are visible to all commands that are
      started after C, no matter whether they are started inside C
      (during the execution of C) or after C is done.
-->
コマンドCで行われた変更は、Cの後に開始された全てのコマンドからは可視です。
Cの内側（処理中）に開始したかCの処理後に開始したかは関係ありません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Commands executed via SPI inside a function called by an SQL command
      (either an ordinary function or a trigger) follow one or the
      other of the above rules depending on the read/write flag passed
      to SPI.  Commands executed in read-only mode follow the first
      rule: they cannot see changes of the calling command.  Commands executed
      in read-write mode follow the second rule: they can see all changes made
      so far.
-->
SQLコマンドによって呼び出される関数（普通の関数やトリガ関数）の内側で、SPIを使用して実行されるコマンドは、SPIに渡される読み書きフラグに応じて上の規則のいくつかに従います。
読み取りのみモードで実行されるコマンドは、呼び出し中のコマンドの変更は不可視であるという最初の規則に従います。
読み書きモードで実行されるコマンドは、今までに行われた変更はすべて可視であるという2番目の規則に従います。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      All standard procedural languages set the SPI read-write mode
      depending on the volatility attribute of the function.  Commands of
      <literal>STABLE</> and <literal>IMMUTABLE</> functions are done in
      read-only mode, while commands of <literal>VOLATILE</> functions are
      done in read-write mode.  While authors of C functions are able to
      violate this convention, it's unlikely to be a good idea to do so.
-->
標準の手続き言語は全て、関数の変動属性に応じてSPI読み書きモードを設定します。
<literal>STABLE</>および<literal>IMMUTABLE</>関数のコマンドは、読み取りのみモードで行われ、<literal>VOLATILE</>関数のコマンドは読み書きモードで行われます。
C言語関数の作者はこの規約を無視することができますが、それはほとんどの場合勧められません。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   The next section contains an example that illustrates the
   application of these rules.
-->
次節には、これら規則の適用についてを示す例があります。
  </para>
 </sect1>

 <sect1 id="spi-examples">
<!--
  <title>Examples</title>
-->
  <title>例</title>

  <para>
<!--
   This section contains a very simple example of SPI usage. The
   procedure <function>execq</function> takes an SQL command as its
   first argument and a row count as its second, executes the command
   using <function>SPI_exec</function> and returns the number of rows
   that were processed by the command.  You can find more complex
   examples for SPI in the source tree in
   <filename>src/test/regress/regress.c</filename> and in the
   <xref linkend="contrib-spi"> module.
-->
本節には、SPIを使用する非常に簡単な例があります。
<function>execq</function> プロシージャは1つ目の引数としてSQLコマンドを、2つ目の引数として行数を取り、<function>SPI_exec</function>コマンドを実行し、そのコマンドで処理された行数を返します。
SPIのより複雑な例はソースツリー内の<filename>src/test/regress/regress.c</filename>と<xref linkend="contrib-spi">モジュールにあります。
  </para>

<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

int execq(text *sql, int cnt);

int
execq(text *sql, int cnt)
{
    char *command;
    int ret;
    int proc;

<!--
    /* Convert given text object to a C string */
-->
    /* 与えられたテキストオブジェクトをC文字列に変換 */
    command = text_to_cstring(sql);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;
    /*
<!--
     * If some rows were fetched, print them via elog(INFO).
-->
     * 何らかの行が取り出された場合は、行をelog(INFO)を使用して表示
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc;
        SPITupleTable *tuptable = SPI_tuptable;
        char buf[8192];
        int i, j;

        for (j = 0; j &lt; proc; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen (buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    return (proc);
}
</programlisting>

  <para>
<!--
   (This function uses call convention version 0, to make the example
   easier to understand.  In real applications you should use the new
   version 1 interface.)
-->
（例をよりわかりやすくするためにこの関数は呼び出し規約Version-0を使用しています。
実際のアプリケーションでは、新しいVersion-1インタフェースを使用すべきです。）
  </para>

  <para>
<!--
   This is how you declare the function after having compiled it into
   a shared library (details are in <xref linkend="dfunc">.):
-->
以下は、コンパイルし共有ライブラリ（<xref linkend="dfunc">を参照）を作成した後で、関数を宣言する方法です。

<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C;
</programlisting>
  </para>

  <para>
<!--
   Here is a sample session:
-->
以下はセッションの例です。

<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-------
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
<!--
INFO:  EXECQ:  0    &#045;&#045; inserted by execq
INFO:  EXECQ:  1    &#045;&#045; returned by execq and inserted by upper INSERT
-->
INFO:  EXECQ:  0    -- execqによって挿入された
INFO:  EXECQ:  1    -- execqによって返され、上位のINSERTによって挿入された

 execq
-------
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1);
 execq
-------
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
<!--
INFO:  EXECQ:  2    &#045;&#045; 0 + 2, only one row inserted - as specified
-->
INFO:  EXECQ:  2    -- 指定された、0 + 2という1つの行のみが挿入された

 execq
-------
<!--
     3              &#045;&#045; 10 is the max value only, 3 is the real number of rows
-->
     3              -- 10は最大値を示すのみで、3が実際の行数です。
(1 row)

=&gt; DELETE FROM a;
DELETE 3
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
<!--
 1                  &#045;&#045; no rows in a (0) + 1
-->
 1                  -- aテーブルに行がない(0) + 1
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1
<!--
 2                  &#045;&#045; there was one row in a + 1
-->
 2                  -- aテーブルに1行あり + 1
(2 rows)

<!--
&#045;&#045; This demonstrates the data changes visibility rule:
-->
--   これはデータ変更に関する可視性規則を説明します。

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  1
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
---
 1
 2
<!--
 2                  &#045;&#045;&#045;&#045; 2 rows * 1 (x in first row)
 6                  &#045;&#045; 3 rows (2 + 1 just inserted) * 2 (x in second row)
(4 rows)               ^^^^^^
                       rows visible to execq() in different invocations
-->
 2                  -- 2 行 * 1 （xは最初の行）
 6                  -- 3 行 （2 + 挿入された 1） * 2 （2行目のx）
(4 rows)               ^^^^^^
                       別の呼び出しで execq()で可視な行
</programlisting>
  </para>
 </sect1>
</chapter>
