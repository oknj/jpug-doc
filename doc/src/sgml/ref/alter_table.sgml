<!--
doc/src/sgml/ref/alter_table.sgml
PostgreSQL documentation
-->

<refentry id="SQL-ALTERTABLE">
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
<!--
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 言語</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
<!--
  <refpurpose>change the definition of a table</refpurpose>
-->
  <refpurpose>テーブル定義を変更する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">name</replaceable> [ * ]
    <replaceable class="PARAMETER">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> TO <replaceable class="PARAMETER">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="PARAMETER">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> TO <replaceable class="PARAMETER">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="PARAMETER">name</replaceable>
    RENAME TO <replaceable class="PARAMETER">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="PARAMETER">name</replaceable>
    SET SCHEMA <replaceable class="PARAMETER">new_schema</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="PARAMETER">name</replaceable> [ OWNED BY <replaceable class="PARAMETER">role_name</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="PARAMETER">new_tablespace</replaceable> [ NOWAIT ]

<!--
<phrase>where <replaceable class="PARAMETER">action</replaceable> is one of:</phrase>
-->
<phrase>ここで、<replaceable class="PARAMETER">action</replaceable>は以下のいずれかです。</phrase>

    ADD [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable class="PARAMETER">collation</replaceable> ] [ <replaceable class="PARAMETER">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="PARAMETER">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable class="PARAMETER">collation</replaceable> ] [ USING <replaceable class="PARAMETER">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET DEFAULT <replaceable class="PARAMETER">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET STATISTICS <replaceable class="PARAMETER">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET ( <replaceable class="PARAMETER">attribute_option</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> RESET ( <replaceable class="PARAMETER">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="PARAMETER">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="PARAMETER">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="PARAMETER">table_constraint_using_index</replaceable>
    ALTER CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="PARAMETER">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="PARAMETER">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="PARAMETER">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="PARAMETER">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="PARAMETER">trigger_name</replaceable>
    DISABLE RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="PARAMETER">rewrite_rule_name</replaceable>
    CLUSTER ON <replaceable class="PARAMETER">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET ( <replaceable class="PARAMETER">storage_parameter</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )
    RESET ( <replaceable class="PARAMETER">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="PARAMETER">parent_table</replaceable>
    NO INHERIT <replaceable class="PARAMETER">parent_table</replaceable>
    OF <replaceable class="PARAMETER">type_name</replaceable>
    NOT OF
    OWNER TO <replaceable class="PARAMETER">new_owner</replaceable>
    SET TABLESPACE <replaceable class="PARAMETER">new_tablespace</replaceable>
    REPLICA IDENTITY {DEFAULT | USING INDEX <replaceable class="PARAMETER">index_name</replaceable> | FULL | NOTHING}

<!--
<phrase>and <replaceable class="PARAMETER">table_constraint_using_index</replaceable> is:</phrase>
-->
<phrase>また<replaceable class="PARAMETER">table_constraint_using_index</replaceable>は以下の通りです。
</phrase>

    [ CONSTRAINT <replaceable class="PARAMETER">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="PARAMETER">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <command>ALTER TABLE</command> changes the definition of an existing table.
   There are several subforms described below. Note that the lock level required
   may differ for each subform. An <literal>ACCESS EXCLUSIVE</literal> lock is held
   unless explicitly noted. When multiple subcommands are listed, the lock
   held will be the strictest one required from any subcommand.
-->
<command>ALTER TABLE</command>は既存のテーブルの定義を変更します。 
以下のようにいくつかの副構文があります。
要求されるロックレベルはそれぞれの副構文によって異なることに注意してください。
特に記述がなければ<literal>ACCESS EXCLUSIVE</literal>ロックを取得します。
複数のサブコマンドが使われるときは、それらのサブコマンドが要求するうち、もっとも高いレベルのロックを取得します。

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
     <para>
<!--
      This form adds a new column to the table, using the same syntax as
      <xref linkend="SQL-CREATETABLE">.
-->
この構文を使用すると、<xref linkend="SQL-CREATETABLE">と同じ構文を使って新しい列をテーブルに追加できます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      This form drops a column from a table.  Indexes and
      table constraints involving the column will be automatically
      dropped as well.  You will need to say <literal>CASCADE</> if
      anything outside the table depends on the column, for example,
      foreign key references or views.
      If <literal>IF EXISTS</literal> is specified and the column
      does not exist, no error is thrown. In this case a notice
      is issued instead.
-->
この構文を使用すると、テーブルから列を削除できます。  
削除する列を含んでいるインデックスおよびテーブル制約も自動的に削除されます。  
また、削除する列にテーブル以外が依存（例えば、外部キー制約、ビューなど）している場合、<literal>CASCADE</>を付ける必要があります。
<literal>IF EXISTS</literal>が指定されている場合、もしその列がなかったとしてもエラーにはなりません。
この場合は代わりに注意が出力されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF EXISTS</literal></term>
    <listitem>
     <para>
<!--
      Do not throw an error if the table does not exist. A notice is issued
      in this case.
-->
テーブルが存在しない場合でもエラーとしません。
この場合は注意メッセージが発行されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <para>
<!--
      This form changes the type of a column of a table. Indexes and
      simple table constraints involving the column will be automatically
      converted to use the new column type by reparsing the originally
      supplied expression.
      The optional <literal>COLLATE</literal> clause specifies a collation
      for the new column; if omitted, the collation is the default for the
      new column type.
      The optional <literal>USING</literal>
      clause specifies how to compute the new column value from the old;
      if omitted, the default conversion is the same as an assignment
      cast from old data type to new.  A  <literal>USING</literal>
      clause must be provided if there is no implicit or assignment
      cast from old to new type.
-->
この構文を使用すると、テーブルの列の型を変更できます。
その列を含むインデックスと簡単なテーブル制約は、元々与えられた式を再解析し、新しい型を使用するように自動的に変換されます。
<literal>COLLATE</literal>句を使うと、新しい列の照合順を指定できます。
省略時の照合順は新しい列の型のデフォルトになります。
<literal>USING</literal>句を使うと、古い列値をどのように新しい値に計算するかを指定できます。
省略された場合、デフォルトの変換は、古いデータ型から新しいデータ型への代入キャストと同じになります。
古いデータ型から新しいデータ型への暗黙キャストあるいは代入キャストがない場合、<literal>USING</literal>句を指定しなければなりません。

     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
<!--
      These forms set or remove the default value for a column.
      Default values only apply in subsequent <command>INSERT</command>
      or <command>UPDATE</> commands; they do not cause rows already in the
      table to change.
-->
これらの構文を使用すると、列のデフォルト値を設定または削除できます。
デフォルト値は、変更後に行われる<command>INSERT</command>または<command>UPDATE</>コマンドにのみ適用されます。 
テーブル内の既存の行は変更されません。 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
<!--
      These forms change whether a column is marked to allow null
      values or to reject null values.  You can only use <literal>SET
      NOT NULL</> when the column contains no null values.
-->
これらの構文は、列の値としてNULL値を使用できるかどうか設定します。
<literal>SET NOT NULL</>は、その列にNULL値が1つもない場合にのみ設定可能です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
<!--
      This form
      sets the per-column statistics-gathering target for subsequent
      <xref linkend="sql-analyze"> operations.
      The target can be set in the range 0 to 10000; alternatively, set it
      to -1 to revert to using the system default statistics
      target (<xref linkend="guc-default-statistics-target">).
      For more information on the use of statistics by the
      <productname>PostgreSQL</productname> query planner, refer to
      <xref linkend="planner-stats">.
-->
この構文は、以後の<xref linkend="sql-analyze">操作において、列単位での統計情報収集対象を設定します。
対象として、0から10000までの範囲の値を設定可能です。
また、対象を-1に設定すると、システムのデフォルト統計情報対象（<xref linkend="guc-default-statistics-target">）が使用されます。
<productname>PostgreSQL</productname>の問い合わせプランナによる統計情報の使用に関する詳細は、<xref linkend="planner-stats">を参照してください。
     </para>
     <para>
<!--
      SET STATISTICS acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
SET STATISTICSは<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="PARAMETER">attribute_option</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="PARAMETER">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
<!--
      This form sets or resets per-attribute options.  Currently, the only
      defined per-attribute options are <literal>n_distinct</> and
      <literal>n_distinct_inherited</>, which override the
      number-of-distinct-values estimates made by subsequent
      <xref linkend="sql-analyze">
      operations.  <literal>n_distinct</> affects the statistics for the table
      itself, while <literal>n_distinct_inherited</> affects the statistics
      gathered for the table plus its inheritance children.  When set to a
      positive value, <command>ANALYZE</> will assume that the column contains
      exactly the specified number of distinct nonnull values.  When set to a
      negative value, which must be greater
      than or equal to -1, <command>ANALYZE</> will assume that the number of
      distinct nonnull values in the column is linear in the size of the
      table; the exact count is to be computed by multiplying the estimated
      table size by the absolute value of the given number.  For example,
      a value of -1 implies that all values in the column are distinct, while
      a value of -0.5 implies that each value appears twice on the average.
      This can be useful when the size of the table changes over time, since
      the multiplication by the number of rows in the table is not performed
      until query planning time.  Specify a value of 0 to revert to estimating
      the number of distinct values normally.  For more information on the use
      of statistics by the <productname>PostgreSQL</productname> query
      planner, refer to <xref linkend="planner-stats">.
-->
この構文は属性単位のオプションの設定または設定解除を行います。
現時点では属性単位のオプションで定義されているのは<literal>n_distinct</>および<literal>n_distinct_inherited</>のみです。
これらのオプションは、その後の<xref linkend="sql-analyze">操作により生成される個別値数の推定値を上書きします。
<literal>n_distinct</>はテーブル自身の統計情報に影響を与え、<literal>n_distinct_inherited</>はテーブルとそれを継承した子テーブルから集めた統計情報に影響を与えます。
正の値の場合、<command>ANALYZE</>は、その列には、正確に指定された個数の非NULLの個別値が存在するものとみなします。
負の値の場合、この値は-1以上でなければなりませんが、<command>ANALYZE</>は、その列内の非NULLの個別値はテーブルのサイズに線形であるとみなし、推定テーブルサイズに指定した値の絶対値を乗じた値が個別値数であるとみなします。
たとえば、-1という値は、列内のすべての値に重複がないことを意味し、-0.5という値は個々の値は平均して2回現れることを意味します。
テーブルの行数との乗算は問い合わせ計画を作成するまで行われませんので、テーブルサイズが変わり続けるような場合にこれは有用かもしれません。
0という値を指定することで、個別値数の推定を通常に戻します。
<productname>PostgreSQL</productname>問い合わせプランナにおける統計情報の使用に関しては<xref linkend="planner-stats">を参照してください。
     </para>
     <para>
<!--
      Changing per-attribute options acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
属性単位のオプションの変更は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>SET STORAGE</literal>
     <indexterm>
      <primary>TOAST</primary>
<!--
      <secondary>per-column storage settings</secondary>
-->
      <secondary>列ごとの保管設定</secondary>
     </indexterm>
    </term>
    <listitem>
     <para>
<!--
      This form sets the storage mode for a column. This controls whether this
      column is held inline or in a secondary <acronym>TOAST</> table, and
      whether the data
      should be compressed or not. <literal>PLAIN</literal> must be used
      for fixed-length values such as <type>integer</type> and is
      inline, uncompressed. <literal>MAIN</literal> is for inline,
      compressible data. <literal>EXTERNAL</literal> is for external,
      uncompressed data, and <literal>EXTENDED</literal> is for external,
      compressed data.  <literal>EXTENDED</literal> is the default for most
      data types that support non-<literal>PLAIN</literal> storage.
      Use of <literal>EXTERNAL</literal> will make substring operations on
      very large <type>text</type> and <type>bytea</type> values run faster,
      at the penalty of increased storage space.  Note that
      <literal>SET STORAGE</> doesn't itself change anything in the table,
      it just sets the strategy to be pursued during future table updates.
      See <xref linkend="storage-toast"> for more information.
-->
この構文は、列の保管モードを設定します。
列をインラインで保持するか補助TOASTテーブルに保持するか、また、データを圧縮するかどうかを制御できます。
<literal>PLAIN</literal>は、<type>integer</type>のような固定長の値に対して使用します。インラインで保持され、圧縮されません。
<literal>MAIN</literal>は、インラインで保持されていて、圧縮可能なデータに使用します。
<literal>EXTERNAL</literal>は圧縮されていない外部データに使用します。
<literal>EXTENDED</literal>は圧縮された外部データに使用します。
<literal>EXTENDED</literal>は、<literal>PLAIN</literal>以外の保管をサポートするほとんどのデータ型におけるデフォルトです。
<literal>EXTERNAL</literal>を使用すると、非常に長い<type>text</type>および<type>bytea</type>列に対する部分文字列操作の処理速度が向上しますが、必要な保管容量が増えるというデメリットがあります。
<literal>SET STORAGE</>自体はテーブルをまったく変更しないことに注意してください。
以後のテーブルの更新時に遂行する戦略を設定するだけです。
詳細は<xref linkend="storage-toast">を参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="PARAMETER">table_constraint</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
     <para>
<!--
      This form adds a new constraint to a table using the same syntax as
      <xref linkend="SQL-CREATETABLE">, plus the option <literal>NOT
      VALID</literal>, which is currently only allowed for foreign key
      and CHECK constraints.
      If the constraint is marked <literal>NOT VALID</literal>, the
      potentially-lengthy initial check to verify that all rows in the table
      satisfy the constraint is skipped.  The constraint will still be
      enforced against subsequent inserts or updates (that is, they'll fail
      unless there is a matching row in the referenced table, in the case
      of foreign keys; and they'll fail unless the new row matches the
      specified check constraints).  But the
      database will not assume that the constraint holds for all rows in
      the table, until it is validated by using the <literal>VALIDATE
      CONSTRAINT</literal> option.
-->
この構文は、<xref linkend="SQL-CREATETABLE">と同じ構文に加え、現時点では外部キー制約と検査制約でのみ許される<literal>NOT VALID</literal>オプションを使って新しい制約をテーブルに追加します。
制約が<literal>NOT VALID</literal>と印付けされた場合、テーブル内のすべての行が制約を満たすかどうかを検証するための、時間がかかるかもしれない初期検査が飛ばされます。
しかし、制約はその後の挿入や更新に対して強制されます（つまり、外部キー制約の場合、被参照テーブルに一致する行が存在しない限り失敗します。指定された検査制約に一致する新しい行が存在しない限り失敗します）。
しかしデータベースは、<literal>VALIDATE CONSTRAINT</literal>オプションを使用して検証されるまで、テーブル内のすべての行で制約が保持されているとみなしません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="PARAMETER">table_constraint_using_index</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form adds a new <literal>PRIMARY KEY</> or <literal>UNIQUE</>
      constraint to a table based on an existing unique index.  All the
      columns of the index will be included in the constraint.
-->
この構文は、既存の一意性インデックスに基づき、テーブルに<literal>PRIMARY KEY</>または<literal>UNIQUE</>制約を新たに追加します。
インデックスのすべての列がこの制約に含まれます。
     </para>

     <para>
<!--
      The index cannot have expression columns nor be a partial index.
      Also, it must be a b-tree index with default sort ordering.  These
      restrictions ensure that the index is equivalent to one that would be
      built by a regular <literal>ADD PRIMARY KEY</> or <literal>ADD UNIQUE</>
      command.
-->
このインデックスは式列を持つことはできず、また部分インデックスであってはいけません。
またこれはデフォルトのソート順序を持つB-Treeインデックスでなければなりません。
これらの制限により、このインデックスが通常の<literal>ADD PRIMARY KEY</>または<literal>ADD UNIQUE</>コマンドにより構築されたインデックスと等価であることを確実にします。
     </para>

     <para>
<!--
      If <literal>PRIMARY KEY</> is specified, and the index's columns are not
      already marked <literal>NOT NULL</>, then this command will attempt to
      do <literal>ALTER COLUMN SET NOT NULL</> against each such column.
      That requires a full table scan to verify the column(s) contain no
      nulls.  In all other cases, this is a fast operation.
-->
<literal>PRIMARY KEY</>が指定され、インデックスの列が<literal>NOT NULL</>と印付けされていない場合、このコマンドはこうした列のそれぞれに対して<literal>ALTER COLUMN SET NOT NULL</>の実施を試みます。
これは列にNULLが含まれないことを検証するために完全なテーブルスキャンを必要とします。
この他の場合においては、これが高速な操作です。
     </para>

     <para>
<!--
      If a constraint name is provided then the index will be renamed to match
      the constraint name.  Otherwise the constraint will be named the same as
      the index.
-->
制約名が提供された場合、インデックスの名前は制約名に合うように変更されます。
提供されない場合は制約にはインデックスと同じ名前が付けられます。
     </para>

     <para>
<!--
      After this command is executed, the index is <quote>owned</> by the
      constraint, in the same way as if the index had been built by
      a regular <literal>ADD PRIMARY KEY</> or <literal>ADD UNIQUE</>
      command.  In particular, dropping the constraint will make the index
      disappear too.
-->
このコマンドの実行後、インデックスは、制約により<quote>所有</>され、それはインデックスが通常の<literal>ADD PRIMARY KEY</>または<literal>ADD UNIQUE</>により構築された場合と同様です。
特にこの制約を削除するとインデックスも消えてしまいます。
     </para>

     <note>
      <para>
<!--
       Adding a constraint using an existing index can be helpful in
       situations where a new constraint needs to be added without blocking
       table updates for a long time.  To do that, create the index using
       <command>CREATE INDEX CONCURRENTLY</>, and then install it as an
       official constraint using this syntax.  See the example below.
-->
既存のインデックスを使用した制約の追加は、テーブル更新を長時間ブロックすることなく新しい制約を追加しなければならない場合に有用になる可能性があります。
このためには、<command>CREATE INDEX CONCURRENTLY</>を用いてインデックスを作成し、この構文を使用して正式の制約としてインストールしてください。
後述の例を参照してください。
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER CONSTRAINT</literal></term>
    <listitem>
     <para>
<!--
      This form alters the attributes of a constraint that was previously
      created. Currently only foreign key constraints may be altered.
-->
この構文は以前に作成された制約の属性を変更します。
現在は外部キー制約のみを変更できます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <para>
<!--
      This form validates a foreign key or check constraint that was previously created
      as <literal>NOT VALID</literal>, by scanning the table to ensure there
      are no rows for which the constraint is not satisfied.
      Nothing happens if the constraint is already marked valid.
-->
この構文は、以前に<literal>NOT VALID</literal>として作成された外部キー制約または検査制約を、これらの制約を満たさない行が存在しないことを確認するためにテーブルをスキャンして、検証します。
制約がすでに有効であると記録されている場合は何も起こりません。
     </para>
     <para>
<!--
      Validation can be a long process on larger tables. The value of separating
      validation from initial creation is that you can defer validation to less
      busy times, or can be used to give additional time to correct pre-existing
      errors while preventing new errors. Note also that validation on its own
      does not prevent normal write commands against the table while it runs.
-->
検証は大きなテーブルに対して長いプロセスになることがあります。
制約の初期生成から検証を分離する利点は、より忙しくない時間まで検証を遅延させることができることや、新しいエラーを防ぎつつ、既存のエラーを修正する時間を用意するために使用することができることです。
また、検証それ自体は、その実行中に、テーブルに対する通常の書き込みコマンドを妨げないことにも注意してください。
     </para>
     <para>
<!--
      Validation acquires only a <literal>SHARE UPDATE EXCLUSIVE</literal> lock
      on the table being altered. If the constraint is a foreign key then
      a <literal>ROW SHARE</literal> lock is also required on
      the table referenced by the constraint.
-->
検証は変更されるテーブルについて<literal>SHARE UPDATE EXCLUSIVE</literal>ロックしか取得しません。
制約が外部キーの時は、制約が参照するテーブルテーブルについて<literal>ROW SHARE</literal>ロックも取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      This form drops the specified constraint on a table.
      If <literal>IF EXISTS</literal> is specified and the constraint
      does not exist, no error is thrown. In this case a notice is issued instead.
-->
この構文を使用すると、テーブル上の指定した制約を削除できます。 
<literal>IF EXISTS</literal>が指定された場合、その制約がなくてもエラーになりません。
この場合は代わりに注意が出力されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
<!--
      These forms configure the firing of trigger(s) belonging to the table.
      A disabled trigger is still known to the system, but is not executed
      when its triggering event occurs.  For a deferred trigger, the enable
      status is checked when the event occurs, not when the trigger function
      is actually executed.  One can disable or enable a single
      trigger specified by name, or all triggers on the table, or only
      user triggers (this option excludes internally generated constraint
      triggers such as those that are used to implement foreign key
      constraints or deferrable uniqueness and exclusion constraints).
      Disabling or enabling internally generated constraint triggers
      requires superuser privileges; it should be done with caution since
      of course the integrity of the constraint cannot be guaranteed if the
      triggers are not executed.
      The trigger firing mechanism is also affected by the configuration
      variable <xref linkend="guc-session-replication-role">. Simply enabled
      triggers will fire when the replication role is <quote>origin</>
      (the default) or <quote>local</>. Triggers configured as <literal>ENABLE
      REPLICA</literal> will only fire if the session is in <quote>replica</>
      mode, and triggers configured as <literal>ENABLE ALWAYS</literal> will
      fire regardless of the current replication mode.
-->
この構文を使用すると、テーブルに属するトリガの発行について設定することができます。
無効にされたトリガはシステム上に存在し続けますが、トリガイベントが発生したとしても実行されません。
遅延トリガの場合、有効無効状態の確認は、トリガ関数を実際に実行しようとする時ではなく、イベントの発生時に行われます。
名前でトリガを1つ指定して有効または無効にすることもできますし、テーブル上のすべてのトリガを有効または無効にすることもできます。
また、ユーザトリガのみを有効または無効にすることも可能です
（このオプションは、外部キー制約、遅延可能な一意性および排他制約を実装するために使用される内部向けに生成される制約トリガを除外します。）
内部向けに生成される制約トリガを有効または無効にするにはスーパーユーザ権限が必要です。
トリガが実行されなかった場合は当然ながら制約の整合性が保証されませんので、制約トリガの無効化は注意して実行しなければなりません。
また、トリガ発行機構は設定変数<xref linkend="guc-session-replication-role">の影響を受けます。
単に有効としたトリガでは、レプリケーションロールが<quote>origin</>（デフォルト）または<quote>local</>の場合に発行されます。
<literal>ENABLE REPLICA</literal>としたトリガでは、セッションが<quote>replica</>モードである場合のみ発行されます。
そして、<literal>ENABLE ALWAYS</literal>としたトリガでは、現在のレプリケーションモードに関係なく発行されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
<!--
      These forms configure the firing of rewrite rules belonging to the table.
      A disabled rule is still known to the system, but is not applied
      during query rewriting. The semantics are as for disabled/enabled
      triggers. This configuration is ignored for <literal>ON SELECT</literal> rules, which
      are always applied in order to keep views working even if the current
      session is in a non-default replication role.
-->
この構文を使用すると、テーブルに属する書き換えルールの実行について設定することができます。
ルールは無効にしてもシステムに残りますが、問い合わせ書き換え時に適用されません。
この意味はトリガの有効化、無効化と同じです。
この設定は<literal>ON SELECT</literal>ルールでは無視されます。
現在のセッションがデフォルト以外のレプリケーションモードであったとしても、ビュー操作を維持するために常に適用されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <para>
<!--
      This form selects the default index for future
      <xref linkend="SQL-CLUSTER">
      operations.  It does not actually re-cluster the table.
-->
この構文は、以後の<xref linkend="SQL-CLUSTER">操作用のデフォルトインデックスを選択します。
テーブルの再クラスタ化は実際には行いません。
     </para>
     <para>
<!--
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
clusterオプションの変更は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
<!--
      This form removes the most recently used
      <xref linkend="SQL-CLUSTER">
      index specification from the table.  This affects
      future cluster operations that don't specify an index.
-->
この構文は、テーブルから、一番最後に適用された<xref linkend="SQL-CLUSTER">インデックス指定を削除します。
以後のインデックスを指定しないクラスタ操作に影響を及ぼします。
     </para>
     <para>
<!--
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
clusterオプションの変更は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITH OIDS</literal></term>
    <listitem>
     <para>
<!--
      This form adds an <literal>oid</literal> system column to the
      table (see <xref linkend="ddl-system-columns">).
      It does nothing if the table already has OIDs.
-->
この構文は<literal>oid</literal>システム列をテーブルに追加します（<xref linkend="ddl-system-columns">を参照してください）。
テーブルがすでにOIDを持つ場合は何も行いません。
     </para>

     <para>
<!--
      Note that this is not equivalent to <literal>ADD COLUMN oid oid</>;
      that would add a normal column that happened to be named
      <literal>oid</>, not a system column.
-->
これが、<literal>ADD COLUMN oid oid</>と同じではないことに注意してください。
後者はシステム列ではなく<literal>oid</>という名前が付いただけの通常の列を追加します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
<!--
      This form removes the <literal>oid</literal> system column from the
      table.  This is exactly equivalent to
      <literal>DROP COLUMN oid RESTRICT</literal>,
      except that it will not complain if there is already no
      <literal>oid</literal> column.
-->
この構文は、テーブルから<literal>oid</literal>システム列を削除します。
既に<literal>oid</literal>列が存在しなくても警告が表示されない点を除けば、<literal>DROP COLUMN oid RESTRICT</literal>とまったく同等です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="PARAMETER">storage_parameter</replaceable> = <replaceable class="PARAMETER">value</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
<!--
      This form changes one or more storage parameters for the table.  See
      <xref linkend="SQL-CREATETABLE-storage-parameters"
      endterm="SQL-CREATETABLE-storage-parameters-title">
      for details on the available parameters.  Note that the table contents
      will not be modified immediately by this command; depending on the
      parameter you might need to rewrite the table to get the desired effects.
      That can be done with <link linkend="SQL-VACUUM">VACUUM
      FULL</>, <xref linkend="SQL-CLUSTER"> or one of the forms
      of <command>ALTER TABLE</> that forces a table rewrite.
-->
この構文は、1つ以上のテーブルの格納パラメータを変更します。
設定可能なパラメータに関しては<xref linkend="SQL-CREATETABLE-storage-parameters" endterm="SQL-CREATETABLE-storage-parameters-title">を参照してください。
このコマンドによってテーブルの内容が即座に変更されない点に注意してください。
パラメータによりますが、期待する効果を得るためにテーブルを書き換える必要がある場合があります。
このためには、<link linkend="SQL-VACUUM">VACUUM FULL</>、<xref linkend="SQL-CLUSTER">またはテーブルを強制的に書き換える<command>ALTER TABLE</>の構文のいずれかを使用してください。
     </para>

     <note>
      <para>
<!--
       While <command>CREATE TABLE</> allows <literal>OIDS</> to be specified
       in the <literal>WITH (<replaceable
       class="PARAMETER">storage_parameter</>)</literal> syntax,
       <command>ALTER TABLE</> does not treat <literal>OIDS</> as a
       storage parameter.  Instead use the <literal>SET WITH OIDS</>
       and <literal>SET WITHOUT OIDS</> forms to change OID status.
-->
<command>CREATE TABLE</>では<literal>OIDS</>を<literal>WITH (<replaceable class="PARAMETER">storage_parameter</>)</literal>構文で指定することができますが、<command>ALTER TABLE</>では<literal>OIDS</>を格納パラメータとして扱っていません。
OIDの状態を変更するためには代わりに<literal>SET WITH OIDS</>および<literal>SET WITHOUT OIDS</>構文を使用してください。
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="PARAMETER">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
<!--
      This form resets one or more storage parameters to their
      defaults.  As with <literal>SET</>, a table rewrite might be
      needed to update the table entirely.
-->
この構文は、1つ以上の格納パラメータをデフォルト値に再設定します。
<literal>SET</>同様、テーブル全体を更新するためにテーブルの書き換えが必要になる場合があります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="PARAMETER">parent_table</replaceable></literal></term>
    <listitem>
     <para>

<!--
      This form adds the target table as a new child of the specified parent
      table.  Subsequently, queries against the parent will include records
      of the target table.  To be added as a child, the target table must
      already contain all the same columns as the parent (it could have
      additional columns, too).  The columns must have matching data types,
      and if they have <literal>NOT NULL</literal> constraints in the parent
      then they must also have <literal>NOT NULL</literal> constraints in the
      child.
-->
この構文は、対象テーブルを指定した親テーブルの子テーブルとして追加します。
その後に行われる親テーブルへの問い合わせには対象テーブルの項目も含まれます。
子テーブルとして追加するためには、対象テーブルには親テーブルと同じ列がすべて含まれていなければなりません。
（この他の列を持つこともできます。）
これらの列のデータ型は一致している必要があり、親テーブルで<literal>NOT NULL</literal>制約がある場合は、子テーブルでも同様に<literal>NOT NULL</literal>制約を持たなければなりません。
     </para>

     <para>
<!--
      There must also be matching child-table constraints for all
      <literal>CHECK</literal> constraints of the parent, except those
      marked non-inheritable (that is, created with <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>)
      in the parent, which are ignored; all child-table constraints matched
      must not be marked non-inheritable.
      Currently
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and
      <literal>FOREIGN KEY</literal> constraints are not considered, but
      this might change in the future.
-->
また、親テーブルの<literal>CHECK</literal>制約すべてについても、一致する制約が子テーブルに存在しなければなりません。
ただし、親テーブルにおいて継承不可と印付けされている（つまり<literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>付きで作成された）制約は除きます(これらは無視されます)。
一致する子テーブルの制約はすべて継承不可であってはなりません。
現時点では<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>、<literal>FOREIGN KEY</literal>制約は無視されますが、将来変更されるかもしれません。
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="PARAMETER">parent_table</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form removes the target table from the list of children of the
      specified parent table.
      Queries against the parent table will no longer include records drawn
      from the target table.
-->
この構文は、指定した親テーブルの子テーブル群から対象のテーブルを削除します。
親テーブルへの問い合わせでは、対象としたテーブルからのデータが含まれなくなります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="PARAMETER">type_name</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form links the table to a composite type as though <command>CREATE
      TABLE OF</> had formed it.  The table's list of column names and types
      must precisely match that of the composite type; the presence of
      an <literal>oid</> system column is permitted to differ.  The table must
      not inherit from any other table.  These restrictions ensure
      that <command>CREATE TABLE OF</> would permit an equivalent table
      definition.
-->
この構文は、<command>CREATE TABLE OF</>で形成されたかのように、テーブルと複合型とを関連付けします。
テーブルの列名とその型のリストは、複合型のものと正確に一致していなければなりません。
ただし<literal>oid</>システム列の有無は異なっていても構いません。
テーブルはどのテーブルも継承していてはいけません。
これらの制限により<command>CREATE TABLE OF</>により作成できるテーブル定義と同等になります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
     <para>
<!--
      This form dissociates a typed table from its type.
-->
この構文は型と型付けされたテーブルの関連を取り除きます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <para>
<!--
      This form changes the owner of the table, sequence, view, materialized view,
      or foreign table to the specified user.
-->
この構文を使用すると、テーブル、シーケンス、ビュー、マテリアライズドビュー、または外部テーブルの所有者を、指定したユーザに変更できます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
<!--
      This form changes the table's tablespace to the specified tablespace and
      moves the data file(s) associated with the table to the new tablespace.
      Indexes on the table, if any, are not moved; but they can be moved
      separately with additional <literal>SET TABLESPACE</literal> commands.
      All tables in the current database in a tablespace can be moved by using
      the <literal>ALL IN TABLESPACE</literal> form, which will lock all tables
      to be moved first and then move each one.  This form also supports
      <literal>OWNED BY</literal>, which will only move tables owned by the
      roles specified.  If the <literal>NOWAIT</literal> option is specified
      then the command will fail if it is unable to acquire all of the locks
      required immediately.  Note that system catalogs are not moved by this
      command, use <command>ALTER DATABASE</command> or explicit
      <command>ALTER TABLE</command> invocations instead if desired.  The
      <literal>information_schema</literal> relations are not considered part
      of the system catalogs and will be moved.
      See also
      <xref linkend="SQL-CREATETABLESPACE">.
-->
この構文を使用すると、テーブルのテーブル空間を指定したテーブル空間に変更し、テーブルに関連するデータファイルを新しいテーブル空間に移動することができます。
テーブルにインデックスがあっても移動されません。
インデックスを移動するには、別途<literal>SET TABLESPACE</literal>コマンドを実行します。
<literal>ALL IN TABLESPACE</literal>構文を使うことで、テーブル空間内の現在のデータベースのすべてのテーブルを移動することができます。
この場合、移動されるすべてのテーブルがまずロックされ、それから一つずつ移動されます。
この構文は<literal>OWNED BY</literal>もサポートしており、これを使うと、指定のロールが所有しているテーブルだけを移動します。
<literal>NOWAIT</literal>を指定した場合、必要とするすべてのロックを即座に獲得できなければ、このコマンドは失敗します。
このコマンドではシステムカタログは移動されないことに注意してください。
必要であれば、<command>ALTER DATABASE</command>を使うか、あるいは<command>ALTER TABLE</command>で明示的に指定してください。
<literal>information_schema</literal>のリレーションはシステムカタログとはみなされないので、移動されます。
<xref linkend="SQL-CREATETABLESPACE">も参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="SQL-CREATETABLE-REPLICA-IDENTITY">
    <term><literal>REPLICA IDENTITY</literal></term>
    <listitem>
     <para>
<!--
      This form changes the information which is written to the write-ahead log
      to identify rows which are updated or deleted.  This option has no effect
      except when logical replication is in use.  <literal>DEFAULT</>
      (the default for non-system tables) records the 
      old values of the columns of the primary key, if any.  <literal>USING INDEX</>
      records the old values of the columns covered by the named index, which
      must be unique, not partial, not deferrable, and include only columns marked
      <literal>NOT NULL</>.  <literal>FULL</> records the old values of all columns
      in the row.  <literal>NOTHING</> records no information about the old row.
      (This is the default for system tables.)
      In all cases, no old values are logged unless at least one of the columns
      that would be logged differs between the old and new versions of the row.
-->
この構文を使用すると、更新あるいは削除された行を特定できるよう、先行書き込みログに書き込まれる情報を変更します。
このオプションは、論理レプリケーションが使われている場合以外は何の効果もありません。
<literal>DEFAULT</>はシステムテーブル以外についてのデフォルトで、主キー列があれば、その古い値を記録します。
<literal>USING INDEX</>は指定したインデックスに含まれる列の古い値を記録しますが、このインデックスは一意であり、部分インデックスや遅延可能インデックスではなく、また<literal>NOT NULL</>の列のみを含まなければなりません。
<literal>FULL</>は行のすべての列の古い値を記録します。
<literal>NOTHING</>は古い行の情報を何も記録しません(これがシステムテーブルについてのデフォルトです)。
どの場合についても、行の古いバージョンと新しいバージョンの間で、ログに記録される列のうち少なくとも1つが変わっていなければ、古い値はログに記録されません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
<!--
      The <literal>RENAME</literal> forms change the name of a table
      (or an index, sequence, view, materialized view, or foreign table), the name
      of an individual column in a table, or the name of a constraint of the table.
      There is no effect on the stored data.
-->
<literal>RENAME</literal>構文を使用すると、テーブル（もしくは、インデックス、シーケンス、ビュー、マテリアライズドビュー、外部テーブル）の名前、テーブルの個々の列名、テーブルの制約名を変更できます。 
格納されているデータへの影響はありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
<!-- 
      This form moves the table into another schema.  Associated indexes,
      constraints, and sequences owned by table columns are moved as well.
-->
この構文を使用して、テーブルを別のスキーマに移動することができます。
関連するインデックスや制約、テーブル列により所有されるシーケンスも同様に移動されます。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
<!--
   All the actions except <literal>RENAME</literal>,
   <literal>SET TABLESPACE</literal> and <literal>SET SCHEMA</literal>
   can be combined into
   a list of multiple alterations to apply in parallel.  For example, it
   is possible to add several columns and/or alter the type of several
   columns in a single command.  This is particularly useful with large
   tables, since only one pass over the table need be made.
-->
<literal>RENAME</literal>、<literal>SET TABLESPACE</literal>および<literal>SET SCHEMA</>以外の全ての操作は、結合して複数の変更リストにまとめて、並行に処理することができます。
例えば、複数の列の追加、型の変更を単一のコマンドで実行することができます。
これは特に巨大なテーブルでは便利です。変更のために必要なテーブル全体の走査が1回で済むからです。
  </para>

  <para>
<!--
   You must own the table to use <command>ALTER TABLE</>.
   To change the schema or tablespace of a table, you must also have
   <literal>CREATE</literal> privilege on the new schema or tablespace.
   To add the table as a new child of a parent table, you must own the
   parent table as well.
   To alter the owner, you must also be a direct or indirect member of the new
   owning role, and that role must have <literal>CREATE</literal> privilege on
   the table's schema.  (These restrictions enforce that altering the owner
   doesn't do anything you couldn't do by dropping and recreating the table.
   However, a superuser can alter ownership of any table anyway.)
   To add a column or alter a column type or use the <literal>OF</literal>
   clause, you must also have <literal>USAGE</literal> privilege on the data
   type.
-->
<command>ALTER TABLE</>コマンドを使用するには、変更するテーブルを所有している必要があります。
テーブルのスキーマあるいはテーブル空間を変更するには、新しいスキーマあるいはテーブル空間における<literal>CREATE</literal>権限も持っていなければなりません。
テーブルを親テーブルの新しい子テーブルとして追加するには、親テーブルも所有している必要があります。
また、所有者を変更するには、新しい所有ロールの直接あるいは間接的なメンバでなければならず、かつ、そのロールがテーブルのスキーマにおける<literal>CREATE</literal>権限を持たなければなりません
（この制限により、テーブルの削除と再作成を行ってもできないことが、所有者の変更によってもできないようにしています。
ただし、スーパーユーザはすべてのテーブルの所有者を変更することができます）。
列の追加、列の型の変更、<literal>OF</literal>句の使用を行うためには、データ型に対する<literal>USAGE</literal>権限を持たなければなりません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Parameters</title>
-->
  <title>パラメータ</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <para>
<!--
        The name (optionally schema-qualified) of an existing table to
        alter. If <literal>ONLY</> is specified before the table name, only
        that table is altered. If <literal>ONLY</> is not specified, the table
        and all its descendant tables (if any) are altered.  Optionally,
        <literal>*</> can be specified after the table name to explicitly
        indicate that descendant tables are included.
-->
変更対象となる既存のテーブルの名前です（スキーマ修飾名も可）。 
テーブル名の前に<literal>ONLY</>が指定された場合、そのテーブルのみが変更されます。 
<literal>ONLY</>が指定されていない場合、そのテーブルおよび（もしあれば）そのテーブルを継承する全てのテーブルが更新されます。 
オプションで、テーブル名の後に<literal>*</>を指定することで、明示的に継承するテーブルも含まれることを示すことができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">column_name</replaceable></term>
      <listitem>
       <para>
<!--
        Name of a new or existing column.
-->
新規または既存の列の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_column_name</replaceable></term>
      <listitem>
       <para>
<!--
        New name for an existing column.
-->
既存の列の新しい名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_name</replaceable></term>
      <listitem>
       <para>
<!--
        New name for the table.
-->
テーブルの新しい名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">data_type</replaceable></term>
      <listitem>
       <para>
<!--
        Data type of the new column, or new data type for an existing
        column.
-->
新しい列のデータ型、もしくは既存の列に対する新しいデータ型です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">table_constraint</replaceable></term>
      <listitem>
       <para>
<!--
        New table constraint for the table.
-->
テーブルの新しいテーブル制約です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">constraint_name</replaceable></term>
      <listitem>
       <para>
<!--
        Name of a new or existing constraint.
-->
新しい、あるいは既存の制約の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
<!--
        Automatically drop objects that depend on the dropped column
        or constraint (for example, views referencing the column).
-->
削除された列や制約に依存しているオブジェクト（例えば、削除された列を参照しているビューなど）を、自動的に削除します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
<!--
        Refuse to drop the column or constraint if there are any dependent
        objects. This is the default behavior.
-->
依存しているオブジェクトがある場合、列または制約の削除要求を拒否します。
これがデフォルトの動作です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">trigger_name</replaceable></term>
      <listitem>
       <para>
<!--
        Name of a single trigger to disable or enable.
-->
有効または無効にする単一のトリガの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
<!--
        Disable or enable all triggers belonging to the table.
        (This requires superuser privilege if any of the triggers are
        internally generated constraint triggers such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.)
-->
テーブルに属するすべてのトリガを有効または無効にします。
（外部キー制約、遅延可能な一意性および排他制約を実装するために使用される、内部向けに生成される制約トリガが含まれる場合、スーパーユーザ権限が必要です。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
       <para>
<!--
        Disable or enable all triggers belonging to the table except for
        internally generated constraint triggers such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.
-->
外部キー制約、遅延可能な一意性および排他制約を実装するために使用される、内部向けに生成されるトリガを除く、テーブルに属するトリガすべてを有効または無効にします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">index_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of an existing index.
-->
既存のインデックスの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">storage_parameter</replaceable></term>
      <listitem>
       <para>
<!--
        The name of a table storage parameter.
-->
テーブルの格納パラメータの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
<!--
        The new value for a table storage parameter.
        This might be a number or a word depending on the parameter.
-->
テーブルの格納パラメータの新しい値です。
パラメータによりこれは数値となることも文字列となることもあります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">parent_table</replaceable></term>
      <listitem>
       <para>
<!--
        A parent table to associate or de-associate with this table.
-->
このテーブルに関連付ける、または、このテーブルから関連付けを取り除く親テーブルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_owner</replaceable></term>
      <listitem>
       <para>
<!--
        The user name of the new owner of the table.
-->
テーブルの新しい所有者のユーザ名です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_tablespace</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the tablespace to which the table will be moved.
-->
テーブルを移動する先のテーブル空間の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">new_schema</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the schema to which the table will be moved.
-->
テーブルを移動する先のスキーマの名前です。

       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
<!--
  <title>Notes</title>
-->
   <title>注釈</title>

   <para>
<!--
    The key word <literal>COLUMN</literal> is noise and can be omitted.
-->
<literal>COLUMN</literal>キーワードには意味がなく、省略可能です。
   </para>

   <para>
<!--
    When a column is added with <literal>ADD COLUMN</literal>, all existing
    rows in the table are initialized with the column's default value
    (NULL if no <literal>DEFAULT</> clause is specified).
    If there is no <literal>DEFAULT</> clause, this is merely a metadata
    change and does not require any immediate update of the table's data;
    the added NULL values are supplied on readout, instead.
-->
<literal>ADD COLUMN</literal>によって列を追加した時、テーブル内の既存行に追加された列は、全てデフォルト値（<literal>DEFAULT</>が指定されていない場合はNULL）で初期化されます。
<literal>DEFAULT</>句がない場合、これは単なるメタデータの変更となり、即座にテーブルのデータを更新する必要はありません。
その代わりに、追加されるNULLの値は読み出し時に付加されます。
   </para>

   <para>
<!--
    Adding a column with a <literal>DEFAULT</> clause or changing the type of
    an existing column will require the entire table and its indexes to be
    rewritten.  As an exception when changing the type of an existing column,
    if the <literal>USING</> clause does not change the column
    contents and the old type is either binary coercible to the new type or
    an unconstrained domain over the new type, a table rewrite is not needed;
    but any indexes on the affected columns must still be rebuilt.  Adding or
    removing a system <literal>oid</> column also requires rewriting the entire
    table.  Table and/or index rebuilds may take a significant amount of time
    for a large table; and will temporarily require as much as double the disk
    space.
-->
<literal>DEFAULT</>句を持つ列を追加したり、既存の列の型を変更するには、テーブルとインデックス全体の書き換えが必要になります。
既存の列の型を変更する場合の例外として、<literal>USING</>句が列の内容を変更せず、かつ、古いデータ型が新しい型とバイナリ変換可能であるか新しい型全体に対する制約のないドメインである場合、テーブルの書き換えは必要ありません。
しかし影響を受ける列に対するインデックスはすべて再構築されなければなりません。
システム<literal>oid</>列の追加や削除も同様にテーブル全体の書き換えが必要です。
テーブルが巨大な場合、テーブル、インデックスまたはその両方の再構築に非常に時間がかかる可能性があります。
また、一時的に2倍のディスク容量が必要とされます。
   </para>

   <para>
<!--
    Adding a <literal>CHECK</> or <literal>NOT NULL</> constraint requires
    scanning the table to verify that existing rows meet the constraint.
-->
<literal>CHECK</>あるいは<literal>NOT NULL</>制約を追加する時は、既存の行が制約に従うかどうかを検証するためにテーブルの走査が必要になります。
   </para>

   <para>
<!--
    The main reason for providing the option to specify multiple changes
    in a single <command>ALTER TABLE</> is that multiple table scans or
    rewrites can thereby be combined into a single pass over the table.
-->
単一の<command>ALTER TABLE</>内に複数の変更を指定できるオプションを提供する主な理由は、複数のテーブル走査や書き換えを1回のテーブル走査にまとめることができるようにすることです。
   </para>

   <para>
<!--
    The <literal>DROP COLUMN</literal> form does not physically remove
    the column, but simply makes it invisible to SQL operations.  Subsequent
    insert and update operations in the table will store a null value for the
    column. Thus, dropping a column is quick but it will not immediately
    reduce the on-disk size of your table, as the space occupied
    by the dropped column is not reclaimed.  The space will be
    reclaimed over time as existing rows are updated.  (These statements do
    not apply when dropping the system <literal>oid</> column; that is done
    with an immediate rewrite.)
-->
<literal>DROP COLUMN</literal>構文は、列を物理的には削除せず、SQLの操作に対して不可視にします。  
このコマンドを実行した後、テーブルに挿入または更新が行われると、削除した列にはNULLが格納されます。 
したがって、列の削除は短時間で行えます。
しかし、削除された列が占めていた領域がまだ回収されていないため、テーブルのディスク上のサイズはすぐには小さくなりません。  
この領域は、その後既存の行が更新されるにつれて回収されます。 
（システム<literal>oid</>列を削除する場合は上記のことは適用されません。
これは即座の書き換えが行われます。）
   </para>

   <para>
<!--
    To force an immediate rewrite of the table, you can use
    <link linkend="SQL-VACUUM">VACUUM FULL</>, <xref linkend="SQL-CLUSTER">
    or one of the forms of ALTER TABLE that forces a rewrite.  This results in
    no semantically-visible change in the table, but gets rid of
    no-longer-useful data.
-->
テーブルの書き換えを即座に強制するために、<link linkend="SQL-VACUUM">VACUUM FULL</>、<xref linkend="SQL-CLUSTER">、書き換えを強制するALTER TABLE構文を使用することができます。
これにより、見た目にはテーブルに有意な変更はありませんが、使用されなくなったデータが取り除かれます。
   </para>

   <para>
<!--
    The <literal>USING</literal> option of <literal>SET DATA TYPE</> can actually
    specify any expression involving the old values of the row; that is, it
    can refer to other columns as well as the one being converted.  This allows
    very general conversions to be done with the <literal>SET DATA TYPE</>
    syntax.  Because of this flexibility, the <literal>USING</literal>
    expression is not applied to the column's default value (if any); the
    result might not be a constant expression as required for a default.
    This means that when there is no implicit or assignment cast from old to
    new type, <literal>SET DATA TYPE</> might fail to convert the default even
    though a <literal>USING</literal> clause is supplied.  In such cases,
    drop the default with <literal>DROP DEFAULT</>, perform the <literal>ALTER
    TYPE</>, and then use <literal>SET DEFAULT</> to add a suitable new
    default.  Similar considerations apply to indexes and constraints involving
    the column.
-->
<literal>SET DATA TYPE</>の<literal>USING</literal>オプションでは、その行の古い値を含め、どのような式でも指定できます。
つまり、変換対象の列と同様に、その他の列も参照することができます。
そのため、一般的な変換を<literal>SET DATA TYPE</>構文で行うことができます。
この柔軟性のため、<literal>USING</literal>式は列のデフォルト値には（仮に存在していても）適用されません。
結果が定数式にならない可能性があるためです（デフォルト値は定数式でなければいけません）。
したがって、古い型から新しい型への暗黙キャストや代入キャストが存在しない場合、<literal>USING</literal>が指定されていても、<literal>SET DATA TYPE</>がデフォルト値の変換に失敗する可能性があります。
この場合は、<literal>DROP DEFAULT</>でデフォルト値を削除し、<literal>ALTER TYPE</>を実行した後で、<literal>SET DEFAULT</>を使用して再度適切なデフォルト値を指定してください。
変更対象の列を含むインデックスと制約も同様の配慮が必要です。
   </para>

   <para>
<!--
    If a table has any descendant tables, it is not permitted to add,
    rename, or change the type of a column, or rename an inherited constraint
    in the parent table without doing
    the same to the descendants.  That is, <command>ALTER TABLE ONLY</command>
    will be rejected.  This ensures that the descendants always have
    columns matching the parent.
-->
そのテーブルを継承するテーブルがある場合、子テーブルに同じ処理を実行しなければ、親テーブルに対する列の追加、列の名前、列の型、継承された制約の名前の変更を実行することはできません。
つまり、<command>ALTER TABLE ONLY</command>コマンドは受け付けられません。
この制限により、子テーブルの列が常に親テーブルと一致していることが保証されます。
   </para>

   <para>
<!--
    A recursive <literal>DROP COLUMN</literal> operation will remove a
    descendant table's column only if the descendant does not inherit
    that column from any other parents and never had an independent
    definition of the column.  A nonrecursive <literal>DROP
    COLUMN</literal> (i.e., <command>ALTER TABLE ONLY ... DROP
    COLUMN</command>) never removes any descendant columns, but
    instead marks them as independently defined rather than inherited.
-->
再帰的な<literal>DROP COLUMN</literal>操作では、子テーブルが他の親テーブルからその列を継承しておらず、かつ、その列について独立した定義を持っていない場合のみ、その子テーブルの列を削除します。 
再帰的でない<literal>DROP COLUMN</literal>（つまり、<command>ALTER TABLE ONLY ... DROP COLUMN</command>）操作では、継承された列は削除されません。
削除する代わりに、その列は継承されておらず独立して定義されているという印を付けます。
   </para>

   <para>
<!--
    The <literal>TRIGGER</>, <literal>CLUSTER</>, <literal>OWNER</>,
    and <literal>TABLESPACE</> actions never recurse to descendant tables;
    that is, they always act as though <literal>ONLY</> were specified.
    Adding a constraint recurses only for <literal>CHECK</> constraints
    that are not marked <literal>NO INHERIT</>.
-->
<literal>TRIGGER</>、<literal>CLUSTER</>、<literal>OWNER</>および<literal>TABLESPACE</>は子テーブルに再帰的に伝わりません。
つまり、常に<literal>ONLY</>が指定されているかのように動作します。
制約の追加は、<literal>NO INHERIT</>印がない<literal>CHECK</>制約に関してのみ再帰的に伝わります。
   </para>

   <para>
<!--
    Changing any part of a system catalog table is not permitted.
-->
システムカタログテーブルについては、いかなる部分の変更も許可されていません。
   </para>

   <para>
<!--
    Refer to <xref linkend="sql-createtable"> for a further description of valid
    parameters. <xref linkend="ddl"> has further information on
    inheritance.
-->
有効なパラメータの詳しい説明は<xref linkend="sql-createtable">を参照してください。
<xref linkend="ddl">に、継承に関するさらに詳しい情報があります。
   </para>
 </refsect1>

 <refsect1>
<!--
  <title>Examples</title>
-->
  <title>例</title>

  <para>
<!--
   To add a column of type <type>varchar</type> to a table:
-->
<type>varchar</type>型の列をテーブルに追加します。
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
  </para>

  <para>
<!--
   To drop a column from a table:
-->
   テーブルから列を削除します。
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>

  <para>
<!--
   To change the types of two existing columns in one operation:
-->
1つの操作で既存の2つの列の型を変更します。
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>

  <para>
<!--
   To change an integer column containing UNIX timestamps to <type>timestamp
   with time zone</type> via a <literal>USING</literal> clause:
-->
<literal>USING</literal>句を使用して、Unixタイムスタンプを持つinteger型の列を<type>timestamp with time zone</type>に変更します。
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
<!--
   The same, when the column has a default expression that won't automatically
   cast to the new data type:
-->
上と同じことをします。
ただし、その列は、自動的に新しいデータ型にキャストされないデフォルト式を持つ場合についてです。
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>

  <para>
<!--
   To rename an existing column:
-->
既存の列の名前を変更します。
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>

  <para>
<!--
   To rename an existing table:
-->
既存のテーブルの名前を変更します。
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>

  <para>
<!--
   To rename an existing constraint:
-->
既存の制約の名前を変更します。
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>

  <para>
<!--
   To add a not-null constraint to a column:
-->
列に非NULL制約を付与します。
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
<!--
   To remove a not-null constraint from a column:
-->
列から非NULL制約を削除します。
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>

  <para>
<!--
   To add a check constraint to a table and all its children:
-->
テーブルとそのすべての子テーブルにCHECK制約を付与します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>

  <para>
<!--
   To add a check constraint only to a table and not to its children:
-->
そのテーブルのみに適用され、その子テーブルには適用されない検査制約を追加します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
<!--
   (The check constraint will not be inherited by future children, either.)
-->
（この検査制約はこの後作成される子テーブルにも継承されません。）
  </para>

  <para>
<!--
   To remove a check constraint from a table and all its children:
-->
テーブルとそのすべての子テーブルからCHECK制約を削除します。
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>

  <para>
<!--
   To remove a check constraint from one table only:
-->
1つのテーブルのみから検査制約を削除します。
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
<!--
   (The check constraint remains in place for any child tables.)
-->
（この検査制約はすべての子テーブルで残ったままです。）
  </para>

  <para>
<!--
   To add a foreign key constraint to a table:
-->
テーブルに外部キー制約を付与します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>

  <para>
<!--
   To add a foreign key constraint to a table with the least impact on other work:
-->
テーブルへの外部キーの追加で、他の作業への影響を最小限にするには、以下のようにします。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>

  <para>
<!--
   To add a (multicolumn) unique constraint to a table:
-->
テーブルに（複数列の）一意性制約を付与します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>

  <para>
<!--
   To add an automatically named primary key constraint to a table, noting
   that a table can only ever have one primary key:
-->
自動的に命名されるプライマリキー制約をテーブルに付与します。 
1つのテーブルが持てるプライマリキーは1つだけであることに注意してください。

<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>

  <para>
<!--
   To move a table to a different tablespace:
-->
テーブルを別のテーブル空間に移動します。
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>

  <para>
<!--
   To move a table to a different schema:
-->
テーブルを別のスキーマに移動します。
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>

  <para>
<!--
   To recreate a primary key constraint, without blocking updates while the
   index is rebuilt:
-->
インデックスを再構築している間の更新をブロックすることなく、プライマリキー制約を再作成します。
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>

 </refsect1>

 <refsect1>
<!--
  <title>Compatibility</title>
-->
  <title>互換性</title>

  <para>
<!--
   The forms <literal>ADD</literal> (without <literal>USING INDEX</literal>),
   <literal>DROP</>, <literal>SET DEFAULT</>,
   and <literal>SET DATA TYPE</literal> (without <literal>USING</literal>)
   conform with the SQL standard.  The other forms are
   <productname>PostgreSQL</productname> extensions of the SQL standard.
   Also, the ability to specify more than one manipulation in a single
   <command>ALTER TABLE</> command is an extension.
-->
（<literal>USING INDEX</literal>がない）<literal>ADD</literal>、<literal>DROP</>、<literal>SET DEFAULT</>、（<literal>USING</literal>がない）<literal>SET DATA TYPE</literal>構文は標準SQLに従います。
他の構文は標準SQLに対する<productname>PostgreSQL</productname>の拡張です。
また、単一の<command>ALTER TABLE</>コマンド内に複数の操作を指定する機能も<productname>PostgreSQL</productname>の拡張です。
  </para>

  <para>
<!--
   <command>ALTER TABLE DROP COLUMN</> can be used to drop the only
   column of a table, leaving a zero-column table.  This is an
   extension of SQL, which disallows zero-column tables.
-->
<command>ALTER TABLE DROP COLUMN</>を使って、1つしか列がないテーブルから列を削除して、列がないテーブルを作成することができます。
これは<productname>PostgreSQL</productname>の拡張です。SQLでは、列を持たないテーブルは認められていません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>See Also</title>
-->
  <title>関連項目</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"></member>
  </simplelist>
 </refsect1>
</refentry>
