<!-- doc/src/sgml/indices.sgml -->

<chapter id="indexes">
<!--
 <title>Indexes</title>
-->
 <title>インデックス</title>

 <indexterm zone="indexes">
<!--
  <primary>index</primary>
-->
  <primary>インデックス</primary>
 </indexterm>

 <para>
<!--
  Indexes are a common way to enhance database performance.  An index
  allows the database server to find and retrieve specific rows much
  faster than it could do without an index.  But indexes also add
  overhead to the database system as a whole, so they should be used
  sensibly.
-->
インデックスは、データベースの性能を向上させるための一般的な方法です。
データベースサーバでインデックスを使用すると、インデックスを使用しない場合に比べてかなり速く、特定の行を検出し抽出することができます。
しかし、インデックスを使用すると、データベースシステム全体にオーバーヘッドを追加することにもなるため、注意して使用する必要があります。
 </para>


 <sect1 id="indexes-intro">
<!--
  <title>Introduction</title>
-->
  <title>序文</title>

  <para>
<!--
   Suppose we have a table similar to this:
-->
次のようなテーブルを考えてみましょう。
<programlisting>
CREATE TABLE test1 (
    id integer,
    content varchar
);
</programlisting>
<!--
   and the application issues many queries of the form:
-->
アプリケーションはこの形式の多くの問い合わせを発行します。
<programlisting>
SELECT content FROM test1 WHERE id = <replaceable>constant</replaceable>;
</programlisting>
<!--
   With no advance preparation, the system would have to scan the entire
   <structname>test1</structname> table, row by row, to find all
   matching entries.  If there are many rows in
   <structname>test1</structname> and only a few rows (perhaps zero
   or one) that would be returned by such a query, this is clearly an
   inefficient method.  But if the system has been instructed to maintain an
   index on the <structfield>id</structfield> column, it can use a more
   efficient method for locating matching rows.  For instance, it
   might only have to walk a few levels deep into a search tree.
-->
高度な準備を行っていなければ、システムで一致する項目を全て検出するためには通常、<structname>test1</structname>テーブル全体を1行ごとにスキャンする必要があります。
<structname>test1</structname>に数多くの行があり、その問い合わせで返されるのが数行（おそらく0行か1行）しかない場合、これは明らかに効率が悪い方法と言えます。
システムがインデックスを<structfield>id</structfield>列上で維持するように指示されていれば、一致する行を検出するのにより効率の良い方法を使うことができます。
例えば、検索ツリーを数層分検索するだけで済む可能性もあります。
  </para>

  <para>
<!--
   A similar approach is used in most non-fiction books:  terms and
   concepts that are frequently looked up by readers are collected in
   an alphabetic index at the end of the book.  The interested reader
   can scan the index relatively quickly and flip to the appropriate
   page(s), rather than having to read the entire book to find the
   material of interest.  Just as it is the task of the author to
   anticipate the items that readers are likely to look up,
   it is the task of the database programmer to foresee which indexes
   will be useful.
-->
ほとんどのノンフィクション小説で、同じような手法が使われています。
読者が頻繁に調べる用語および概念は、その本の最後にアルファベット順に索引としてまとめられています。
その本に興味を持った読者は、索引（インデックス）を調べ、比較的速く簡単に該当するページを開くことができるため、見たい場所を探すために本全部を読む必要はありません。
読者がよく調べそうな項目を予想するのが著者の仕事であるように、どのインデックスが実用的であるかを予測するのはデータベースプログラマの仕事です。
  </para>

  <para>
<!--
   The following command can be used to create an index on the
   <structfield>id</structfield> column, as discussed:
-->
上述のように<structfield>id</structfield>列にインデックスを作成する場合は、以下のようなコマンドが使用できます。
<programlisting>
CREATE INDEX test1_id_index ON test1 (id);
</programlisting>
<!--
   The name <structname>test1_id_index</structname> can be chosen
   freely, but you should pick something that enables you to remember
   later what the index was for.
-->
<structname>test1_id_index</structname>というインデックス名には、何を選んでも構いませんが、そのインデックスを何のために作成したかを後で思い出せるような名前を選ぶべきです。
  </para>

  <para>
<!--
   To remove an index, use the <command>DROP INDEX</command> command.
   Indexes can be added to and removed from tables at any time.
-->
インデックスを削除するには、<command>DROP INDEX</command>コマンドを使用します。
テーブルのインデックスは、いつでも追加および削除できます。
  </para>

  <para>
<!--
   Once an index is created, no further intervention is required: the
   system will update the index when the table is modified, and it will
   use the index in queries when it thinks doing so would be more efficient
   than a sequential table scan.  But you might have to run the
   <command>ANALYZE</command> command regularly to update
   statistics to allow the query planner to make educated decisions.
   See <xref linkend="performance-tips"> for information about
   how to find out whether an index is used and when and why the
   planner might choose <emphasis>not</emphasis> to use an index.
-->
いったんインデックスを作成すれば、それ以上の処理は必要はありません。
システムは、テーブルが変更される時インデックスを更新し、シーケンシャルスキャンよりもインデックススキャンを行うことがより効率的と判断した場合、問い合わせでインデックスを使用します。
しかし、問い合わせプランナで情報に基づいた判断をするためには、定期的に<command>ANALYZE</command>コマンドを実行し、統計情報を更新する必要があるかもしれません。
インデックスが使われているかどうか、およびプランナがインデックスを<emphasis>使わない</emphasis>と判断した状況および理由を調べる方法については、<xref linkend="performance-tips">を参照してください。
  </para>

  <para>
<!--
   Indexes can also benefit <command>UPDATE</command> and
   <command>DELETE</command> commands with search conditions.
   Indexes can moreover be used in join searches.  Thus,
   an index defined on a column that is part of a join condition can
   also significantly speed up queries with joins.
-->
インデックスは、<command>UPDATE</command>や<command>DELETE</command>コマンドの検索条件でも使用できます。
インデックスは結合問い合わせでより多く使用されます。
したがって、結合条件で記述されている列にインデックスを定義すれば、結合を伴った問い合わせにかかる時間もかなり短縮できます。
  </para>

  <para>
<!--
   Creating an index on a large table can take a long time.  By default,
   <productname>PostgreSQL</productname> allows reads (<command>SELECT</command> statements) to occur
   on the table in parallel with index creation, but writes (<command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command>) are blocked until the index build is finished.
   In production environments this is often unacceptable.
   It is possible to allow writes to occur in parallel with index
   creation, but there are several caveats to be aware of &mdash;
   for more information see <xref linkend="SQL-CREATEINDEX-CONCURRENTLY"
   endterm="SQL-CREATEINDEX-CONCURRENTLY-title">.
-->
大規模テーブルに対するインデックス作成が長期にわたる可能性があります。
デフォルトで<productname>PostgreSQL</productname>はインデックス作成と並行してテーブルを読み取る（<command>SELECT</command>文）ことができますが、書き込み（<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）はインデックス作成が終わるまでブロックされます。
これは多くの運用環境では受け入れられません。
インデックス作成中でも並行して書き込みできるようにすることができますが、いくつか注意しなければならないことがあります。
<xref linkend="SQL-CREATEINDEX-CONCURRENTLY" endterm="SQL-CREATEINDEX-CONCURRENTLY-title">の情報を参照してください。
  </para>

  <para>
<!--
   After an index is created, the system has to keep it synchronized with the
   table.  This adds overhead to data manipulation operations.
   Therefore indexes that are seldom or never used in queries
   should be removed.
-->
インデックスが作成された後、システムでは、テーブルとインデックスとの間で常に同期を取っておく必要があります。
これにより、データ操作の処理にオーバーヘッドが加わります。
したがって、めったに使用されないインデックスや、まったく使用されなくなったインデックスは、削除しておいた方が良いでしょう。
  </para>
 </sect1>


 <sect1 id="indexes-types">
<!--
  <title>Index Types</title>
-->
  <title>インデックスの種類</title>

  <para>
<!--
   <productname>PostgreSQL</productname> provides several index types:
   B-tree, Hash, GiST, SP-GiST and GIN.  Each index type uses a different
   algorithm that is best suited to different types of queries.
   By default, the <command>CREATE INDEX</command> command creates
   B-tree indexes, which fit the most common situations.
-->
<productname>PostgreSQL</productname>では、B-tree、Hash、GiST、SP-GiST、GINといった複数の種類のインデックスを使用可能です。
インデックスの各種類は、異なる種類の問い合わせに最も適した、異なるアルゴリズムを使用します。
デフォルトで<command>CREATE INDEX</command>コマンドは、B-treeインデックスを作成し、それはほとんどの一般的状況に適合します。
  </para>

  <para>
   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>B-tree</secondary>
   </indexterm>
   <indexterm>
    <primary>B-tree</primary>
<!--
    <see>index</see>
-->
    <see>インデックス</see>
   </indexterm>
<!--
   B-trees can handle equality and range queries on data that can be sorted
   into some ordering.
   In particular, the <productname>PostgreSQL</productname> query planner
   will consider using a B-tree index whenever an indexed column is
   involved in a comparison using one of these operators:
-->
B-treeインデックスは、ある順番でソート可能なデータに対する等価性や範囲を問い合わせることを扱うことができます。
具体的には、<productname>PostgreSQL</productname>の問い合わせプランナは、インデックスの付いた列を次の演算子を使用して比較する場合に、B-treeインデックスの使用を検討します。

   <simplelist>
    <member><literal>&lt;</literal></member>
    <member><literal>&lt;=</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&gt;=</literal></member>
    <member><literal>&gt;</literal></member>
   </simplelist>

<!--
   Constructs equivalent to combinations of these operators, such as
   <literal>BETWEEN</> and <literal>IN</>, can also be implemented with
   a B-tree index search.  Also, an <literal>IS NULL</> or <literal>IS NOT
   NULL</> condition on an index column can be used with a B-tree index.
-->
また、<literal>BETWEEN</>や<literal>IN</>などのこれらの演算子の組み合わせと等価な式をB-treeインデックス検索で実装することができます。
インデックスの付いた列に対する<literal>IS NULL</>や<literal>IS NOT NULL</>でもB-treeインデックスを使用することができます。
  </para>

  <para>
<!--
   The optimizer can also use a B-tree index for queries involving the
   pattern matching operators <literal>LIKE</> and <literal>~</literal>
   <emphasis>if</emphasis> the pattern is a constant and is anchored to
   the beginning of the string &mdash; for example, <literal>col LIKE
   'foo%'</literal> or <literal>col ~ '^foo'</literal>, but not
   <literal>col LIKE '%bar'</literal>. However, if your database does not
   use the C locale you will need to create the index with a special
   operator class to support indexing of pattern-matching queries; see
   <xref linkend="indexes-opclass"> below. It is also possible to use
   B-tree indexes for <literal>ILIKE</literal> and
   <literal>~*</literal>, but only if the pattern starts with
   non-alphabetic characters, i.e., characters that are not affected by
   upper/lower case conversion.
-->
オプティマイザは、パターンマッチ演算子<literal>LIKE</>、<literal>~</literal>を含む問い合わせでも、そのパターンが定数であり、先頭文字列を指定している<emphasis>場合</emphasis>B-treeインデックスを使用することができます。
例えば、<literal>col LIKE 'foo%'</literal>または<literal>col ~ '^foo'</literal>です。
<literal>col LIKE '%bar'</literal>では使用されません。
しかし、データベースがCロケールを使用していない場合、パターンマッチ問い合わせのインデックス付けをサポートする特別な演算子クラスでインデックスを作成しなければなりません。
後述の<xref linkend="indexes-opclass">を参照してください。
なお、<literal>ILIKE</literal>と<literal>~*</literal>でもB-treeインデックスを使用することができますが、パターンが英字以外の文字、つまり、大文字小文字の違いの影響がない文字で始まる場合のみです。
  </para>

  <para>
<!--
   B-tree indexes can also be used to retrieve data in sorted order.
   This is not always faster than a simple scan and sort, but it is
   often helpful.
-->
B-treeインデックスをソートされた順序でデータを受けとるために使用することもできます。
これは常に単純なスキャンとソート処理より高速になるものではありませんが、よく役に立つことがあります。
  </para>

  <para>
   <indexterm>
<!--
    <primary>index</primary>
    <secondary>hash</secondary>
-->
    <primary>インデックス</primary>
    <secondary>ハッシュ</secondary>
   </indexterm>
   <indexterm>
<!--
    <primary>hash</primary>
    <see>index</see>
-->
    <primary>ハッシュ</primary>
    <see>インデックス</see>
   </indexterm>
<!--
   Hash indexes can only handle simple equality comparisons.
   The query planner will consider using a hash index whenever an
   indexed column is involved in a comparison using the
   <literal>=</literal> operator.
   The following command is used to create a hash index:
-->
ハッシュインデックスは単純な等価性比較のみを扱うことができます。
問い合わせプランナでは、インデックスの付いた列を<literal>=</literal>演算子を使用して比較する場合に、ハッシュインデックスの使用を検討します。
ハッシュインデックスを作成するには、以下のようなコマンドを使用してください。
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> USING hash (<replaceable>column</replaceable>);
</synopsis>
  </para>

  <caution>
   <para>
<!--
    Hash index operations are not presently WAL-logged,
    so hash indexes might need to be rebuilt with <command>REINDEX</>
    after a database crash if there were unwritten changes.
    Also, changes to hash indexes are not replicated over streaming or
    file-based replication after the initial base backup, so they
    give wrong answers to queries that subsequently use them.
    For these reasons, hash index use is presently discouraged.
-->
現在ハッシュインデックス操作はWALに記録されません。
そのため、データベースクラッシュの後ハッシュインデックスを<command>REINDEX</>で再構築しなければならない可能性があります。
また、最初のバックアップを取得して以降、ストリーミングレプリケーションやファイルベースのレプリケーションでは変更が反映されないため、その後ハッシュインデックスを使うクエリは誤った結果を返します。
これらの理由により、ハッシュインデックスの使用は現在お勧めできません。
   </para>
  </caution>

  <para>
   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>GiST</primary>
<!--
    <see>index</see>
-->
    <see>インデックス</see>
   </indexterm>
<!--
   GiST indexes are not a single kind of index, but rather an infrastructure
   within which many different indexing strategies can be implemented.
   Accordingly, the particular operators with which a GiST index can be
   used vary depending on the indexing strategy (the <firstterm>operator
   class</>).  As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes GiST operator classes
   for several two-dimensional geometric data types, which support indexed
   queries using these operators:
-->
GiSTインデックスは単一種類のインデックスではなく、多くの異なるインデックス戦略を実装することができる基盤です。
したがって、具体的なGiSTインデックスで使用できる演算子はインデックス戦略（<firstterm>演算子クラス</>）によって異なります。
例えば、<productname>PostgreSQL</productname>の標準配布物には、複数の二次元幾何データ型用のGiST演算子クラスが含まれています。
これらの演算子を使用してインデックス付けされた問い合わせをサポートします。

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&amp;&lt;</literal></member>
    <member><literal>&amp;&gt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>&lt;&lt;|</literal></member>
    <member><literal>&amp;&lt;|</literal></member>
    <member><literal>|&amp;&gt;</literal></member>
    <member><literal>|&gt;&gt;</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

<!--
   (See <xref linkend="functions-geometry"> for the meaning of
   these operators.)
   The GiST operator classes included in the standard distribution are
   documented in <xref linkend="gist-builtin-opclasses-table">.
   Many other GiST operator
   classes are available in the <literal>contrib</> collection or as separate
   projects.  For more information see <xref linkend="GiST">.
-->
（これらの演算子の意味については<xref linkend="functions-geometry">を参照してください。）
標準配布物に含まれるGiST演算子クラスは<xref linkend="gist-builtin-opclasses-table">に記載されています。
他の多くのGiST演算子クラスが<literal>contrib</>群や別のプロジェクトとして利用可能です。
詳細は<xref linkend="GiST">を参照してください。
  </para>
  <para>
<!--
   GiST indexes are also capable of optimizing <quote>nearest-neighbor</>
   searches, such as
-->
GiSTインデックスは以下のような<quote>最近傍</>検索を最適化する機能も持ちます。
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
<!--
   which finds the ten places closest to a given target point.  The ability
   to do this is again dependent on the particular operator class being used.
   In <xref linkend="gist-builtin-opclasses-table">, operators that can be
   used in this way are listed in the column <quote>Ordering Operators</>.

-->
これは指定された対象地点に最も近い１０箇所を見つけ出します。
繰り返しますが、これができるかどうかは使用される特定の演算子クラスに依存します。
このように利用できる演算子は<xref linkend="gist-builtin-opclasses-table">の<quote>Ordering Operators</>列に表示されています。
  </para>

  <para>
   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>
   <indexterm>
    <primary>SP-GiST</primary>
<!--
    <see>index</see>
-->
    <see>インデックス</see>
   </indexterm>
<!--
   SP-GiST indexes, like GiST indexes, offer an infrastructure that supports
   various kinds of searches.  SP-GiST permits implementation of a wide range
   of different non-balanced disk-based data structures, such as quadtrees,
   k-d trees, and radix trees (tries).  As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes SP-GiST operator classes
   for two-dimensional points, which support indexed
   queries using these operators:
-->
SP-GiSTインデックスは、GiSTインデックスと同様に様々な種類の検索を支援する基盤を提供します。
SP-GiSTインデックスは広域な異なる不均衡でディスクベースのデータ構造、つまり、四分木,kd木、基数木のような実装を認めます。
例えば、<productname>PostgreSQL</productname>標準配布物には、以下の演算子を使用する問い合わせに対するインデックスをサポートする2次元の点用のSP-GiST用の演算子クラスが含まれています。

   <simplelist>
    <member><literal>&lt;&lt;</literal></member>
    <member><literal>&gt;&gt;</literal></member>
    <member><literal>~=</literal></member>
    <member><literal>&lt;@</literal></member>
    <member><literal>&lt;^</literal></member>
    <member><literal>&gt;^</literal></member>
   </simplelist>
<!--
   (See <xref linkend="functions-geometry"> for the meaning of
   these operators.)
   The SP-GiST operator classes included in the standard distribution are
   documented in <xref linkend="spgist-builtin-opclasses-table">.
   For more information see <xref linkend="SPGiST">.
-->
(演算子の意味は以下を参照してください<xref linkend="functions-geometry"> )
標準配布物に含まれるSP-GiSTクラスは<xref linkend="spgist-builtin-opclasses-table">に記載されています。
詳細は <xref linkend="SPGiST">を参照してください。

  </para>
  <para>
   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>GIN</secondary>
   </indexterm>
   <indexterm>
    <primary>GIN</primary>
<!--
    <see>index</see>
-->
    <see>インデックス</see>
   </indexterm>
<!--
   GIN indexes are inverted indexes which can handle values that contain more
   than one key, arrays for example. Like GiST and SP-GiST, GIN can support
   many different user-defined indexing strategies and the particular
   operators with which a GIN index can be used vary depending on the
   indexing strategy.
   As an example, the standard distribution of
   <productname>PostgreSQL</productname> includes GIN operator classes
   for one-dimensional arrays, which support indexed
   queries using these operators:
-->
GINは転置インデックスであり、例えば配列など複数のキーを持つ値を扱うことができます。
GiSTやSP-GiST同様、GINも多くの異なるユーザ定義のインデックス戦略を持つことができ、GINが使用できる具体的な演算子はインデックス戦略によって変化します。
例えば、<productname>PostgreSQL</productname>標準配布物には、1次元配列用のGIN演算子クラスが含まれています。
これは、以下の演算子を使用する問い合わせに対するインデックスをサポートします。

   <simplelist>
    <member><literal>&lt;@</literal></member>
    <member><literal>@&gt;</literal></member>
    <member><literal>=</literal></member>
    <member><literal>&amp;&amp;</literal></member>
   </simplelist>

<!--
   (See <xref linkend="functions-array"> for the meaning of
   these operators.)
   The GIN operator classes included in the standard distribution are
   documented in <xref linkend="gin-builtin-opclasses-table">.
   Many other GIN operator
   classes are available in the <literal>contrib</> collection or as separate
   projects.  For more information see <xref linkend="GIN">.
-->
（これらの演算子の意味については<xref linkend="functions-array">を参照してください。）
標準配布物に含まれるGIN演算子クラスは<xref linkend="gin-builtin-opclasses-table">に記載されています。
他の多くのGIN演算子クラスは<literal>contrib</>群または別のプロジェクトで利用可能です。
詳細は<xref linkend="GIN">を参照してください。
  </para>
 </sect1>


 <sect1 id="indexes-multicolumn">
<!--
  <title>Multicolumn Indexes</title>
-->
  <title>複数列インデックス</title>

  <indexterm zone="indexes-multicolumn">
<!--
   <primary>index</primary>
   <secondary>multicolumn</secondary>
-->
   <primary>インデックス</primary>
   <secondary>複数列</secondary>
  </indexterm>

  <para>
<!--
   An index can be defined on more than one column of a table.  For example, if
   you have a table of this form:
-->
インデックスは、テーブルの1つ以上の列に定義することができます。
例えば、以下のようなテーブルがあるとします。
<programlisting>
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</programlisting>
<!--
   (say, you keep your <filename class="directory">/dev</filename>
   directory in a database...) and you frequently issue queries like:
-->
（例えば、<filename class="directory">/dev</filename>ディレクトリの内容をデータベースに保持していて）頻繁に下記のような問い合わせを発行するとします。
<programlisting>
SELECT name FROM test2 WHERE major = <replaceable>constant</replaceable> AND minor = <replaceable>constant</replaceable>;
</programlisting>
<!--
   then it might be appropriate to define an index on the columns
   <structfield>major</structfield> and
   <structfield>minor</structfield> together, e.g.:
-->
このような場合、<structfield>major</structfield>および<structfield>minor</structfield>という２つの列に1つのインデックスを定義する方が適切かもしれません。
<programlisting>
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</programlisting>
  </para>

  <para>
<!--
   Currently, only the B-tree, GiST and GIN index types support multicolumn
   indexes.  Up to 32 columns can be specified.  (This limit can be
   altered when building <productname>PostgreSQL</productname>; see the
   file <filename>pg_config_manual.h</filename>.)
-->
現在、B-tree、GiST、およびGINインデックス型でのみ、複数列インデックスをサポートしています。
最高32列まで指定可能です。
（この上限は、<productname>PostgreSQL</productname>を構築する際に変更可能です。
<filename>pg_config_manual.h</filename>ファイルを参照してください。）
  </para>

  <para>
<!--
   A multicolumn B-tree index can be used with query conditions that
   involve any subset of the index's columns, but the index is most
   efficient when there are constraints on the leading (leftmost) columns.
   The exact rule is that equality constraints on leading columns, plus
   any inequality constraints on the first column that does not have an
   equality constraint, will be used to limit the portion of the index
   that is scanned.  Constraints on columns to the right of these columns
   are checked in the index, so they save visits to the table proper, but
   they do not reduce the portion of the index that has to be scanned.
   For example, given an index on <literal>(a, b, c)</literal> and a
   query condition <literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</>,
   the index would have to be scanned from the first entry with
   <literal>a</> = 5 and <literal>b</> = 42 up through the last entry with
   <literal>a</> = 5.  Index entries with <literal>c</> &gt;= 77 would be
   skipped, but they'd still have to be scanned through.
   This index could in principle be used for queries that have constraints
   on <literal>b</> and/or <literal>c</> with no constraint on <literal>a</>
   &mdash; but the entire index would have to be scanned, so in most cases
   the planner would prefer a sequential table scan over using the index.
-->
複数列に対するB-treeインデックスをインデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
しかし、先頭側の（左側）列に制約がある場合に、このインデックスはもっとも効率的になります。
正確な規則は、先頭側の列への等価制約、および、等価制約を持たない先頭列への不等号制約がスキャン対象のインデックス範囲を制限するために使用されます。
これらの列の右側の列に対する制約は、このインデックス内から検査されます。
ですので、テーブルアクセスを適切に抑えますが、スキャンされるインデックスの範囲を減らしません。
例えば、<literal>(a, b, c)</literal>に対するインデックスがあり、<literal>WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</>という問い合わせ条件があったとすると、
<literal>a</> = 5かつ<literal>b</> = 42を持つ項目を先頭に、<literal>a</> = 5となる最後の項目までのインデックスをスキャンしなければなりません。
<literal>c</> &gt;= 77を持つインデックス項目は飛ばされますが、スキャンを行わなければなりません。
このインデックスは原理上、 <literal>a</>に対する制約を持たない、<literal>b</>および<literal>c</>、あるいは、<literal>b</>または<literal>c</>を制約に持つ問い合わせで使用することができます。
しかし、インデックス全体がスキャンされますので、ほとんどの場合、プランナはインデックスの使用よりもシーケンシャルテーブルスキャンを選択します。
  </para>

  <para>
<!--
   A multicolumn GiST index can be used with query conditions that
   involve any subset of the index's columns. Conditions on additional
   columns restrict the entries returned by the index, but the condition on
   the first column is the most important one for determining how much of
   the index needs to be scanned.  A GiST index will be relatively
   ineffective if its first column has only a few distinct values, even if
   there are many distinct values in additional columns.
-->
複数列GiSTインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
他の列に対する条件は、インデックスで返される項目を制限します。
しかし、先頭列に対する条件が、インデックスのスキャン量を決定するもっとも重要なものです。
先頭列の個別値がわずかな場合、他の列が多くの個別値を持っていたとしても、相対的にGiSTインデックスは非効率的になります。
  </para>

  <para>
<!--
   A multicolumn GIN index can be used with query conditions that
   involve any subset of the index's columns. Unlike B-tree or GiST,
   index search effectiveness is the same regardless of which index column(s)
   the query conditions use.
-->
複数列GINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
B-TreeやGiSTと異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
  </para>

  <para>
<!--
   Of course, each column must be used with operators appropriate to the index
   type; clauses that involve other operators will not be considered.
-->
当然ながら、インデックス種類に対して適切な演算子を各列に使用しなければなりません。
他の演算子を含む句は考慮されません。
  </para>

  <para>
<!--
   Multicolumn indexes should be used sparingly.  In most situations,
   an index on a single column is sufficient and saves space and time.
   Indexes with more than three columns are unlikely to be helpful
   unless the usage of the table is extremely stylized.  See also
   <xref linkend="indexes-bitmap-scans"> for some discussion of the
   merits of different index configurations.
-->
複数列インデックスは慎重に使用する必要があります。
多くの場合、単一列のインデックスで十分であり、また、その方がディスク領域と時間を節約できます。
テーブルの使用方法が極端に様式化されていない限り、3つ以上の列を使用しているインデックスは、ほぼ間違いなく不適切であると言えます。
異なるインデックス構成の利点に関するこの他の説明について<xref linkend="indexes-bitmap-scans">も参照してください。
  </para>
 </sect1>


 <sect1 id="indexes-ordering">
<!--
  <title>Indexes and <literal>ORDER BY</></title>
-->
  <title>インデックスと<literal>ORDER BY</></title>

  <indexterm zone="indexes-ordering">
<!--
   <primary>index</primary>
   <secondary>and <literal>ORDER BY</></secondary>
-->
   <primary>インデックス</primary>
   <secondary>と<literal>ORDER BY</></secondary>
  </indexterm>

  <para>
<!--
   In addition to simply finding the rows to be returned by a query,
   an index may be able to deliver them in a specific sorted order.
   This allows a query's <literal>ORDER BY</> specification to be honored
   without a separate sorting step.  Of the index types currently
   supported by <productname>PostgreSQL</productname>, only B-tree
   can produce sorted output &mdash; the other index types return
   matching rows in an unspecified, implementation-dependent order.
-->
単に問い合わせによって返される行を見つけ出すだけではなく、インデックスは、その行を指定した順番で取り出すことができます。
これにより、別途ソート処理を行うことなく、問い合わせの<literal>ORDER BY</>指定に従うことが可能です。
<productname>PostgreSQL</productname>が現在サポートするインデックスの種類の中で、B-Treeのみがソート出力を行うことができます。
他の種類のインデックスでは指定なし、または、実装固有の順序で一致した行を返します。
  </para>

  <para>
<!--
   The planner will consider satisfying an <literal>ORDER BY</> specification
   either by scanning an available index that matches the specification,
   or by scanning the table in physical order and doing an explicit
   sort.  For a query that requires scanning a large fraction of the
   table, an explicit sort is likely to be faster than using an index
   because it requires
   less disk I/O due to following a sequential access pattern.  Indexes are
   more useful when only a few rows need be fetched.  An important
   special case is <literal>ORDER BY</> in combination with
   <literal>LIMIT</> <replaceable>n</>: an explicit sort will have to process
   all the data to identify the first <replaceable>n</> rows, but if there is
   an index matching the <literal>ORDER BY</>, the first <replaceable>n</>
   rows can be retrieved directly, without scanning the remainder at all.
-->
プランナは、指定に一致し利用可能なインデックスでスキャンする、または、テーブルを物理的な順番でスキャンし明示的なソートを行うことにより、<literal>ORDER BY</>指定を満足させるかを考慮します。
テーブルの大部分のスキャンが必要な問い合わせでは、後に発生するシーケンシャルなアクセスパターンのために要求されるディスクI/Oが少ないため、インデックスを使用するよりも、明示的なソートの方が高速です。
数行を取り出す必要がある場合のみ、インデックスの方が有用になります。
<literal>ORDER BY</>と<literal>LIMIT</> <replaceable>n</>が組み合わされた場合が、重要かつ特別です。
先頭の<replaceable>n</>行を識別するために、明示的なソートを全データに対して行う必要があります。
しかし、もし<literal>ORDER BY</>に合うインデックスが存在すれば、残りの部分をスキャンすることなく、先頭の<replaceable>n</>行の取り出しを直接行うことができます。
  </para>

  <para>
<!--
   By default, B-tree indexes store their entries in ascending order
   with nulls last.  This means that a forward scan of an index on
   column <literal>x</> produces output satisfying <literal>ORDER BY x</>
   (or more verbosely, <literal>ORDER BY x ASC NULLS LAST</>).  The
   index can also be scanned backward, producing output satisfying
   <literal>ORDER BY x DESC</>
   (or more verbosely, <literal>ORDER BY x DESC NULLS FIRST</>, since
   <literal>NULLS FIRST</> is the default for <literal>ORDER BY DESC</>).
-->
デフォルトでは、B-Treeインデックスは項目を昇順で格納し、NULLを最後に格納します。
これは、<literal>x</>列に対するインデックスの前方方向のスキャンで<literal>ORDER BY x</>（より冗長にいえば<literal>ORDER BY x ASC NULLS LAST</>）を満たす出力を生成することを意味します。
また、インデックスを後方方向にスキャンすることもでき、この場合、<literal>ORDER BY x DESC</>（より冗長にいえば<literal>ORDER BY x DESC NULLS FIRST</>。<literal>NULLS FIRST</>が<literal>ORDER BY DESC</>のデフォルトだからです。）を満たす出力を生成します。
  </para>

  <para>
<!--
   You can adjust the ordering of a B-tree index by including the
   options <literal>ASC</>, <literal>DESC</>, <literal>NULLS FIRST</>,
   and/or <literal>NULLS LAST</> when creating the index; for example:
-->
インデックスを作成する時に、以下のように<literal>ASC</>、<literal>DESC</>、<literal>NULLS FIRST</>、<literal>NULLS LAST</>オプションを組み合わせて指定することにより、B-Treeインデックスの順序を調整することができます。
<programlisting>
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</programlisting>
<!--
   An index stored in ascending order with nulls first can satisfy
   either <literal>ORDER BY x ASC NULLS FIRST</> or
   <literal>ORDER BY x DESC NULLS LAST</> depending on which direction
   it is scanned in.
-->
昇順かつNULL先頭という順で格納されたインデックスは、スキャンされる方向に依存して<literal>ORDER BY x ASC NULLS FIRST</>または<literal>ORDER BY x DESC NULLS LAST</>を満たすことができます。
  </para>

  <para>
<!--
   You might wonder why bother providing all four options, when two
   options together with the possibility of backward scan would cover
   all the variants of <literal>ORDER BY</>.  In single-column indexes
   the options are indeed redundant, but in multicolumn indexes they can be
   useful.  Consider a two-column index on <literal>(x, y)</>: this can
   satisfy <literal>ORDER BY x, y</> if we scan forward, or
   <literal>ORDER BY x DESC, y DESC</> if we scan backward.
   But it might be that the application frequently needs to use
   <literal>ORDER BY x ASC, y DESC</>.  There is no way to get that
   ordering from a plain index, but it is possible if the index is defined
   as <literal>(x ASC, y DESC)</> or <literal>(x DESC, y ASC)</>.
-->
4つの全方向を提供する理由が何か、後方方向へのスキャンの可能性があることを考慮した2方向で、すべての種類の<literal>ORDER BY</>を網羅できるのではないかと疑問を持つかもしえません。
単一列に対するインデックスでは、このオプションは実際冗長ですが、複数列に対するインデックスでは有用になります。
<literal>(x, y)</>という2つの列に対するインデックスを仮定します。
これを前方方向にスキャンすれば<literal>ORDER BY x, y</>を満たし、後方方向にスキャンすれば<literal>ORDER BY x DESC, y DESC</>を満たします。
しかし、<literal>ORDER BY x ASC, y DESC</>をよく使用しなければならないアプリケーションが存在する可能性があります。
簡素なインデックスからこの順序を取り出す方法がありません。
しかし、インデックスが<literal>(x ASC, y DESC)</>または<literal>(x DESC, y ASC)</>として定義されていれば、取り出すことができます。
  </para>

  <para>
<!--
   Obviously, indexes with non-default sort orderings are a fairly
   specialized feature, but sometimes they can produce tremendous
   speedups for certain queries.  Whether it's worth maintaining such an
   index depends on how often you use queries that require a special
   sort ordering.
-->
明確なことですが、デフォルト以外のソート順を持つインデックスはかなり特殊な機能です。
しかし、特定の問い合わせにおいては恐ろしいほどの速度を向上させることがあります。
こうしたインデックスを維持する価値があるかどうかは、特殊なソート順を要求する問い合わせを使用する頻度に依存します。
  </para>
 </sect1>


 <sect1 id="indexes-bitmap-scans">
<!--
  <title>Combining Multiple Indexes</title>
-->
  <title>複数のインデックスの組み合わせ</title>

  <indexterm zone="indexes-bitmap-scans">
<!--
   <primary>index</primary>
   <secondary>combining multiple indexes</secondary>
-->
   <primary>インデックス</primary>
   <secondary>複数のインデックスの組み合わせ</secondary>
  </indexterm>

  <indexterm zone="indexes-bitmap-scans">
<!--
   <primary>bitmap scan</primary>
-->
   <primary>ビットマップスキャン</primary>
  </indexterm>

  <para>
<!--
   A single index scan can only use query clauses that use the index's
   columns with operators of its operator class and are joined with
   <literal>AND</>.  For example, given an index on <literal>(a, b)</literal>
   a query condition like <literal>WHERE a = 5 AND b = 6</> could
   use the index, but a query like <literal>WHERE a = 5 OR b = 6</> could not
   directly use the index.
-->
単一のインデックススキャンは、インデックスの列をその演算子クラスの演算子で使用する問い合わせ句と、それを<literal>AND</>結合したものでのみ使用されます。
例えば、<literal>(a, b)</literal>というインデックスと<literal>WHERE a = 5 AND b = 6</>という問い合わせでは、インデックスが使用されます。
しかし、<literal>WHERE a = 5 OR b = 6</>のような問い合わせではインデックスは直接使用されません。
  </para>

  <para>
<!--
   Fortunately,
   <productname>PostgreSQL</> has the ability to combine multiple indexes
   (including multiple uses of the same index) to handle cases that cannot
   be implemented by single index scans.  The system can form <literal>AND</>
   and <literal>OR</> conditions across several index scans.  For example,
   a query like <literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</>
   could be broken down into four separate scans of an index on <literal>x</>,
   each scan using one of the query clauses.  The results of these scans are
   then ORed together to produce the result.  Another example is that if we
   have separate indexes on <literal>x</> and <literal>y</>, one possible
   implementation of a query like <literal>WHERE x = 5 AND y = 6</> is to
   use each index with the appropriate query clause and then AND together
   the index results to identify the result rows.
-->
幸いにも、<productname>PostgreSQL</>は、単一のインデックススキャンでは実装できない場合を扱うために、複数のインデックス（同じインデックスの複数回使用を含む）を組み合わせる機能を持ちます。
システムは複数のインデックススキャンを跨がる、条件の<literal>AND</>または<literal>OR</>を形成します。
例えば、
<literal>WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</>という問い合わせは、問い合わせ句の1つを使用して<literal>x</>上のインデックスをスキャンする4つのスキャンに分割することができます。
その後、これらのスキャンの結果はOR演算でまとめられ、結果を生成します。
他の例として<literal>x</>と<literal>y</>に別個のインデックスがある場合を考えます。
<literal>WHERE x = 5 AND y = 6</>のような問い合わせに対して取り得る実装は、適切な問い合わせ句で各インデックスを使用し、インデックスの結果をANDでまとめ、結果行を識別することです。
  </para>

  <para>
<!--
   To combine multiple indexes, the system scans each needed index and
   prepares a <firstterm>bitmap</> in memory giving the locations of
   table rows that are reported as matching that index's conditions.
   The bitmaps are then ANDed and ORed together as needed by the query.
   Finally, the actual table rows are visited and returned.  The table rows
   are visited in physical order, because that is how the bitmap is laid
   out; this means that any ordering of the original indexes is lost, and
   so a separate sort step will be needed if the query has an <literal>ORDER
   BY</> clause.  For this reason, and because each additional index scan
   adds extra time, the planner will sometimes choose to use a simple index
   scan even though additional indexes are available that could have been
   used as well.
-->
複数のインデックスを組み合わせるために、システムは必要なインデックスそれぞれをスキャンし、インデックス条件に一致するものと報告されたテーブル行の位置を与えるためにメモリ上に<firstterm>ビットマップ</>を準備します。
その後、このビットマップは問い合わせで必要とされたように、ANDまたはOR演算されます。
最後に、実際のテーブル行がアクセスされ、返されます。
テーブル行は物理的な順番でアクセスされます。
ビットマップにこの順番で格納されているからです。
これは、元のインデックスの順序が失われていることを意味します。
そのため、もし問い合わせが<literal>ORDER BY</>句を持つ場合、この他のソート手続きが必要となります。
この理由、および、追加のインデックススキャンそれぞれのために余計な時間が加わることから、プランナは追加のインデックスが同様に使用できる場合であっても、単純なインデックススキャンを選択することがあります。
  </para>

  <para>
<!--
   In all but the simplest applications, there are various combinations of
   indexes that might be useful, and the database developer must make
   trade-offs to decide which indexes to provide.  Sometimes multicolumn
   indexes are best, but sometimes it's better to create separate indexes
   and rely on the index-combination feature.  For example, if your
   workload includes a mix of queries that sometimes involve only column
   <literal>x</>, sometimes only column <literal>y</>, and sometimes both
   columns, you might choose to create two separate indexes on
   <literal>x</> and <literal>y</>, relying on index combination to
   process the queries that use both columns.  You could also create a
   multicolumn index on <literal>(x, y)</>.  This index would typically be
   more efficient than index combination for queries involving both
   columns, but as discussed in <xref linkend="indexes-multicolumn">, it
   would be almost useless for queries involving only <literal>y</>, so it
   should not be the only index.  A combination of the multicolumn index
   and a separate index on <literal>y</> would serve reasonably well.  For
   queries involving only <literal>x</>, the multicolumn index could be
   used, though it would be larger and hence slower than an index on
   <literal>x</> alone.  The last alternative is to create all three
   indexes, but this is probably only reasonable if the table is searched
   much more often than it is updated and all three types of query are
   common.  If one of the types of query is much less common than the
   others, you'd probably settle for creating just the two indexes that
   best match the common types.
-->
もっとも単純なアプリケーション以外のほとんどすべてのアプリケーションでは、インデックスの有用な組み合わせはいろいろあります。
このため、データベース開発者は妥協点を探してどのようなインデックスを提供するかを決定しなければなりません。
複数列インデックスが最善な場合がありますし、別々のインデックスを作成し、インデックスの組み合わせ機能に依存する方が優れている場合もあります。
例えば、作業に<literal>x</>列のみを含む場合と<literal>y</>列のみを含む場合、両方の列を含む場合が混在する問い合わせが含まれる場合、<literal>x</>と<literal>y</>に対し、別個に2つのインデックスを作成し、両方の列を使用する問い合わせを処理する時にインデックスの組み合わせに依存することを選ぶことができます。
また、<literal>(x, y)</>に対する複数列インデックスを作成することもできます。
両方の列を含む問い合わせでは、通常このインデックスの方がインデックスの組み合わせよりも効率的です。
しかし、<xref linkend="indexes-multicolumn">で説明した通り、<literal>y</>のみを含む問い合わせではほとんど意味がありません。
従って、このインデックスのみとすることはできません。
複数列インデックスと<literal>y</>に対する別のインデックスの組み合わせがかなりよく役に立ちます。
<literal>x</>のみを含む問い合わせでは、複数列インデックスを使用することができます。
しかし、これはより大きくなりますので、<literal>x</> のみインデックスよりも低速になります。
最後の別方法は、3つのインデックスすべてを作成することです。
しかしこれはおそらく、テーブルの検索頻度が更新頻度よりもかなり高く、3種類の問い合わせすべてが良く使用される場合のみ合理的です。
問い合わせの中の1つの頻度が他よりも少なければ、おそらく良く使用される種類にもっとも合うように2つだけインデックスを作成した方がよいでしょう。
  </para>

 </sect1>


 <sect1 id="indexes-unique">
<!--
  <title>Unique Indexes</title>
-->
  <title>一意インデックス</title>

  <indexterm zone="indexes-unique">
<!--
   <primary>index</primary>
   <secondary>unique</secondary>
-->
   <primary>インデックス</primary>
   <secondary>一意</secondary>
  </indexterm>

  <para>
<!--
   Indexes can also be used to enforce uniqueness of a column's value,
   or the uniqueness of the combined values of more than one column.
-->
インデックスは、列値の一意性や、複数列を組み合わせた値の一意性を強制するためにも使用できます。
<synopsis>
CREATE UNIQUE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <optional>, ...</optional>);
</synopsis>
<!--
   Currently, only B-tree indexes can be declared unique.
-->
現在、一意インデックスとして宣言できるのはB-treeインデックスのみです。
  </para>

  <para>
<!--
   When an index is declared unique, multiple table rows with equal
   indexed values are not allowed.  Null values are not considered
   equal.  A multicolumn unique index will only reject cases where all
   indexed columns are equal in multiple rows.
-->
一意インデックスが宣言された場合、同じインデックス値を有する複数のテーブル行は許されなくなります。
NULL 値は同じ値とはみなされません。
複数列の一意インデックスは、複数の行でインデックス列の全てが同一の場合のみ拒絶されます。
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname> automatically creates a unique
   index when a unique constraint or primary key is defined for a table.
   The index covers the columns that make up the primary key or unique
   constraint (a multicolumn index, if appropriate), and is the mechanism
   that enforces the constraint.
-->
<productname>PostgreSQL</productname>では、テーブルに一意性制約またはプライマリキーが定義されると、自動的に一意インデックスを作成します。
このインデックスが、プライマリキーや一意性制約（適切ならば複数列のインデックスで）となる列に対して作成され、この制約を強制する機構となります。
  </para>

  <note>
   <para>
<!--
    The preferred way to add a unique constraint to a table is
    <literal>ALTER TABLE ... ADD CONSTRAINT</literal>.  The use of
    indexes to enforce unique constraints could be considered an
    implementation detail that should not be accessed directly.
    One should, however, be aware that there's no need to manually
    create indexes on unique columns; doing so would just duplicate
    the automatically-created index.
-->
テーブルに一意性制約を追加するためによく使用される方法は、<literal>ALTER TABLE ... ADD CONSTRAINT</literal>です。
一意性制約を課すためのインデックスの用法は、直接アクセスしてはならない実装の細部とみなされることがあります。
しかし、手作業で一意列に対しインデックスを作成する必要がないことには注意してください。
これは、単に自動作成されるインデックスを二重にするだけです。
   </para>
  </note>
 </sect1>


 <sect1 id="indexes-expressional">
<!--
  <title>Indexes on Expressions</title>
-->
  <title>式に対するインデックス</title>

  <indexterm zone="indexes-expressional">
<!--
   <primary>index</primary>
   <secondary sortas="expressions">on expressions</secondary>
-->
   <primary>インデックス</primary>
   <secondary sortas="expressions">式に対する</secondary>
  </indexterm>

  <para>
<!--
   An index column need not be just a column of the underlying table,
   but can be a function or scalar expression computed from one or
   more columns of the table.  This feature is useful to obtain fast
   access to tables based on the results of computations.
-->
インデックス列は、基礎をなすテーブルにある列である必要はなく、そのテーブルの１つ以上の列から計算される関数やスカラ式とすることもできます。
この機能は、ある演算結果に基づいた高速テーブルアクセスを行う時に有用です。
  </para>

  <para>
<!--
   For example, a common way to do case-insensitive comparisons is to
   use the <function>lower</function> function:
-->
例えば、大文字小文字を区別せずに比較するための一般的な方法である、<function>lower</function>関数での使用例を以下に示します。
<programlisting>
SELECT * FROM test1 WHERE lower(col1) = 'value';
</programlisting>
<!--
   This query can use an index if one has been
   defined on the result of the <literal>lower(col1)</literal>
   function:
-->
<literal>lower(column)</literal>関数の結果にインデックスが定義されていれば、この問い合わせでインデックスを使用することができます。
<programlisting>
CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));
</programlisting>
  </para>

  <para>
<!--
   If we were to declare this index <literal>UNIQUE</>, it would prevent
   creation of rows whose <literal>col1</> values differ only in case,
   as well as rows whose <literal>col1</> values are actually identical.
   Thus, indexes on expressions can be used to enforce constraints that
   are not definable as simple unique constraints.
-->
このインデックスを<literal>UNIQUE</>と宣言したとすると、<literal>col1</>の値が同一となる行だけでなく、<literal>col1</>の大文字小文字だけが違う行の生成を防ぐことになります。
したがって、式に対するインデックスを使用して、単なる一意性制約では定義できないような制約を強制することができます。
  </para>

  <para>
<!--
   As another example, if one often does queries like:
-->
別の例として、以下のような問い合わせが頻繁に行われる場合を考えます。
<programlisting>
SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';
</programlisting>
<!--
   then it might be worth creating an index like this:
-->
この場合、以下のようなインデックスを作成する価値があるでしょう。
<programlisting>
CREATE INDEX people_names ON people ((first_name || ' ' || last_name));
</programlisting>
  </para>

  <para>
<!--
   The syntax of the <command>CREATE INDEX</> command normally requires
   writing parentheses around index expressions, as shown in the second
   example.  The parentheses can be omitted when the expression is just
   a function call, as in the first example.
-->
２番目の例に示すように<command>CREATE INDEX</>コマンドの構文は通常、インデックス式を括弧で括る必要があります。
最初の例のように、式が単なる関数呼び出しの場合には括弧を省略することができます。
  </para>

  <para>
<!--
   Index expressions are relatively expensive to maintain, because the
   derived expression(s) must be computed for each row upon insertion
   and whenever it is updated.  However, the index expressions are
   <emphasis>not</> recomputed during an indexed search, since they are
   already stored in the index.  In both examples above, the system
   sees the query as just <literal>WHERE indexedcolumn = 'constant'</>
   and so the speed of the search is equivalent to any other simple index
   query.  Thus, indexes on expressions are useful when retrieval speed
   is more important than insertion and update speed.
-->
派生した式が、行が挿入、更新される度に実行されなければなりませんので、インデックス式は相対的に見て維持が高価です。
しかし、インデックス式はインデックスを使用する検索の間で再計算<emphasis>されません</>。
上の両方の例では、システムは問い合わせを単なる<literal>WHERE indexedcolumn = 'constant'</>と理解しますので、この検索速度は他の単純なインデックス問い合わせと同じです。
したがって、式に対するインデックスは取り出し速度が挿入、更新速度より重要な場合にのみ有用です。
  </para>
 </sect1>


 <sect1 id="indexes-partial">
<!--
  <title>Partial Indexes</title>
-->
  <title>部分インデックス</title>

  <indexterm zone="indexes-partial">
<!--
   <primary>index</primary>
   <secondary>partial</secondary>
-->
   <primary>インデックス</primary>
   <secondary>部分</secondary>
  </indexterm>

  <para>
<!--
   A <firstterm>partial index</firstterm> is an index built over a
   subset of a table; the subset is defined by a conditional
   expression (called the <firstterm>predicate</firstterm> of the
   partial index).  The index contains entries only for those table
   rows that satisfy the predicate.  Partial indexes are a specialized
   feature, but there are several situations in which they are useful.
-->
<firstterm>部分インデックス</firstterm>とは、テーブルの部分集合に構築されるインデックスです。
部分集合は、（部分インデックスの<firstterm>述語</firstterm>と呼ばれる）条件式で定義されます。
部分インデックスには、その述語を満たすテーブル行のみに対するエントリが含まれます。 
部分インデックスは特別な機能です。
しかし、これらが有用となる状況が複数あります。
  </para>

  <para>
<!--
   One major reason for using a partial index is to avoid indexing common
   values.  Since a query searching for a common value (one that
   accounts for more than a few percent of all the table rows) will not
   use the index anyway, there is no point in keeping those rows in the
   index at all.  This reduces the size of the index, which will speed
   up those queries that do use the index.  It will also speed up many table
   update operations because the index does not need to be
   updated in all cases.  <xref linkend="indexes-partial-ex1"> shows a
   possible application of this idea.
-->
部分インデックスを利用する主な目的は、頻出値に対してインデックスを作成しないようにすることです。
（テーブル全体の行のうち、数パーセント以上を占める）頻出値を検索する問い合わせでは、いかなる場合でもインデックスを使用しないため、インデックスにそれらの行を持ち続けることは全く意味がありません。
これによりインデックスのサイズが小さくなりますので、インデックスを使用する問い合わせが速くなります。
また、インデックスを更新する必要のないケースも生じるため、テーブルを更新する作業の多くも速くなります。
<xref linkend="indexes-partial-ex1">にこの概念に基づいた用例を示します。
  </para>

  <example id="indexes-partial-ex1">
<!--
   <title>Setting up a Partial Index to Exclude Common Values</title>
-->
   <title>頻出値を除外するための部分インデックスの作成</title>

   <para>
<!--
    Suppose you are storing web server access logs in a database.
    Most accesses originate from the IP address range of your organization but
    some are from elsewhere (say, employees on dial-up connections).
    If your searches by IP are primarily for outside accesses,
    you probably do not need to index the IP range that corresponds to your
    organization's subnet.
-->
ウェブサーバのアクセスログをデータベースに格納しているとします。
多くのアクセスは、社内のIPアドレスの範囲内から発信されています。
しかし、範囲外のアドレス（例えば、社員がダイアルアップ接続している場所）からの発信もあります。
主に範囲外からのアクセスをIPアドレスで検索する場合、社内のサブネットに該当するIPアドレスの範囲にインデックスを作成する必要はないでしょう。
   </para>

   <para>
<!--
    Assume a table like this:
-->
以下のようなテーブルがあると想定します。
<programlisting>
CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);
</programlisting>
   </para>

   <para>
<!--
    To create a partial index that suits our example, use a command
    such as this:
-->
この例に適する部分インデックスを作成するには、以下のようなコマンドを使用します。
<programlisting>
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');
</programlisting>
   </para>

   <para>
<!--
    A typical query that can use this index would be:
-->
このインデックスを使用できる問い合わせの典型的な例は、以下のようなものです。
<programlisting>
SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';
</programlisting>
<!--
    A query that cannot use this index is:
-->
また、以下のような問い合わせの場合、このインデックスは使用できません。
<programlisting>
SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';
</programlisting>
   </para>

   <para>
<!--
    Observe that this kind of partial index requires that the common
    values be predetermined, so such partial indexes are best used for
    data distributions that do not change.  The indexes can be recreated
    occasionally to adjust for new data distributions, but this adds
    maintenance effort.
-->
このような部分インデックスを使用するには、あらかじめ頻出値が何であるかを知っている必要があることに注意してください。
値の分布が変わらない場合に、このような部分インデックスが最善です。
新しいデータの分布を調整するためにときたまインデックスを再作成することも可能ですが、これはメンテナンス作業を増やしてしまいます。
   </para>
  </example>

  <para>
<!--
   Another possible use for a partial index is to exclude values from the
   index that the
   typical query workload is not interested in; this is shown in <xref
   linkend="indexes-partial-ex2">.  This results in the same
   advantages as listed above, but it prevents the
   <quote>uninteresting</quote> values from being accessed via that
   index, even if an index scan might be profitable in that
   case.  Obviously, setting up partial indexes for this kind of
   scenario will require a lot of care and experimentation.
-->
部分インデックスを使用する有効な他の方法としては、一般的な問い合わせに必要のない値をインデックスから取り除くことです。
<xref linkend="indexes-partial-ex2">を参照してください。
この方法の利点は上で示したものと同じです。
ただ、この方法を使用すると、インデックススキャンが適している場合でも、<quote>必要のない</quote>値へのインデックスを介したアクセスが防止されてしまいます。
以上のことから明白なように、このようなケースで部分インデックスを作成する際は、細心の注意を払い、十分な検証を行う必要があります。
  </para>

  <example id="indexes-partial-ex2">
<!--
   <title>Setting up a Partial Index to Exclude Uninteresting Values</title>
-->
   <title>必要のない値を除外するための部分インデックスの作成</title>

   <para>
<!--
    If you have a table that contains both billed and unbilled orders,
    where the unbilled orders take up a small fraction of the total
    table and yet those are the most-accessed rows, you can improve
    performance by creating an index on just the unbilled rows.  The
    command to create the index would look like this:
-->
支払済み注文書および未支払注文書からなる、１つのテーブルがあるとします。
そして、未支払注文書の方がテーブル全体に対する割合が小さく、かつその部分へのアクセス数が最も多かったとします。
このような場合、未支払の行のみにインデックスを作成することにより、性能を向上させることができます。
インデックスの作成には、以下のようなコマンドを使用します。
<programlisting>
CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;
</programlisting>
   </para>

   <para>
<!--
    A possible query to use this index would be:
-->
このインデックスを使用する問い合わせの例としては、次のものが考えられます。
<programlisting>
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;
</programlisting>
<!--
    However, the index can also be used in queries that do not involve
    <structfield>order_nr</> at all, e.g.:
-->
しかし、このインデックスは、<structfield>order_nr</>をまったく使用しない問い合わせでも使用することができます。
以下は、その例です。
<programlisting>
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;
</programlisting>
<!--
    This is not as efficient as a partial index on the
    <structfield>amount</> column would be, since the system has to
    scan the entire index.  Yet, if there are relatively few unbilled
    orders, using this partial index just to find the unbilled orders
    could be a win.
-->
この問い合わせでは、システムがインデックス全体を検索する必要があるため、<structfield>amount</>列に部分インデックスを作成した場合ほど効率は良くありません。
しかし、未支払注文書データが比較的少ない場合は、この部分インデックスを未支払注文書を検出するためだけに使用した方が効率が良い可能性があります。
   </para>

   <para>
<!--
    Note that this query cannot use this index:
-->
以下の問い合わせでは、このインデックスを使用できないことに注意してください。
<programlisting>
SELECT * FROM orders WHERE order_nr = 3501;
</programlisting>
<!--
    The order 3501 might be among the billed or unbilled
    orders.
-->
注文番号3501は支払済みかもしれませんし、未支払かもしれないからです。
   </para>
  </example>

  <para>
<!--
   <xref linkend="indexes-partial-ex2"> also illustrates that the
   indexed column and the column used in the predicate do not need to
   match.  <productname>PostgreSQL</productname> supports partial
   indexes with arbitrary predicates, so long as only columns of the
   table being indexed are involved.  However, keep in mind that the
   predicate must match the conditions used in the queries that
   are supposed to benefit from the index.  To be precise, a partial
   index can be used in a query only if the system can recognize that
   the <literal>WHERE</> condition of the query mathematically implies
   the predicate of the index.
   <productname>PostgreSQL</productname> does not have a sophisticated
   theorem prover that can recognize mathematically equivalent
   expressions that are written in different forms.  (Not
   only is such a general theorem prover extremely difficult to
   create, it would probably be too slow to be of any real use.)
   The system can recognize simple inequality implications, for example
   <quote>x &lt; 1</quote> implies <quote>x &lt; 2</quote>; otherwise
   the predicate condition must exactly match part of the query's
   <literal>WHERE</> condition
   or the index will not be recognized as usable. Matching takes
   place at query planning time, not at run time. As a result,
   parameterized query clauses do not work with a partial index. For
   example a prepared query with a parameter might specify
   <quote>x &lt; ?</quote> which will never imply
   <quote>x &lt; 2</quote> for all possible values of the parameter.
-->
<xref linkend="indexes-partial-ex2">でもわかるように、インデックスが付けられた列名と、述語で使用されている列名は、一致している必要はありません。
<productname>PostgreSQL</productname>では、インデックス付けされるテーブルの列だけが含まれているのなら、任意の述語で部分インデックスを使用できます。
しかし、この述語は、インデックスを使用させたい問い合わせの条件と一致する必要があることに留意してください。
正確に言うと、部分インデックスを問い合わせで使用できるのは、インデックスの述語が問い合わせの<literal>WHERE</>条件に数学的に当てはまるとシステムが判断できる場合のみです。
<productname>PostgreSQL</productname>には、異なった形式で記述された述語が数学的に同等のものであると判断できるような、洗練された定理証明機能はありません。
（そのような汎用的な定理証明機能の作成は、非常に困難であるだけではなく、おそらく実際の利用にはあまりにも実行速度が遅過ぎるでしょう。）
システムでは、例えば<quote>x &lt; 1</quote>は<quote>x &lt; 2</quote>を意味するというような、単純な比較演算子の意味は認識可能です。
しかし、それ以外の場合は、述語条件は問い合わせの<literal>WHERE</>条件と完全に一致している必要があります。
一致していない場合は、インデックスは使用可能と認識されません。
一致するかどうかは、実行時ではなく、問い合わせ計画作成時に判定されます。
したがって、パラメータ付きの問い合わせでは部分インデックスは動作しません。
たとえば、<quote>x &lt; ?</quote>と指定されたパラメータを持つ、プリペアド問い合わせでは、どのようなパラメータ値であっても<quote>x &lt; 2</quote>を表しません。
  </para>

  <para>
<!--
   A third possible use for partial indexes does not require the
   index to be used in queries at all.  The idea here is to create
   a unique index over a subset of a table, as in <xref
   linkend="indexes-partial-ex3">.  This enforces uniqueness
   among the rows that satisfy the index predicate, without constraining
   those that do not.
-->
部分インデックスの考えられる３つ目の用法では、問い合わせでインデックスをまったく使用しません。
この考え方は、テーブルの部分集合に一意インデックスを作成するというものです。
<xref linkend="indexes-partial-ex3">を参照してください。
これにより、インデックスの述語を満たさない行を制約することなく、その述語を満たす行での一意性を強制します。
  </para>

  <example id="indexes-partial-ex3">
<!--
   <title>Setting up a Partial Unique Index</title>
-->
   <title>一意な部分インデックスの作成</title>

   <para>
<!--
    Suppose that we have a table describing test outcomes.  We wish
    to ensure that there is only one <quote>successful</> entry for
    a given subject and target combination, but there might be any number of
    <quote>unsuccessful</> entries.  Here is one way to do it:
-->
テストの結果が格納されているテーブルがあるとします。
与えられた件名（subject）および対象（target）の組み合わせに対して、<quote>成功</>のエントリが確実に1つしかないようにします。
<quote>失敗</>のエントリは、複数あっても構いません。
以下に、これを実行する一例を示します。
<programlisting>
CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</programlisting>
<!--
    This is a particularly efficient approach when there are few
    successful tests and many unsuccessful ones.
-->
これは、成功するテストがほとんどなく、失敗するテストが多い場合に特に有効な手法です。
   </para>
  </example>

  <para>
<!--
   Finally, a partial index can also be used to override the system's
   query plan choices.  Also, data sets with peculiar
   distributions might cause the system to use an index when it really
   should not.  In that case the index can be set up so that it is not
   available for the offending query.  Normally,
   <productname>PostgreSQL</> makes reasonable choices about index
   usage (e.g., it avoids them when retrieving common values, so the
   earlier example really only saves index size, it is not required to
   avoid index usage), and grossly incorrect plan choices are cause
   for a bug report.
-->
最後に、部分インデックスは、システムの問い合わせ計画の選択を変更するためにも使用できます。
特殊なデータ分布を持つデータ集合では、システムが実際には使用すべきでないインデックスを使用してしまうことがあります。
このような場合、特定の問い合わせでは使用することができないインデックスを設定することができます。
通常、<productname>PostgreSQL</>はインデックスの使用について適切な選択を行います（例えば、頻出値の検索にはインデックスを使用しませんので、前述の例はインデックスのサイズを実際に小さくするだけのもので、インデックスの使用を制限するためには必要はありません）。
まったく不適切な計画を選択するようであれば、バグとして報告してください。
  </para>

  <para>
<!--
   Keep in mind that setting up a partial index indicates that you
   know at least as much as the query planner knows, in particular you
   know when an index might be profitable.  Forming this knowledge
   requires experience and understanding of how indexes in
   <productname>PostgreSQL</> work.  In most cases, the advantage of a
   partial index over a regular index will be minimal.
-->
部分インデックスを作成するには、少なくとも問い合わせプランナと同等の知識を持っていること、特に、インデックスが有益となる状況を理解している必要があることに留意してください。
このような知識を得るためには、<productname>PostgreSQL</>でインデックスがどのように機能するかを理解し、経験を積むことが必要です。
ほとんどの場合、通常のインデックスと比べて、部分インデックスを使用する利点は微細です。
  </para>

  <para>
<!--
   More information about partial indexes can be found in <xref
   linkend="STON89b">, <xref linkend="OLSON93">, and <xref
   linkend="SESHADRI95">.
-->
部分インデックスの詳細については、<xref linkend="STON89b">、<xref linkend="OLSON93">、および<xref linkend="SESHADRI95">を参照してください。
  </para>
 </sect1>


 <sect1 id="indexes-opclass">
<!--
  <title>Operator Classes and Operator Families</title>
-->
  <title>演算子クラスと演算子族</title>

  <indexterm zone="indexes-opclass">
<!--
   <primary>operator class</primary>
-->
   <primary>演算子クラス</primary>
  </indexterm>

  <indexterm zone="indexes-opclass">
<!--
   <primary>operator family</primary>
-->
   <primary>演算子族</primary>
  </indexterm>

  <para>
<!--
   An index definition can specify an <firstterm>operator
   class</firstterm> for each column of an index.
-->
インデックス定義では、インデックスの各列に<firstterm>演算子クラス</firstterm>を指定することができます。
<synopsis>
CREATE INDEX <replaceable>name</replaceable> ON <replaceable>table</replaceable> (<replaceable>column</replaceable> <replaceable>opclass</replaceable> <optional><replaceable>sort options</replaceable></optional> <optional>, ...</optional>);
</synopsis>
<!--
   The operator class identifies the operators to be used by the index
   for that column.  For example, a B-tree index on the type <type>int4</type>
   would use the <literal>int4_ops</literal> class; this operator
   class includes comparison functions for values of type <type>int4</type>.
   In practice the default operator class for the column's data type is
   usually sufficient.  The main reason for having operator classes is
   that for some data types, there could be more than one meaningful
   index behavior.  For example, we might want to sort a complex-number data
   type either by absolute value or by real part.  We could do this by
   defining two operator classes for the data type and then selecting
   the proper class when making an index.  The operator class determines
   the basic sort ordering (which can then be modified by adding sort options
   <literal>COLLATE</literal>,
   <literal>ASC</>/<literal>DESC</> and/or
   <literal>NULLS FIRST</>/<literal>NULLS LAST</>).
-->
演算子クラスにより、その列のインデックスで使用される演算子が特定されます。
例えば、<type>int4</type>型に対するB-treeインデックスには、<literal>int4_ops</literal>クラスを使用します。
この演算子クラスには、<type>int4</type>型の値用の比較関数が含まれています。
実際には、通常、列のデータ型のデフォルト演算子クラスで十分です。
演算子クラスを持つ主な理由は、複数の有意義なインデックスの振舞いを持つ、いくつかのデータ型に対してです。
例えば、複素数データ型を、絶対値と実数部のどちらかでソートする必要があるとします。
この処理は、そのデータ型の2つの演算子クラスを定義した上で、インデックスを作成する際に適切なクラスを選択することで、実行可能です。
演算子クラスは基本的なソート順を決定します。
（これは<literal>COLLATE</literal> <literal>ASC</>/<literal>DESC</>、<literal>NULLS FIRST</>/<literal>NULLS LAST</>、またはこの両方というソートオプションを付けることで変更される可能性があります。）
  </para>

  <para>
<!--
   There are also some built-in operator classes besides the default ones:
-->
以下のように、デフォルトの演算子クラスとは別に、組み込み演算子クラスがいくつかあります。

   <itemizedlist>
    <listitem>
     <para>
<!--
      The operator classes <literal>text_pattern_ops</literal>,
      <literal>varchar_pattern_ops</literal>, and
      <literal>bpchar_pattern_ops</literal> support B-tree indexes on
      the types <type>text</type>, <type>varchar</type>, and
      <type>char</type> respectively.  The
      difference from the default operator classes is that the values
      are compared strictly character by character rather than
      according to the locale-specific collation rules.  This makes
      these operator classes suitable for use by queries involving
      pattern matching expressions (<literal>LIKE</literal> or POSIX
      regular expressions) when the database does not use the standard
      <quote>C</quote> locale.  As an example, you might index a
      <type>varchar</type> column like this:
-->
<literal>text_pattern_ops</literal>、<literal>varchar_pattern_ops</literal>、<literal>bpchar_pattern_ops</literal>、<literal>name_pattern_ops</literal>演算子クラスは、それぞれ、<type>text</type>、<type>varchar</type>、<type>char</type>型上のB-treeインデックスをサポートします。
デフォルトの演算子クラスとの違いは、ロケール特有の照合規則に従わずに、文字同士を厳密に比較する点です。
これらの演算子クラスを、標準<quote>C</quote>ロケールを使用しないデータベースにおける、パターンマッチ式（<literal>LIKE</literal>やPOSIX正規表現）を含む問い合わせでの使用に適したものにします。
例えば、以下のように<type>varchar</type>のインデックスを作成できます。
<programlisting>
CREATE INDEX test_index ON test_table (col varchar_pattern_ops);
</programlisting>
<!--
      Note that you should also create an index with the default operator
      class if you want queries involving ordinary <literal>&lt;</>,
      <literal>&lt;=</>, <literal>&gt;</>, or <literal>&gt;=</> comparisons
      to use an index.  Such queries cannot use the
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      operator classes.  (Ordinary equality comparisons can use these
      operator classes, however.)  It is possible to create multiple
      indexes on the same column with different operator classes.
      If you do use the C locale, you do not need the
      <literal><replaceable>xxx</replaceable>_pattern_ops</literal>
      operator classes, because an index with the default operator class
      is usable for pattern-matching queries in the C locale.
-->
また、インデックスを使うために通常の<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</>、または<literal>&gt;=</>比較を含む問い合わせを希望するのであれば、デフォルトの演算子クラスでインデックスを作成しなければならないことに注意してください。
こうした問い合わせでは<literal><replaceable>xxx</replaceable>_pattern_ops</literal>演算子クラスを使用することができません。（しかし、通常の等価比較はこれらの演算子クラスを使用することができます。）
異なる演算子クラスで使用する列と同じ列に対して複数のインデックスを作成することができます。
Cロケールを使用する場合は、<literal><replaceable>xxx</replaceable>_pattern_ops</literal>演算子クラスは必要ありません。
Cロケールでのパターンマッチ問い合わせでは、デフォルト演算子クラスを使用したインデックスが使用できるためです。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
    The following query shows all defined operator classes:
-->
以下の問い合わせは、定義済みの演算子クラスを全て返します。

<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc
    WHERE opc.opcmethod = am.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>

  <para>
<!--
   An operator class is actually just a subset of a larger structure called an
   <firstterm>operator family</>.  In cases where several data types have
   similar behaviors, it is frequently useful to define cross-data-type
   operators and allow these to work with indexes.  To do this, the operator
   classes for each of the types must be grouped into the same operator
   family.  The cross-type operators are members of the family, but are not
   associated with any single class within the family.
-->
実際のところ演算子クラスは、<firstterm>演算子族</>と呼ばれる大きな構造の一部でしかありません。
複数のデータ型が似たような動作を行う場合、データ型を跨る演算子を定義し、インデックスで使用可能とすることが有用な場合がよくあります。
このためには、各型に対する演算子クラスが同一の演算子族にまとめられている必要があります。
データ型を跨る演算子は演算子族の要素です。演算子族内の1つの演算子クラスに結びついているわけではありません。
  </para>

  <para>
<!--    This expanded version of the previous query shows the operator family
    each operator class belongs to:
-->
この前述のクエリで拡張されたバージョンはどの演算子も含まれる演算子の種類に属します。

<programlisting>
SELECT am.amname AS index_method,
       opc.opcname AS opclass_name,
       opf.opfname AS opfamily_name,
       opc.opcintype::regtype AS indexed_type,
       opc.opcdefault AS is_default
    FROM pg_am am, pg_opclass opc, pg_opfamily opf
    WHERE opc.opcmethod = am.oid AND
          opc.opcfamily = opf.oid
    ORDER BY index_method, opclass_name;
</programlisting>
  </para>

  <para>
<!--
    This query shows all defined operator families and all
    the operators included in each family:
-->
以下の問い合わせは、定義済みの演算子族と各演算子族に含まれる演算子をすべて表示します。
<programlisting>
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-collations">
<!--
  <title>Indexes and Collations</title>
-->
  <title>インデックスと照合順序</title>

  <para>
<!--
   An index can support only one collation per index column.
   If multiple collations are of interest, multiple indexes may be needed.
-->
インデックスはインデックス列当たり１つの照合順序のみをサポートすることができます。
複数の照合順序を考慮しなければならない場合、複数のインデックスが必要になるかもしれません。
  </para>

  <para>
<!--
   Consider these statements:
-->
以下の文を考えてみます。
<programlisting>
CREATE TABLE test1c (
    id integer,
    content varchar COLLATE "x"
);

CREATE INDEX test1c_content_index ON test1c (content);
</programlisting>
<!--
   The index automatically uses the collation of the
   underlying column.  So a query of the form
-->
このインデックスは自動的に背後にある列の照合順序を使用することになり、
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable>;
</programlisting>
<!--
   could use the index, because the comparison will by default use the
   collation of the column.  However, this index cannot accelerate queries
   that involve some other collation.  So if queries of the form, say,
-->
という形式の問い合わせでは、この比較はデフォルトで列の照合順序を使用しますので、このインデックスを使用することになります。
しかし、このインデックスは何らかの他の照合順序を含む問い合わせを高速化することはできません。
このため
<programlisting>
SELECT * FROM test1c WHERE content &gt; <replaceable>constant</replaceable> COLLATE "y";
</programlisting>
<!--
   are also of interest, an additional index could be created that supports
   the <literal>"y"</literal> collation, like this:
-->
という形式の問い合わせも考慮しなければならない場合は、以下のように<literal>"y"</literal>照合順序をサポートする追加のインデックスを作成することになります。
<programlisting>
CREATE INDEX test1c_content_y_index ON test1c (content COLLATE "y");
</programlisting>
  </para>
 </sect1>


 <sect1 id="indexes-examine">
<!--
  <title>Examining Index Usage</title>
-->
  <title>インデックス使用状況の検証</title>

  <indexterm zone="indexes-examine">
<!--
   <primary>index</primary>
   <secondary>examining usage</secondary>
-->
   <primary>インデックス</primary>
   <secondary>の使用状況の検証</secondary>
  </indexterm>

  <para>
<!--
   Although indexes in <productname>PostgreSQL</> do not need
   maintenance or tuning, it is still important to check
   which indexes are actually used by the real-life query workload.
   Examining index usage for an individual query is done with the
   <xref linkend="sql-explain">
   command; its application for this purpose is
   illustrated in <xref linkend="using-explain">.
   It is also possible to gather overall statistics about index usage
   in a running server, as described in <xref linkend="monitoring-stats">.
-->
<productname>PostgreSQL</>では、インデックスのメンテナンスまたはチューニングは必要ありませんが、どのインデックスが実際の問い合わせで使われているかを確認することは、やはり重要です。
個々のコマンドでのインデックスの使用状況は、<xref linkend="sql-explain">コマンドで検証できます。
この目的のための用例を<xref linkend="using-explain">に示します。
また、<xref linkend="monitoring-stats">に示す通り、稼働中のサーバにおけるインデックス使用状況の全体的な統計情報を取り出すこともできます。
  </para>

  <para>
<!--
   It is difficult to formulate a general procedure for determining
   which indexes to create.  There are a number of typical cases that
   have been shown in the examples throughout the previous sections.
   A good deal of experimentation is often necessary.
   The rest of this section gives some tips for that:
-->
どのインデックスを作成すべきかを判断するための一般的な手順を定めることは困難です。
これまでの節では、例として典型的なケースをいくつか記述してきました。
十分な検証がしばしば必要です。
本節の残りで、検証のためのヒントをいくつか説明しておきます。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     Always run <xref linkend="sql-analyze">
     first.  This command
     collects statistics about the distribution of the values in the
     table.  This information is required to estimate the number of rows
     returned by a query, which is needed by the planner to assign
     realistic costs to each possible query plan.  In absence of any
     real statistics, some default values are assumed, which are
     almost certain to be inaccurate.  Examining an application's
     index usage without having run <command>ANALYZE</command> is
     therefore a lost cause.
     See <xref linkend="vacuum-for-statistics">
     and <xref linkend="autovacuum"> for more information.
-->
まず、必ず<xref linkend="sql-analyze">コマンドを実行してください。
このコマンドにより、テーブル内の値の分布に関する統計情報を収集します。
この情報は、問い合わせにより返される行数を推測する際に必要となります。
推測された行数は、利用できる各問い合わせ計画に実際のコストを割り当てるために、プランナで必要となります。
実際の統計情報が少しでも欠如している場合、何らかのデフォルト値が仮定されます。
このデフォルト値は、ほぼ間違いなく不正確です。
したがって、<command>ANALYZE</command>コマンドを実行せずに、アプリケーションのインデックス使用状況を検証しても、あまり意味がありません。
より詳細な情報は<xref linkend="vacuum-for-statistics">と<xref linkend="autovacuum">を参照してください。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Use real data for experimentation.  Using test data for setting
     up indexes will tell you what indexes you need for the test data,
     but that is all.
-->
検証には、実際に使用するデータを使ってください。
テストデータを使ってインデックスを作成した場合、テストデータに必要なインデックスはわかりますが、それ以上はわかりません。
    </para>

    <para>
<!--
     It is especially fatal to use very small test data sets.
     While selecting 1000 out of 100000 rows could be a candidate for
     an index, selecting 1 out of 100 rows will hardly be, because the
     100 rows probably fit within a single disk page, and there
     is no plan that can beat sequentially fetching 1 disk page.
-->
非常に小さなテストデータを使用することも、結果に特に致命的な影響を与えます。
100,000行から1,000行を選択する場合は、インデックスが使用される可能性がありますが、100行から1行を選択する場合はインデックスはまず使用されません。
なぜなら、100行はおそらく1つのディスクページに収まるため、1ページを逐次読み取るよりも高速な計画は存在しないからです。
    </para>

    <para>
<!--
     Also be careful when making up test data, which is often
     unavoidable when the application is not yet in production.
     Values that are very similar, completely random, or inserted in
     sorted order will skew the statistics away from the distribution
     that real data would have.
-->
また、アプリケーションがまだ実動していない場合、テストデータを作成しなければならないことがよくありますが、その際にも注意が必要です。
非常に類似した値や、完全にランダムな値、またはソートされた順序で値が挿入されている場合は、その統計情報は、実際のデータの分布とかけ離れたものになってしまいます。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     When indexes are not used, it can be useful for testing to force
     their use.  There are run-time parameters that can turn off
     various plan types (see <xref linkend="runtime-config-query-enable">).
     For instance, turning off sequential scans
     (<varname>enable_seqscan</>) and nested-loop joins
     (<varname>enable_nestloop</>), which are the most basic plans,
     will force the system to use a different plan.  If the system
     still chooses a sequential scan or nested-loop join then there is
     probably a more fundamental reason why the index is not being
     used; for example, the query condition does not match the index.
     (What kind of query can use what kind of index is explained in
     the previous sections.)
-->
インデックスが使用されていない場合、テストのためにインデックスを強制的に使用するようにすると便利です。
各種の計画型を無効にするかを設定できる実行時パラメータがあります
（<xref linkend="runtime-config-query-enable">を参照してください）。
例えば、最も基本的な計画であるシーケンシャルスキャン（<varname>enable_seqscan</>）および入れ子状ループ結合（<varname>enable_nestloop</>）を無効に設定すると、システムは別の計画を使用するように強制されます。
そのような設定を行っても、システムがシーケンシャルスキャンや入れ子状ループ結合を選択する場合は、インデックスを使用しない理由としておそらくもっと根本的な理由があるということになります。
例えば、問い合わせの条件がインデックスに一致しない、などが考えられます。
（どのような問い合わせで、どのようなインデックスを使用できるかは、前節で説明済みです。）
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     If forcing index usage does use the index, then there are two
     possibilities: Either the system is right and using the index is
     indeed not appropriate, or the cost estimates of the query plans
     are not reflecting reality.  So you should time your query with
     and without indexes.  The <command>EXPLAIN ANALYZE</command>
     command can be useful here.
-->
強制的にインデックスを使うように設定し、インデックスを使用している場合は、次の2つの状況が考えられます。
システムの判断が正しく、インデックスの使用が実際には適切ではないという状況と、問い合わせ計画のコスト推定が実情を反映していない状況です。
したがって、インデックスを使った問い合わせの実行時間と、使わない場合の実行時間を計測する必要があります。
この場合、<command>EXPLAIN ANALYZE</command>コマンドが便利です。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     If it turns out that the cost estimates are wrong, there are,
     again, two possibilities.  The total cost is computed from the
     per-row costs of each plan node times the selectivity estimate of
     the plan node.  The costs estimated for the plan nodes can be adjusted
     via run-time parameters (described in <xref
     linkend="runtime-config-query-constants">).
     An inaccurate selectivity estimate is due to
     insufficient statistics.  It might be possible to improve this by
     tuning the statistics-gathering parameters (see
     <xref linkend="sql-altertable">).
-->
コスト推定が間違っていると判明した場合、やはり2つの状況が考えられます。
総コストは、各計画ノードの行単位のコストに、計画ノードの推定選択度を掛けることで算出されます。
計画ノードのコスト推定は、実行時パラメータによって設定することができます
（<xref linkend="runtime-config-query-constants">を参照してください）。
推定選択度が不正確であるのは、統計情報が不十分であるのが原因です。
統計情報収集用のパラメータを調節することによって、この状況を改善することができます
（<xref linkend="sql-altertable">を参照してください）。
    </para>

    <para>
<!--
     If you do not succeed in adjusting the costs to be more
     appropriate, then you might have to resort to forcing index usage
     explicitly.  You might also want to contact the
     <productname>PostgreSQL</> developers to examine the issue.
-->
コストを適切に調節できない場合は、明示的にインデックスを使用する必要が考えられます。
あるいは、<productname>PostgreSQL</>開発者に問題の調査を依頼することになるかもしれません。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
