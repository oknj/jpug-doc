<!-- doc/src/sgml/storage.sgml -->

<chapter id="storage">

<!--
<title>Database Physical Storage</title>
-->
<title>データベースの物理的な格納</title>

<para>
<!--
This chapter provides an overview of the physical storage format used by
<productname>PostgreSQL</productname> databases.
-->
本章では<productname>PostgreSQL</productname>データベースで使用される物理的格納書式についての概要を説明します。
</para>

<sect1 id="storage-file-layout">

<!--
<title>Database File Layout</title>
-->
<title>データベースファイルのレイアウト</title>

<para>
<!--
This section describes the storage format at the level of files and
directories.
-->
本節ではファイルとディレクトリというレベルで格納書式について説明します。
</para>

<para>
<!--
Traditionally, the configuration and data files used by a database
cluster are stored together within the cluster's data
directory, commonly referred to as <varname>PGDATA</> (after the name of the
environment variable that can be used to define it).  A common location for
<varname>PGDATA</> is <filename>/var/lib/pgsql/data</>.  Multiple clusters,
managed by different server instances, can exist on the same machine.
-->
伝統的に、データベースクラスタで利用される制御ファイルとデータファイルは、クラスタのデータディレクトリ内に一緒に格納され、通常（このディレクトリを定義するために使用できる環境変数名にちなんで）<varname>PGDATA</>として参照されます。
通常の<varname>PGDATA</>の位置は<filename>/var/lib/pgsql/data</>です。
異なるサーバインスタンスによって管理することで、複数のクラスタを同一のマシン上に存在させることができます。
</para>

<para>
<!--
The <varname>PGDATA</> directory contains several subdirectories and control
files, as shown in <xref linkend="pgdata-contents-table">.  In addition to
these required items, the cluster configuration files
<filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename>, and
<filename>pg_ident.conf</filename> are traditionally stored in
<varname>PGDATA</>, although it is possible to place them elsewhere.
-->
<xref linkend="pgdata-contents-table">に示すように、<varname>PGDATA</>ディレクトリには数個のサブディレクトリと制御ファイルがあります。
これら必要な項目に加え、クラスタの設定ファイルである<filename>postgresql.conf</filename>、<filename>pg_hba.conf</filename>および<filename>pg_ident.conf</filename>が、他の場所にも置くことができますが、伝統的に<varname>PGDATA</>内に格納されます
</para>

<table tocentry="1" id="pgdata-contents-table">
<!--
<title>Contents of <varname>PGDATA</></title>
-->
<title><varname>PGDATA</>の内容</title>
<tgroup cols="2">
<thead>
<row>
<entry>
<!--
Item
-->
項目
</entry>
<!--
<entry>Description</entry>
-->
<entry>説明</entry>
</row>
</thead>

<tbody>

<row>
 <entry><filename>PG_VERSION</></entry>
<!--
 <entry>A file containing the major version number of <productname>PostgreSQL</productname></entry>
-->
 <entry><productname>PostgreSQL</productname>の主バージョン番号を保有するファイル</entry>
</row>

<row>
 <entry><filename>base</></entry>
<!--
 <entry>Subdirectory containing per-database subdirectories</entry>
-->
 <entry>データベースごとのサブディレクトリを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>global</></entry>
<!--
 <entry>Subdirectory containing cluster-wide tables, such as
 <structname>pg_database</></entry>
-->
 <entry><structname>pg_database</>のようなクラスタで共有するテーブルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_clog</></entry>
<!--
 <entry>Subdirectory containing transaction commit status data</entry>
-->
 <entry>トランザクションのコミット状態のデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_dynshmem</></entry>
<!--
 <entry>Subdirectory containing files used by the dynamic shared memory
  subsystem</entry>
-->
 <entry>動的共有メモリサブシステムで使われるファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_logical</></entry>
<!--
 <entry>Subdirectory containing status data for logical decoding</entry>
-->
 <entry>論理デコードのための状態データを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_multixact</></entry>
<!--
 <entry>Subdirectory containing multitransaction status data
  (used for shared row locks)</entry>
-->
 <entry>マルチトランザクションの状態のデータを保有するサブディレクトリ（共有行ロックで使用されます）</entry> 
</row>

<row>
 <entry><filename>pg_notify</></entry>
<!--
 <entry>Subdirectory containing LISTEN/NOTIFY status data</entry>
-->
 <entry>LISTEN/NOTIFY状態データを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_replslot</></entry>
<!--
 <entry>Subdirectory containing replication slot data</entry>
-->
 <entry>レプリケーションスロットデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_serial</></entry>
<!--
 <entry>Subdirectory containing information about committed serializable transactions</entry>
-->
 <entry>コミットされたシリアライザブルトランザクションに関する情報を保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_snapshots</></entry>
<!--
 <entry>Subdirectory containing exported snapshots</entry>
-->
 <entry>エキスポートされたスナップショットを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_stat</></entry>
<!--
 <entry>Subdirectory containing permanent files for the statistics
  subsystem</entry>
-->
 <entry>統計サブシステムのための永続ファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_stat_tmp</></entry>
 <!--
 <entry>Subdirectory containing temporary files for the statistics
  subsystem</entry>
  -->
 <entry>統計用サブシステム用の一時ファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_subtrans</></entry>
<!--
 <entry>Subdirectory containing subtransaction status data</entry>
-->
 <entry>サブトランザクションの状態のデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_tblspc</></entry>
<!--
 <entry>Subdirectory containing symbolic links to tablespaces</entry>
-->
 <entry>テーブル空間へのシンボリックリンクを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_twophase</></entry>
<!--
 <entry>Subdirectory containing state files for prepared transactions</entry>
-->
 <entry>プリペアドトランザクション用の状態ファイルを保有するサブディレクトリ</entry>

</row>

<row>
 <entry><filename>pg_xlog</></entry>
<!--
 <entry>Subdirectory containing WAL (Write Ahead Log) files</entry>
-->
 <entry> WAL（ログ先行書き込み）ファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>postgresql.auto.conf</></entry>
<!--
 <entry>A file used for storing configuration parameters that are set by
<command>ALTER SYSTEM</command></entry>
-->
 <entry><command>ALTER SYSTEM</command>により設定された設定パラメータを格納するのに使われるファイル</entry>
</row>

<row>
 <entry><filename>postmaster.opts</></entry>
<!--
 <entry>A file recording the command-line options the server was
last started with</entry>
-->
 <entry>最後にサーバを起動した時のコマンドラインオプションを記録するファイル</entry>
</row>

<row>
 <entry><filename>postmaster.pid</></entry>
<!--
 <entry>A lock file recording the current postmaster process ID (PID),
  cluster data directory path,
  postmaster start timestamp,
  port number,
  Unix-domain socket directory path (empty on Windows),
  first valid listen_address (IP address or <literal>*</>, or empty if
  not listening on TCP),
  and shared memory segment ID
  (this file is not present after server shutdown)</entry>
-->
 <entry>
現在のpostmasterプロセスID（PID）、クラスタのデータディレクトリパス、postmaster起動時のタイムスタンプ、ポート番号、Unixドメインソケットのディレクトリパス（Windowsでは空）、有効な監視アドレスの一番目（IPアドレスまたは<literal>*</>、TCPを監視していない場合は空）および共有メモリのセグメントIDを記録するロックファイル（サーバが停止した後は存在しません）
</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
<!--
For each database in the cluster there is a subdirectory within
<varname>PGDATA</><filename>/base</>, named after the database's OID in
<structname>pg_database</>.  This subdirectory is the default location
for the database's files; in particular, its system catalogs are stored
there.
-->
クラスタ内の各データベースに対して、<varname>PGDATA</><filename>/base</>内にサブディレクトリが存在し、サブディレクトリ名は<structname>pg_database</>内のデータベースOIDとなります。
このサブディレクトリはデータベースファイルのデフォルトの位置であり、特にシステムカタログがそこに格納されます。
</para>

<para>
<!--
Each table and index is stored in a separate file.  For ordinary relations,
these files are named after the table or index's <firstterm>filenode</> number,
which can be found in <structname>pg_class</>.<structfield>relfilenode</>. But
for temporary relations, the file name is of the form
<literal>t<replaceable>BBB</>_<replaceable>FFF</></>, where <replaceable>BBB</>
is the backend ID of the backend which created the file, and <replaceable>FFF</>
is the filenode number.  In either case, in addition to the main file (a/k/a
main fork), each table and index has a <firstterm>free space map</> (see <xref
linkend="storage-fsm">), which stores information about free space available in
the relation.  The free space map is stored in a file named with the filenode
number plus the suffix <literal>_fsm</>.  Tables also have a
<firstterm>visibility map</>, stored in a fork with the suffix <literal>_vm</>,
to track which pages are known to have no dead tuples.  The visibility map is
described further in <xref linkend="storage-vm">.  Unlogged tables and indexes
have a third fork, known as the initialization fork, which is stored in a fork
with the suffix <literal>_init</literal> (see <xref linkend="storage-init">).
-->
各テーブルおよびインデックスは別個のファイルに格納されます。
通常のリレーションでは、これらのファイル名はテーブルまたはインデックスの<firstterm>ファイルノード</>番号となります。
ファイルノード番号は<structname>pg_class</>.<structfield>relfilenode</>内で見つけられます。
しかし一時的なリレーションでは、ファイル名は<literal>t<replaceable>BBB</>_<replaceable>FFF</></>という形になります。
ここで<replaceable>BBB</>はファイルを生成したバックエンドのバックエンドID、<replaceable>FFF</>はファイルノード番号です。
どちらの場合でも、主ファイル（いわゆる主フォーク）に加え、それぞれのテーブルとインデックスはリレーションに利用できる空き領域についての情報を格納する<firstterm>空き領域マップ</>（<xref linkend="storage-fsm">参照）を持ちます。
空き領域マップはファイルノード番号に接尾辞<literal>_fsm</>がついた名前のファイルに格納されます。
テーブルは同時に、どのページが不要なタプルを持っていないと判断できるように追跡する<firstterm>可視性マップ</>を持ち、フォークに接尾辞<literal>_vm</>を付けたファイルに格納します。
可視性マップは<xref linkend="storage-vm">でより詳しく解説します。
ログを取らないテーブルとインデックスは、初期化フォークという第３のフォークを持ち、フォークに接尾辞<literal>_init</>を付けたファイルに格納します（<xref linkend="storage-init">参照）。
</para>

<caution>
<para>
<!--
Note that while a table's filenode often matches its OID, this is
<emphasis>not</> necessarily the case; some operations, like
<command>TRUNCATE</>, <command>REINDEX</>, <command>CLUSTER</> and some forms
of <command>ALTER TABLE</>, can change the filenode while preserving the OID.
Avoid assuming that filenode and table OID are the same.
Also, for certain system catalogs including <structname>pg_class</> itself,
<structname>pg_class</>.<structfield>relfilenode</> contains zero.  The
actual filenode number of these catalogs is stored in a lower-level data
structure, and can be obtained using the <function>pg_relation_filenode()</>
function.
-->
テーブルにおけるファイルノード番号とOIDは多くの場合一致しますが、常に一致するとは<emphasis>限らない</>ことに注意してください。
<command>TRUNCATE</>、<command>REINDEX</>、<command>CLUSTER</>等のいくつかの操作、および<command>ALTER TABLE</>におけるいくつかの構文は、OIDを保持したままファイルノード番号を変更できます。
ファイルノード番号とテーブルOIDが同一であると仮定しないでください。
また<structname>pg_class</>自身を含む特定のシステムカタログにおいて、<structname>pg_class</>.<structfield>relfilenode</>はゼロを持ちます。
これらのカタログの実際のファイルノード番号は低レベルなデータ構造内に保管されており、<function>pg_relation_filenode()</>関数を使用して入手できます。
</para>
</caution>

<para>
<!--
When a table or index exceeds 1 GB, it is divided into gigabyte-sized
<firstterm>segments</>.  The first segment's file name is the same as the
filenode; subsequent segments are named filenode.1, filenode.2, etc.
This arrangement avoids problems on platforms that have file size limitations.
(Actually, 1 GB is just the default segment size.  The segment size can be
adjusted using the configuration option <option>&#045;&#045;with-segsize</option>
when building <productname>PostgreSQL</>.)
In principle, free space map and visibility map forks could require multiple
segments as well, though this is unlikely to happen in practice.
-->
テーブルまたはインデックスが１ギガバイトを超えると、ギガバイト単位の<firstterm>セグメント</>に分割されます。
最初のセグメントのファイル名はファイルノード番号と同一であり、それ以降は、ファイルノード番号.1、ファイルノード番号.2等の名称になります。
この配置法によってファイル容量に制限のあるプラットフォームにおける問題を回避します。
（実際、１ギガバイトは単なるデフォルトのセグメント容量です。
セグメント容量は<productname>PostgreSQL</>を構築する際、<option>--with-segsize</option>設定オプションを使用して調整することができます。)
原理上、空き領域マップと可視性マップのフォークにおいても複数のセグメントも必要とする可能性がありますが、実際のところは起こりそうにありません。
</para>

<para>
<!--
A table that has columns with potentially large entries will have an
associated <firstterm>TOAST</> table, which is used for out-of-line storage of
field values that are too large to keep in the table rows proper.
<structname>pg_class</>.<structfield>reltoastrelid</> links from a table to
its <acronym>TOAST</> table, if any.
See <xref linkend="storage-toast"> for more information.
-->
項目が大きくなりそうな列を持ったテーブルは、連携した<firstterm>TOAST</>テーブルを保有する可能性があります。
<firstterm>TOAST</>テーブルは、テーブル行の中には大き過ぎて適切に保持できないフィールド値を行の外部に格納するために使用されます。
<acronym>TOAST</>テーブルが存在する時、<structname>pg_class</>.<structfield>reltoastrelid</>は元のテーブルと<acronym>TOAST</>テーブルを結びつけます。
<xref linkend="storage-toast">を参照してください。
</para>

<para>
<!--
The contents of tables and indexes are discussed further in
<xref linkend="storage-page-layout">.
-->
テーブルおよびインデックスの内容は、<xref linkend="storage-page-layout">においてさらに考察されています。
</para>

<para>
<!--
Tablespaces make the scenario more complicated.  Each user-defined tablespace
has a symbolic link inside the <varname>PGDATA</><filename>/pg_tblspc</>
directory, which points to the physical tablespace directory (i.e., the
location specified in the tablespace's <command>CREATE TABLESPACE</> command).
This symbolic link is named after
the tablespace's OID.  Inside the physical tablespace directory there is
a subdirectory with a name that depends on the <productname>PostgreSQL</>
server version, such as <literal>PG_9.0_201008051</>.  (The reason for using
this subdirectory is so that successive versions of the database can use
the same <command>CREATE TABLESPACE</> location value without conflicts.)
Within the version-specific subdirectory, there is
a subdirectory for each database that has elements in the tablespace, named
after the database's OID.  Tables and indexes are stored within that
directory, using the filenode naming scheme.
The <literal>pg_default</> tablespace is not accessed through
<filename>pg_tblspc</>, but corresponds to
<varname>PGDATA</><filename>/base</>.  Similarly, the <literal>pg_global</>
tablespace is not accessed through <filename>pg_tblspc</>, but corresponds to
<varname>PGDATA</><filename>/global</>.
-->
テーブル空間は状況をさらに複雑にします。
ユーザが定義したテーブル空間はそれぞれ、<varname>PGDATA</><filename>/pg_tblspc</>ディレクトリ内に物理的なテーブル空間ディレクトリ（つまりそのテーブル空間の<command>CREATE TABLESPACE</>コマンドで指定された場所）を指し示す、シンボリックリンクを持ちます。
シンボリックリンクの名称はテーブル空間のOIDとなります。
物理的テーブル空間ディレクトリの内部では、<literal>PG_9.0_201008051</>などの<productname>PostgreSQL</>サーバのバージョンに依存した名前のサブディレクトリが存在します。
（このサブディレクトリを使用する理由は、競合することなく<command>CREATE TABLESPACE</>で指定する場所と同じものを将来のバージョンのデータベースでも使用できるようにするためです。）
このバージョン固有のサブディレクトリの内部では、テーブル空間に要素を持つデータベースごとに、データベースOIDをディレクトリ名としたサブディレクトリが存在します。
テーブルとインデックスは、ファイルノードの命名の規定に従って、そのディレクトリ内に格納されます。
<literal>pg_default</>テーブル空間は <filename>pg_tblspc</>を通してアクセスされるのではなく、<varname>PGDATA</><filename>/base</>と連携します。
同様に、<literal>pg_global</>テーブル空間は<filename>pg_tblspc</>を通してアクセスされるのではなく、<varname>PGDATA</><filename>/global</>と連携します。
</para>

<para>
<!--
The <function>pg_relation_filepath()</> function shows the entire path
(relative to <varname>PGDATA</>) of any relation.  It is often useful
as a substitute for remembering many of the above rules.  But keep in
mind that this function just gives the name of the first segment of the
main fork of the relation &mdash; you may need to append a segment number
and/or <literal>_fsm</>, <literal>_vm</>, or <literal>_init</> to find all
the files associated with the relation.
-->
<function>pg_relation_filepath()</>関数は任意のリレーションの(<varname>PGDATA</>から相対的な)パス全体を示します。
これは上の規則の多くを記憶する必要がありませんので、しばしば有用です。
しかし、この関数がリレーションの主フォークの最初のセグメントの名前だけを返すことに注意して下さい。
リレーションに関したすべてのファイルを見つけるためにセグメント番号や<literal>_fsm</>や<literal>_vm</>、<literal>_init</>を追加する必要があるかもしれません。
</para>

<para>
<!--
Temporary files (for operations such as sorting more data than can fit in
memory) are created within <varname>PGDATA</><filename>/base/pgsql_tmp</>,
or within a <filename>pgsql_tmp</> subdirectory of a tablespace directory
if a tablespace other than <literal>pg_default</> is specified for them.
The name of a temporary file has the form
<filename>pgsql_tmp<replaceable>PPP</>.<replaceable>NNN</></filename>,
where <replaceable>PPP</> is the PID of the owning backend and
<replaceable>NNN</> distinguishes different temporary files of that backend.
-->
一時ファイル（メモリ内に収まりきらないデータのソートなどの操作用）は<varname>PGDATA</><filename>/base/pgsql_tmp</>内、または、<literal>pg_default</>以外のテーブル空間が指定されていた場合はテーブル空間ディレクトリ下の<filename>pgsql_tmp</>サブディレクトリ内に作成されます。
一時ファイルの名前は<filename>pgsql_tmp<replaceable>PPP</>.<replaceable>NNN</></filename>という形式です。
ここで、<replaceable>PPP</>は所有するバックエンドのPIDであり、<replaceable>NNN</>で同一バックエンドで作成された別の一時ファイルと区別します。
</para>

</sect1>

<sect1 id="storage-toast">

<title>TOAST</title>

    <indexterm>
     <primary>TOAST</primary>
    </indexterm>
<!--
    <indexterm><primary>sliced bread</><see>TOAST</></indexterm>
-->
    <indexterm><primary>スライスパン</><see>TOAST</></indexterm>

<para>
<!--
This section provides an overview of <acronym>TOAST</> (The
Oversized-Attribute Storage Technique).
-->
本節では<acronym>TOAST</>（過大属性格納技法：The Oversized-Attribute Storage Technique）の概要について説明します。
</para>

<para>
<!--
<productname>PostgreSQL</productname> uses a fixed page size (commonly
8 kB), and does not allow tuples to span multiple pages.  Therefore,  it is
not possible to store very large field values directly.  To overcome
this limitation, large  field values are compressed and/or broken up into
multiple physical rows. This happens transparently to the user, with only
small impact on most of the backend code.  The technique is affectionately
known as <acronym>TOAST</>  (or <quote>the best thing since sliced bread</>).
-->
<productname>PostgreSQL</productname>は固定長のページサイズ（通常8キロバイト）を使用し、複数ページにまたがるタプルを許しません。
そのため、大規模なフィールド値を直接格納できません。
大規模なフィールド値を圧縮したり、複数の物理的な行に分割したりすることで、この限界はなくなりました。
これはユーザからは透過的に発生し、また、バックエンドのコード全体には小さな影響しか与えませんでした。
この技法は<acronym>TOAST</>（または<quote>パンをスライスして以来最善のもの</>）という愛称で呼ばれます。
[訳注：“パンをスライスして以来最善のもの（the best thing since sliced bread）”は素晴らしいものを意味します。]
</para>

<para>
<!--
Only certain data types support <acronym>TOAST</> &mdash; there is no need to
impose the overhead on data types that cannot produce large field values.
To support <acronym>TOAST</>, a data type must have a variable-length
(<firstterm>varlena</>) representation, in which the first 32-bit word of any
stored value contains the total length of the value in bytes (including
itself).  <acronym>TOAST</> does not constrain the rest of the representation.
All the C-level functions supporting a <acronym>TOAST</>-able data type must
be careful to handle <acronym>TOAST</>ed input values.  (This is normally done
by invoking <function>PG_DETOAST_DATUM</> before doing anything with an input
value, but in some cases more efficient approaches are possible.)
-->
一部のデータ型のみが<acronym>TOAST</>をサポートします。
大規模なフィールド値を生成することがないデータ型にオーバーヘッドを負わせる必要はありません。
<acronym>TOAST</>をサポートするためには、データ型は可変長（<firstterm>varlena</>）表現を持たなければなりません。
格納する値の最初の32ビットワードにはバイト単位の値の（このワード自体を含む）長さが含まれます。
<acronym>TOAST</>は残りの表現について制限しません。
<acronym>TOAST</>可能なデータ型をサポートするC言語関数はすべて、<acronym>TOAST</>化された入力値を注意して扱わなければなりません
（通常これは、入力に対して何か作業をする前に<function>PG_DETOAST_DATUM</>を呼び出すことで行われますが、もっと効率的な方法が可能な場合もあります）。
</para>

<para>
<!--
<acronym>TOAST</> usurps two bits of the varlena length word (the high-order
bits on big-endian machines, the low-order bits on little-endian machines),
thereby limiting the logical size of any value of a <acronym>TOAST</>-able
data type to 1 GB (2<superscript>30</> - 1 bytes).  When both bits are zero,
the value is an ordinary un-<acronym>TOAST</>ed value of the data type, and
the remaining bits of the length word give the total datum size (including
length word) in bytes.  When the highest-order or lowest-order bit is set,
the value has only a single-byte header instead of the normal four-byte
header, and the remaining bits give the total datum size (including length
byte) in bytes.  As a special case, if the remaining bits are all zero
(which would be impossible for a self-inclusive length), the value is a
pointer to out-of-line data stored in a separate TOAST table.  (The size of
a TOAST pointer is given in the second byte of the datum.)
Values with single-byte headers aren't aligned on any particular
boundary, either.  Lastly, when the highest-order or lowest-order bit is
clear but the adjacent bit is set, the content of the datum has been
compressed and must be decompressed before use.  In this case the remaining
bits of the length word give the total size of the compressed datum, not the
original data.  Note that compression is also possible for out-of-line data
but the varlena header does not tell whether it has occurred &mdash;
the content of the TOAST pointer tells that, instead.
-->
<acronym>TOAST</>はvarlenaの長さワードの2ビット(ビッグエンディアンのマシンでは上位ビット、リトルエンディアンのマシンでは下位ビット)を勝手に使用します。
そのため、すべての<acronym>TOAST</>可能なデータ型の値の論理サイズは1ギガバイト（2<superscript>30</> - 1バイト）までになります。
両ビットが0の場合、値はそのデータ型の普通の<acronym>TOAST</>化されていない値となり、長さワードの残りのビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
上位側または下位側のどちらか片方のビットが設定された場合、値は通常の4バイトのヘッダを持たず1バイトのヘッダを持ちます。
また、長さワードの残りビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
特殊な状況として、長さワードの残りビットがすべて0（自身の長さを含みますのでありえません）の場合、その値は別のTOASTテーブルに保存される行外データへのポインタです。
（TOASTポインタのサイズはデータの第2バイト内で与えられます。）
単一バイトヘッダを持つ値は特定の境界に整列されません。
最後に上位側または下位側のビットが0で隣のビットが設定されている場合、データの内容は圧縮され、使用前に伸長しなければなりません。
この場合、長さワードの残りビットは元データのサイズではなく圧縮したデータの総サイズになります。
圧縮が行外データでも起こりえますが、varlenaヘッダには圧縮されているかどうかについての情報がないことに注意してください。
その代わりTOASTポインタの内容にこの情報が含まれています。
</para>

<para>
<!--
If any of the columns of a table are <acronym>TOAST</>-able, the table will
have an associated <acronym>TOAST</> table, whose OID is stored in the table's
<structname>pg_class</>.<structfield>reltoastrelid</> entry.  Out-of-line
<acronym>TOAST</>ed values are kept in the <acronym>TOAST</> table, as
described in more detail below.
-->
テーブルの任意の列が<acronym>TOAST</>可能な場合、そのテーブルは連携する<acronym>TOAST</>テーブルを持ちます。
<acronym>TOAST</>テーブルのOIDはテーブルの<structname>pg_class</>.<structfield>reltoastrelid</>項目に格納されます。
詳細は後で説明しますが、行外の<acronym>TOAST</>化された値は<acronym>TOAST</>テーブル内に保持されます。
</para>

<para>
<!--
The compression technique used is a fairly simple and very fast member
of the LZ family of compression techniques.  See
<filename>src/backend/utils/adt/pg_lzcompress.c</> for the details.
-->
使用される圧縮技術は、LZ系の圧縮技術の1つで単純かつ非常に高速なものです。
詳細は<filename>src/backend/utils/adt/pg_lzcompress.c</>を参照してください。
</para>

<para>
<!--
Out-of-line values are divided (after compression if used) into chunks of at
most <symbol>TOAST_MAX_CHUNK_SIZE</> bytes (by default this value is chosen
so that four chunk rows will fit on a page, making it about 2000 bytes).
Each chunk is stored
as a separate row in the <acronym>TOAST</> table for the owning table.  Every
<acronym>TOAST</> table has the columns <structfield>chunk_id</> (an OID
identifying the particular <acronym>TOAST</>ed value),
<structfield>chunk_seq</> (a sequence number for the chunk within its value),
and <structfield>chunk_data</> (the actual data of the chunk).  A unique index
on <structfield>chunk_id</> and <structfield>chunk_seq</> provides fast
retrieval of the values.  A pointer datum representing an out-of-line
<acronym>TOAST</>ed value therefore needs to store the OID of the
<acronym>TOAST</> table in which to look and the OID of the specific value
(its <structfield>chunk_id</>).  For convenience, pointer datums also store the
logical datum size (original uncompressed data length) and actual stored size
(different if compression was applied).  Allowing for the varlena header bytes,
the total size of a <acronym>TOAST</> pointer datum is therefore 18 bytes
regardless of the actual size of the represented value.
-->
行外の値は（圧縮される場合は圧縮後に）最大<literal>TOAST_MAX_CHUNK_SIZE</>バイトの塊に分割されます
（デフォルトではこの値は4チャンク行が1ページに収まり、およそ2000バイトになるように選ばれます）。
各塊は、データを持つテーブルと連携する<acronym>TOAST</>テーブル内に個別の行として格納されます。
すべての<acronym>TOAST</>テーブルは<structfield>chunk_id</>列（特定の<acronym>TOAST</>化された値を識別するOID）、<structfield>chunk_seq</>列（値の塊に対する連番）、<structfield>chunk_data</>（塊の実際のデータ）列を持ちます。
<structfield>chunk_id</>と<structfield>chunk_seq</>に対する一意性インデックスは値の抽出を高速化します。
したがって、行外の<acronym>TOAST</>化された値を示すポインタデータには、検索先となる<acronym>TOAST</>テーブルのOIDと指定した値のOID(<structfield>chunk_id</>)を格納しなければなりません。
簡便性のために、ポインタデータには論理データサイズ（元々の非圧縮のデータ長）と実際の格納サイズ（圧縮時には異なります）も格納されます。
varlenaヘッダバイトに収納するために<acronym>TOAST</>ポインタデータの総サイズは、表現される値の実サイズに関係なく、18バイトになります。
</para>

<para>
<!--
The <acronym>TOAST</> code is triggered only
when a row value to be stored in a table is wider than
<symbol>TOAST_TUPLE_THRESHOLD</> bytes (normally 2 kB).
The <acronym>TOAST</> code will compress and/or move
field values out-of-line until the row value is shorter than
<symbol>TOAST_TUPLE_TARGET</> bytes (also normally 2 kB)
or no more gains can be had.  During an UPDATE
operation, values of unchanged fields are normally preserved as-is; so an
UPDATE of a row with out-of-line values incurs no <acronym>TOAST</> costs if
none of the out-of-line values change.
-->
<acronym>TOAST</>のコードは、テーブル内に格納される値が<symbol>TOAST_TUPLE_THRESHOLD</>バイト（通常2キロバイト）を超える時にのみ実行されます。
<acronym>TOAST</>コードは、行の値が<symbol>TOAST_TUPLE_TARGET</>バイト（こちらも通常2キロバイト）より小さくなるかそれ以上の縮小ができなくなるまで、フィールド値の圧縮や行外への移動を行います。
更新操作中、変更されない値は通常そのまま残ります。
行外の値を持つ行の更新では、行外の値の変更がなければ<acronym>TOAST</>するコストはかかりません。
</para>

<para>
<!--
The <acronym>TOAST</> code recognizes four different strategies for storing
<acronym>TOAST</>-able columns:
-->
<acronym>TOAST</>コードでは、以下の<acronym>TOAST</>可能な列を格納するための4つの異なる戦略を認めます。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>PLAIN</literal> prevents either compression or
      out-of-line storage; furthermore it disables use of single-byte headers
      for varlena types.
      This is the only possible strategy for
      columns of non-<acronym>TOAST</>-able data types.
-->
<literal>PLAIN</literal>は圧縮や行外の格納を防止します。
さらにvarlena型での単一バイトヘッダの使用を無効にします。
これは<acronym>TOAST</>化不可能のデータ型の列に対してのみ取り得る戦略です。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>EXTENDED</literal> allows both compression and out-of-line
      storage.  This is the default for most <acronym>TOAST</>-able data types.
      Compression will be attempted first, then out-of-line storage if
      the row is still too big.
-->
<literal>EXTENDED</literal>では、圧縮と行外の格納を許します。
これはほとんどの<acronym>TOAST</>可能のデータ型のデフォルトです。
圧縮がまず行われ、それでも行が大き過ぎるのであれば行外に格納します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>EXTERNAL</literal> allows out-of-line storage but not
      compression.  Use of <literal>EXTERNAL</literal> will
      make substring operations on wide <type>text</type> and
      <type>bytea</type> columns faster (at the penalty of increased storage
      space) because these operations are optimized to fetch only the
      required parts of the out-of-line value when it is not compressed.
-->
<literal>EXTERNAL</literal>は非圧縮の行外格納を許します。
<literal>EXTERNAL</literal>を使用すると、<type>text</type>と<type>bytea</type>列全体に対する部分文字列操作が高速化されます。
こうした操作は非圧縮の行外の値から必要な部分を取り出す時に最適化されるためです
（格納領域が増加するという欠点があります）。
     </para>
    </listitem>
    <listitem>
     <para>
<!-- 
      <literal>MAIN</literal> allows compression but not out-of-line
      storage.  (Actually, out-of-line storage will still be performed
      for such columns, but only as a last resort when there is no other
      way to make the row small enough to fit on a page.)
-->
<literal>MAIN</literal>は圧縮を許しますが、行外の格納はできません
（実際にはこうした列についても行外の格納は行われます。
しかし、他に行を縮小させページに合わせる方法がない場合の最後の手段としてのみです）。
     </para>
    </listitem>
   </itemizedlist>

<!--
Each <acronym>TOAST</>-able data type specifies a default strategy for columns
of that data type, but the strategy for a given table column can be altered
with <command>ALTER TABLE SET STORAGE</>.
-->
<acronym>TOAST</>可能なデータ型はそれぞれ、そのデータ型の列用のデフォルトの戦略を指定します。
しかし<command>ALTER TABLE SET STORAGE</>を使用して、あるテーブル列の戦略を変更することができます。
</para>

<para>
<!--
This scheme has a number of advantages compared to a more straightforward
approach such as allowing row values to span pages.  Assuming that queries are
usually qualified by comparisons against relatively small key values, most of
the work of the executor will be done using the main row entry. The big values
of <acronym>TOAST</>ed attributes will only be pulled out (if selected at all)
at the time the result set is sent to the client. Thus, the main table is much
smaller and more of its rows fit in the shared buffer cache than would be the
case without any out-of-line storage. Sort sets shrink also, and sorts will
more often be done entirely in memory. A little test showed that a table
containing typical HTML pages and their URLs was stored in about half of the
raw data size including the <acronym>TOAST</> table, and that the main table
contained only about 10% of the entire data (the URLs and some small HTML
pages). There was no run time difference compared to an un-<acronym>TOAST</>ed
comparison table, in which all the HTML pages were cut down to 7 kB to fit.
-->
この機構には、ページをまたがる行の値を許可するといった素直な手法に比べて多くの利点があります。
通常問い合わせは比較的小さなキー値に対する比較で条件付けされるものと仮定すると、エクゼキュータの仕事のほとんどは主だった行の項目を使用して行われることになります。
<acronym>TOAST</>化属性の大規模な値は、（それが選択されている時）結果集合をクライアントに戻す時に引き出されるだけです。
このため、主テーブルは行外の格納を使用しない場合に比べて、かなり小さくなり、その行は共有バッファキャッシュにより合うようになります。
ソート集合もまた小さくなり、ソートが完全にメモリ内で行われる頻度が高くなります。
小規模な試験結果ですが、典型的なHTMLページとそのURLを持つテーブルでは、<acronym>TOAST</>テーブルを含め、元々のデータサイズのおよそ半分で格納でき、さらに、主テーブルには全体のデータのおよそ10%のみ（URLと一部の小さなHTMLページ）が格納されました。
すべてのHTMLページを7キロバイト程度に切り詰めた<acronym>TOAST</>化されない比較用テーブルと比べ、実行時間に違いはありませんでした。
</para>

</sect1>

<sect1 id="storage-fsm">

<!--
<title>Free Space Map</title>
-->
<title>空き領域マップ</title>

<indexterm>
<!--
 <primary>Free Space Map</primary>
-->
 <primary>空き領域マップ</primary>
</indexterm>
<!--
<indexterm><primary>FSM</><see>Free Space Map</></indexterm>
-->
<indexterm><primary>FSM</><see>空き領域マップ</></indexterm>

<para>
<!--
Each heap and index relation, except for hash indexes, has a Free Space Map
(FSM) to keep track of available space in the relation. It's stored
alongside the main relation data in a separate relation fork, named after the
filenode number of the relation, plus a <literal>_fsm</> suffix. For example,
if the filenode of a relation is 12345, the FSM is stored in a file called
<filename>12345_fsm</>, in the same directory as the main relation file.
-->
ヒープとハッシュインデックス以外のインデックスリレーションはそれぞれ、そのリレーション内で利用可能な領域を継続して追跡するために、空き領域マップ（FSM）を持ちます。
これは、個々のリレーションのフォーク内の主リレーションデータに沿って、リレーションのファイルノード番号に<literal>_fsm</>という接尾辞を付けた名前のファイルに格納されます。
例えばリレーションのファイルノードが12345であれば、FSMは主リレーションファイルと同じディレクトリ内の<filename>12345_fsm</>という名前のファイルに格納されます。
</para>

<para>
<!--
The Free Space Map is organized as a tree of <acronym>FSM</> pages. The
bottom level <acronym>FSM</> pages store the free space available on each
heap (or index) page, using one byte to represent each such page. The upper
levels aggregate information from the lower levels.
-->
空き領域マップは<acronym>FSM</>ページのツリーとして編成されます。
最下位レベルの<acronym>FSM</>ページはすべてのヒープ（またはインデックス）ページで利用可能な空き領域を、各ページ毎に1バイト使用して格納します。
上位レベルは下位レベルからの情報を集約します。
</para>

<para>
<!--
Within each <acronym>FSM</> page is a binary tree, stored in an array with
one byte per node. Each leaf node represents a heap page, or a lower level
<acronym>FSM</> page. In each non-leaf node, the higher of its children's
values is stored. The maximum value in the leaf nodes is therefore stored
at the root.
-->
各<acronym>FSM</>ページの内部はノード当たり1バイトを持つ配列内に格納されたバイナリツリーです。
各リーフノードはヒープページ、または下位レベルの<acronym>FSM</>ページを表現します。
各非リーフノード内には、子の値より大きな値が格納されます。
したがってリーフノード内の最大値がルートに格納されます。
</para>

<para>
<!--
See <filename>src/backend/storage/freespace/README</> for more details on
how the <acronym>FSM</> is structured, and how it's updated and searched.
The <xref linkend="pgfreespacemap"> module
can be used to examine the information stored in free space maps.
-->
<acronym>FSM</>がどのように構築されるか、そしてどのように更新、検索されるかに関する詳細は<filename>src/backend/storage/freespace/README</>を参照してください。
<xref linkend="pgfreespacemap">モジュールを使用して、空き領域マップに格納された情報を調べることができます。
</para>

</sect1>

<sect1 id="storage-vm">

<!--
<title>Visibility Map</title>
-->
<title>可視性マップ</title>

<indexterm>
<!--
 <primary>Visibility Map</primary>
-->
 <primary>可視性マップ</primary>
</indexterm>
<!--
<indexterm><primary>VM</><see>Visibility Map</></indexterm>
-->
<indexterm><primary>VM</><see>可視性マップ</></indexterm>

<para>
<!--
Each heap relation has a Visibility Map
(VM) to keep track of which pages contain only tuples that are known to be
visible to all active transactions. It's stored
alongside the main relation data in a separate relation fork, named after the
filenode number of the relation, plus a <literal>_vm</> suffix. For example,
if the filenode of a relation is 12345, the VM is stored in a file called
<filename>12345_vm</>, in the same directory as the main relation file.
Note that indexes do not have VMs.
-->
各ヒープリレーションは、どのページがすべての実行中のトランザクションから可視であることが分かっているタプルのみを持つことを追跡する、可視性マップ（VM）を持ちます。
これは、リレーションのファイルノード番号に<literal>_vm</>という接尾辞を付与した名前の別のリレーションフォーク内に主リレーションデータと並行して格納されます。
例えばリレーションのファイルノードが12345の場合、VMは主リレーションファイルと同じディレクトリ内の<filename>12345_vm</>というファイル内に格納されます。
インデックスはVMを持たないことに注意してください。
</para>

<para>
<!--
The visibility map simply stores one bit per heap page. A set bit means
that all tuples on the page are known to be visible to all transactions.
This means that the page does not contain any tuples that need to be vacuumed.
This information can also be used by <firstterm>index-only scans</> to answer
queries using only the index tuple.
-->
可視性マップは単にヒープページ当たり1ビットを保持します。
セットされたビットは、ページ内のすべてのタプルがすべてのトランザクションから可視であることが分かっていることを意味します。
これは、そのページにはバキュームが必要なタプルをまったく含んでいないことを意味します。
またこの情報は、インデックスタプルのみを使用して問い合わせに答えるために<firstterm>インデックスオンリースキャン</>によっても使用されます。
</para>

<para>
<!--
The map is conservative in the sense that we make sure that whenever a bit is
set, we know the condition is true, but if a bit is not set, it might or
might not be true. Visibility map bits are only set by vacuum, but are
cleared by any data-modifying operations on a page.
-->
このマップは、ビットがセットされている時は常にこの条件が真であることを確実に把握できるという点で保守的ですが、ビットがセットされていない場合は、真かもしれませんし偽かもしれません。
可視性マップのビットはバキュームによってのみで設定されます。
しかしページに対する任意のデータ編集操作によってクリアされます。
</para>

</sect1>

<sect1 id="storage-init">

<!--
<title>The Initialization Fork</title>
-->
<title>初期化フォーク</title>

<indexterm>
<!--
 <primary>Initialization Fork</primary>
-->
 <primary>初期化フォーク</primary>
</indexterm>

<para>
<!--
Each unlogged table, and each index on an unlogged table, has an initialization
fork.  The initialization fork is an empty table or index of the appropriate
type.  When an unlogged table must be reset to empty due to a crash, the
initialization fork is copied over the main fork, and any other forks are
erased (they will be recreated automatically as needed).
-->
ログを取らないテーブルと、ログを取らないテーブルに対するインデックスは、それぞれ初期化フォークを持ちます。
初期化フォークとは適切な種類の空テーブルと空インデックスです。
ログを取らないテーブルをクラッシュのために再度空にしなければならない場合、初期化フォークで主フォーク全体をコピーし、その他のフォークは消去されます（これらは必要に応じて自動的に再作成されます）。
</para>

</sect1>

<sect1 id="storage-page-layout">

<!--
<title>Database Page Layout</title>
-->
<title>データベースページのレイアウト</title>

<para>
<!--
This section provides an overview of the page format used within
<productname>PostgreSQL</productname> tables and indexes.<footnote>
  <para>
    Actually, index access methods need not use this page format.
    All the existing index methods do use this basic format,
    but the data kept on index metapages usually doesn't follow
    the item layout rules.
  </para>
</footnote>
Sequences and <acronym>TOAST</> tables are formatted just like a regular table.
-->
本節では<productname>PostgreSQL</productname>のテーブルおよびインデックスで使われるページ書式の概略について説明します。
<footnote>
<para>
実際にはインデックスアクセスメソッドはこのページ書式を使用する必要はありません。
既存のすべてのインデックスメソッドがこの基本書式を使用しています。
しかし、インデックスメタページに保持されるデータは通常、アイテムレイアウト規則に正確には従っていません。
  </para>
</footnote>
<acronym>TOAST</>のテーブルとシーケンスは、通常のテーブルと同様に整形されています。
</para>

<para>
<!--
In the following explanation, a
<firstterm>byte</firstterm>
is assumed to contain 8 bits.  In addition, the term
<firstterm>item</firstterm>
refers to an individual data value that is stored on a page.  In a table,
an item is a row; in an index, an item is an index entry.
-->
以下の説明では1<firstterm>バイト</firstterm>は8ビットからなることを前提としています。
さらに、<firstterm>アイテム</firstterm>という単語は、ページに格納される個別のデータ値のことを指しています。
テーブル内ではアイテムは行であり、インデックス内ではアイテムはインデックスのエントリです。
</para>

<para>
<!--
Every table and index is stored as an array of <firstterm>pages</> of a
fixed size (usually 8 kB, although a different page size can be selected
when compiling the server).  In a table, all the pages are logically
equivalent, so a particular item (row) can be stored in any page.  In
indexes, the first page is generally reserved as a <firstterm>metapage</>
holding control information, and there can be different types of pages
within the index, depending on the index access method.
-->
テーブルとインデックスはすべて、固定サイズ（通常8キロバイト。サーバのコンパイル時に異なるサイズを設定可能）の<firstterm>ページ</>の集まりとして格納されます。
テーブルでは、すべてのページは論理上等価です。
したがって、あるアイテム（行）はどのページにでも格納することができます。
インデックスでは、初めのページは通常、制御用の情報を保持する<firstterm>メタページ</>として予約されます。
また、インデックスではインデックスアクセスメソッドに依存した様々なページ種類があります。
</para>

<para>
<!--
<xref linkend="page-table"> shows the overall layout of a page.
There are five parts to each page.
-->
<xref linkend="page-table">はページの全体的なレイアウトを示しています。
各ページには5つの部分があります。
</para>

<table tocentry="1" id="page-table">
<!--
<title>Overall Page Layout</title>
<titleabbrev>Page Layout</titleabbrev>
-->
<title>ページレイアウト全体</title>
<titleabbrev>ページレイアウト</titleabbrev>
<tgroup cols="2">
<thead>
<row>
<entry>
<!--
Item
-->
アイテム
</entry>
<!--
<entry>Description</entry>
-->
<entry>説明</entry>
</row>
</thead>

<tbody>

<row>
 <entry>PageHeaderData</entry>
<!--
 <entry>24 bytes long. Contains general information about the page, including
free space pointers.</entry>
-->
 <entry>長さは24バイト。空き領域ポインタを含む、ページについての一般情報です。</entry>
</row>

<row>
<entry>ItemIdData</entry>
<!--
<entry>Array of (offset,length) pairs pointing to the actual items.
4 bytes per item.</entry>
-->
<entry>実際のアイテムを指す（オフセットと長さの）ペアの配列です。
1アイテムにつき4バイトです。</entry>
</row>

<row>
<!--
<entry>Free space</entry>
<entry>The unallocated space. New item pointers are allocated from the start
of this area, new items from the end.</entry>
-->
<entry>空き領域</entry>
<entry>割り当てられていない空間です。
新規のアイテムポインタはこの領域の先頭から、新規のアイテムは最後から割り当てられます。
</entry>
</row>

<row>
<!--
<entry>Items</entry>
<entry>The actual items themselves.</entry>
-->
<entry>アイテム</entry>
<entry>実際のアイテムそのものです。</entry>
</row>

<row>
<!--
<entry>Special space</entry>
<entry>Index access method specific data. Different methods store different
data. Empty in ordinary tables.</entry>
-->
<entry>特別な空間</entry>
<entry>インデックスアクセスメソッド特有のデータです。異なるメソッドは異なるデータを格納します。通常のテーブルでは空です。</entry>
</row>

</tbody>
</tgroup>
</table>

 <para>

<!--
  The first 24 bytes of each page consists of a page header
  (PageHeaderData). Its format is detailed in <xref
  linkend="pageheaderdata-table">. The first two fields track the most
  recent WAL entry related to this page. Next is a 2-byte field
  containing flag bits. This is followed by three 2-byte integer fields
  (<structfield>pd_lower</structfield>, <structfield>pd_upper</structfield>,
  and <structfield>pd_special</structfield>). These contain byte offsets
  from the page start to the start
  of unallocated space, to the end of unallocated space, and to the start of
  the special space.
  The next 2 bytes of the page header,
  <structfield>pd_pagesize_version</structfield>, store both the page size
  and a version indicator.  Beginning with
  <productname>PostgreSQL</productname> 8.3 the version number is 4;
  <productname>PostgreSQL</productname> 8.1 and 8.2 used version number 3;
  <productname>PostgreSQL</productname> 8.0 used version number 2;
  <productname>PostgreSQL</productname> 7.3 and 7.4 used version number 1;
  prior releases used version number 0.
  (The basic page layout and header format has not changed in most of these
  versions, but the layout of heap row headers has.)  The page size
  is basically only present as a cross-check; there is no support for having
  more than one page size in an installation.
  The last field is a hint that shows whether pruning the page is likely
  to be profitable: it tracks the oldest un-pruned XMAX on the page.
-->
それぞれのページの最初の24バイトはページヘッダ（PageHeaderData）から構成されています。
その書式を<xref linkend="pageheaderdata-table">にて説明します。
最初の2つのフィールドは、このページに関連する最も最近のWAL項目を表しています。
次にフラグビットを含む2バイトのフィールドがあります。
その後に2バイトの整数フィールドが3つ続きます（<structfield>pd_lower</structfield>、<structfield>pd_upper</structfield>、<structfield>pd_special</structfield>）。
これらには、割り当てられていない空間の始まり、割り当てられていない空間の終わり、そして特別な空間の始まりのバイトオフセットが格納されています。
ページヘッダの次の2バイトである<structfield>pd_pagesize_version</structfield>は、ページサイズとバージョン指示子の両方を格納します。
<productname>PostgreSQL</productname> 8.3以降のバージョン番号は4、<productname>PostgreSQL</productname> 8.1と8.2のバージョン番号は3、<productname>PostgreSQL</productname> 8.0のバージョン番号は2、<productname>PostgreSQL</productname> 7.3と7.4のバージョン番号は1です。
それより前のリリースのバージョン番号は0です
（ほとんどのバージョン間で基本的なページレイアウトやヘッダの書式は変更されていませんが、ヒープ行ヘッダのレイアウトが変更されました）。
ページサイズは基本的に照合用としてのみ存在しています。
同一インストレーションでの複数のページサイズはサポートされていません。
最後のフィールドはそのページの切り詰めが有益かどうかを示すヒントです。
これはページ上で切り詰められていないもっとも古いXMAXが追跡するものです。
 </para>

 <table tocentry="1" id="pageheaderdata-table">
<!--
 <title>PageHeaderData Layout</title>
 <titleabbrev>PageHeaderData Layout</titleabbrev>
-->
 <title>PageHeaderDataのレイアウト</title>
 <titleabbrev>PageHeaderDataのレイアウト</titleabbrev>
 <tgroup cols="4">
 <thead>
  <row>
<!--
   <entry>Field</entry>
   <entry>Type</entry>
   <entry>Length</entry>
   <entry>Description</entry>
-->
<entry>フィールド</entry>
<entry>型</entry>
<entry>長さ</entry>
<entry>説明</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>pd_lsn</entry>
   <entry>XLogRecPtr</entry>
<!--
   <entry>8 bytes</entry>
   <entry>LSN: next byte after last byte of xlog record for last change
   to this page</entry>
-->
   <entry>8バイト</entry>
   <entry>LSN: このページへの最終変更に対応するxlogレコードの最後のバイトの次のバイト</entry>
  </row>
  <row>
   <entry>pd_checksum</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Page checksum</entry>
-->
   <entry>2バイト</entry>
   <entry>ページチェックサム</entry>
  </row>
  <row>
   <entry>pd_flags</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Flag bits</entry>
-->
   <entry>2バイト</entry>
   <entry>フラグビット</entry>
  </row>
  <row>
   <entry>pd_lower</entry>
   <entry>LocationIndex</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Offset to start of free space</entry>
-->
   <entry>2 バイト</entry>
   <entry>空き領域の始まりに対するオフセット</entry>
  </row>
  <row>
   <entry>pd_upper</entry>
   <entry>LocationIndex</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Offset to end of free space</entry>
-->
   <entry>2バイト</entry>
   <entry>空き領域の終わりに対するオフセット</entry>
  </row>
  <row>
   <entry>pd_special</entry>
   <entry>LocationIndex</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Offset to start of special space</entry>
-->
   <entry>2バイト</entry>
   <entry>特別な空間の始まりに対するオフセット</entry>
  </row>
  <row>
   <entry>pd_pagesize_version</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Page size and layout version number information</entry>
-->
   <entry>2バイト</entry>
   <entry>ページサイズおよびレイアウトのバージョン番号の情報</entry>
  </row>
  <row>
   <entry>pd_prune_xid</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>Oldest unpruned XMAX on page, or zero if none</entry>
-->
   <entry>4バイト</entry>
   <entry>ページ上でもっとも古い切り詰められていないXMAX。存在しなければゼロ。</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>
<!--
  All the details can be found in
  <filename>src/include/storage/bufpage.h</filename>.
-->
詳細情報については<filename>src/include/storage/bufpage.h</filename>を参照してください。
 </para>

 <para>

<!--
  Following the page header are item identifiers
  (<type>ItemIdData</type>), each requiring four bytes.
  An item identifier contains a byte-offset to
  the start of an item, its length in bytes, and a few attribute bits
  which affect its interpretation.
  New item identifiers are allocated
  as needed from the beginning of the unallocated space.
  The number of item identifiers present can be determined by looking at
  <structfield>pd_lower</>, which is increased to allocate a new identifier.
  Because an item
  identifier is never moved until it is freed, its index can be used on a
  long-term basis to reference an item, even when the item itself is moved
  around on the page to compact free space.  In fact, every pointer to an
  item (<type>ItemPointer</type>, also known as
  <type>CTID</type>) created by
  <productname>PostgreSQL</productname> consists of a page number and the
  index of an item identifier.
-->
ページヘッダに続くのはアイテム識別子（<type>ItemIdData</type>）です。
識別子ごとに4バイトを必要とします。
アイテム識別子は、アイテムが開始されるバイトオフセット、バイト単位の長さ、そしてその解釈に影響する属性ビット群を持っています。
新しいアイテム識別子は必要に応じて、未割当て空間の最初から割り当てられます。
アイテム識別子の数は、新しい識別子を割り当てるために増加される<structfield>pd_lower</>を見ることで決定できます。
アイテム識別子は解放されるまで動かされることがないので、アイテム自体が空き領域をまとめるためにページ上で移動される場合でも、そのインデックスはアイテムを参照するために長期にわたって使うことができます。
実際、<productname>PostgreSQL</productname>が作る、アイテムへのポインタ（<type>ItemPointer</type>、<type>CTID</type>とも言います）はページ番号とアイテム識別子のインデックスによって構成されています。

 </para>

 <para>
<!--
  The items themselves are stored in space allocated backwards from the end
  of unallocated space.  The exact structure varies depending on what the
  table is to contain. Tables and sequences both use a structure named
  <type>HeapTupleHeaderData</type>, described below.
-->
アイテム自体は、未割り当て空間の最後から順番に割り当てられた空間に格納されます。
正確な構造は、テーブルに何を含めるかによって異なります。
テーブルとシーケンスの両方が、以下で説明する<type>HeapTupleHeaderData</type>という構造を使用します。
 </para>

 <para>

<!--
  The final section is the <quote>special section</quote> which can
  contain anything the access method wishes to store.  For example,
  b-tree indexes store links to the page's left and right siblings,
  as well as some other data relevant to the index structure.
  Ordinary tables do not use a special section at all (indicated by setting
  <structfield>pd_special</> to equal the page size).
-->
最後のセクションは、アクセスメソッドが格納しようとするものを何でも含めることのできる<quote>特別なセクション</quote>です。
例えば、B-treeインデックスは、そのページの両隣のページへのリンク、ならびに、インデックス構造体に関連したその他の何らかのデータを持ちます。
通常のテーブルではこれはまったく使用されません（ページサイズを同じにするために<structfield>pd_special</>を設定することで示されます）。

 </para>

 <para>

<!--
  All table rows are structured in the same way. There is a fixed-size
  header (occupying 23 bytes on most machines), followed by an optional null
  bitmap, an optional object ID field, and the user data. The header is
  detailed
  in <xref linkend="heaptupleheaderdata-table">.  The actual user data
  (columns of the row) begins at the offset indicated by
  <structfield>t_hoff</>, which must always be a multiple of the MAXALIGN
  distance for the platform.
  The null bitmap is
  only present if the <firstterm>HEAP_HASNULL</firstterm> bit is set in
  <structfield>t_infomask</structfield>. If it is present it begins just after
  the fixed header and occupies enough bytes to have one bit per data column
  (that is, <structfield>t_natts</> bits altogether). In this list of bits, a
  1 bit indicates not-null, a 0 bit is a null.  When the bitmap is not
  present, all columns are assumed not-null.
  The object ID is only present if the <firstterm>HEAP_HASOID</firstterm> bit
  is set in <structfield>t_infomask</structfield>.  If present, it appears just
  before the <structfield>t_hoff</> boundary.  Any padding needed to make
  <structfield>t_hoff</> a MAXALIGN multiple will appear between the null
  bitmap and the object ID.  (This in turn ensures that the object ID is
  suitably aligned.)
-->
テーブル行はすべて同じ方法で構成されています。
固定サイズのヘッダ（ほとんどのマシンで23バイトを占有します）があり、その後にオプションのNULLビットマップ、オプションのオブジェクトIDフィールド、およびユーザデータが続きます。
ヘッダについては<xref linkend="heaptupleheaderdata-table">で説明します。
実際のユーザデータ（行内の列）は、常にプラットフォームのMAXALIGN距離の倍数である<structfield>t_hoff</>で示されるオフセットから始まります。
NULLビットマップは<firstterm>HEAP_HASNULL</firstterm>ビットが<structfield>t_infomask</structfield>で設定されている場合にのみ存在します。
存在する場合は、固定ヘッダのすぐ後ろから始まり、データ列ごとに1ビットとするのに十分なバイト数を占有します（合計すると、<structfield>t_natts</>のビット数となります）。
このビットのリスト内では、1ビットは非NULLを、0ビットはNULLを示します。
このビットマップが存在しない場合、すべての列が非NULLとみなされます。
オブジェクトIDは<firstterm>HEAP_HASOID</firstterm>ビットが<structfield>t_infomask</structfield>で設定されている場合にのみ存在します。
存在する場合、これは<structfield>t_hoff</>境界の直前に現れます。
<structfield>t_hoff</>をMAXALIGNの倍数とするために必要なパッドは全て、NULLビットマップとオブジェクトIDの間に現れます
（このことにより、オブジェクトIDの位置揃えが確実に適切になります）。

 </para>

 <table tocentry="1" id="heaptupleheaderdata-table">
<!--
 <title>HeapTupleHeaderData Layout</title>
 <titleabbrev>HeapTupleHeaderData Layout</titleabbrev>
-->
 <title>HeapTupleHeaderDataのレイアウト</title>
 <titleabbrev>HeapTupleHeaderDataのレイアウト</titleabbrev>
 <tgroup cols="4">
 <thead>
  <row>
<!--
   <entry>Field</entry>
   <entry>Type</entry>
   <entry>Length</entry>
   <entry>Description</entry>
-->
<entry>フィールド</entry>
<entry>型</entry>
<entry>長さ</entry>
<entry>説明</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>t_xmin</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>insert XID stamp</entry>
-->
   <entry>4バイト</entry>
   <entry>挿入XIDスタンプ</entry>
  </row>
  <row>
   <entry>t_xmax</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>delete XID stamp</entry>
-->
   <entry>4バイト</entry>
   <entry>削除XIDスタンプ</entry>
  </row>
  <row>
   <entry>t_cid</entry>
   <entry>CommandId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>insert and/or delete CID stamp (overlays with t_xvac)</entry>
-->
   <entry>4バイト</entry>
   <entry>挿入、削除の両方または片方のCIDスタンプ（t_xvacと共有）</entry>
  </row>
  <row>
   <entry>t_xvac</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>XID for VACUUM operation moving a row version</entry>
-->
   <entry>4バイト</entry>
   <entry>行バージョンを移すVACUUM操作用XID</entry>
  </row>
  <row>
   <entry>t_ctid</entry>
   <entry>ItemPointerData</entry>
<!--
   <entry>6 bytes</entry>
   <entry>current TID of this or newer row version</entry>
-->
   <entry>6バイト</entry>
   <entry>この行または最新バージョンの行の現在のTID</entry>
  </row>
  <row>
   <entry>t_infomask2</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>number of attributes, plus various flag bits</entry>
-->
   <entry>2バイト</entry>
   <entry>属性の数と各種フラグビット</entry>
  </row>
  <row>
   <entry>t_infomask</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>various flag bits</entry>
-->
   <entry>2バイト</entry>
   <entry>様々なフラグビット</entry>
  </row>
  <row>
   <entry>t_hoff</entry>
   <entry>uint8</entry>
<!--
   <entry>1 byte</entry>
   <entry>offset to user data</entry>
-->
   <entry>1バイト</entry>
   <entry>ユーザデータに対するオフセット</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>
<!--
   All the details can be found in
   <filename>src/include/access/htup.h</filename>.
-->
詳細情報については<filename>src/include/access/htup.h</filename>を参照してください。
 </para>

 <para>

<!--
  Interpreting the actual data can only be done with information obtained
  from other tables, mostly <structname>pg_attribute</structname>. The
  key values needed to identify field locations are
  <structfield>attlen</structfield> and <structfield>attalign</structfield>.
  There is no way to directly get a
  particular attribute, except when there are only fixed width fields and no
  null values. All this trickery is wrapped up in the functions
  <firstterm>heap_getattr</firstterm>, <firstterm>fastgetattr</firstterm>
  and <firstterm>heap_getsysattr</firstterm>.
-->
実際のデータの解釈は、他のテーブル、ほとんどの場合、<structname>pg_attribute</structname>から取得された情報でのみ行うことができます。
フィールド位置を識別するために必要なキー値は、<structfield>attlen</structfield>および<structfield>attalign</structfield>です。
フィールドの幅が固定されていてNULL値が存在しない場合を除き、特定の属性を直接取得する方法はありません。
この仕組みはすべて、<firstterm>heap_getattr</firstterm>、<firstterm>fastgetattr</firstterm>および<firstterm>heap_getsysattr</firstterm>関数にラップされています。
 </para>

 <para>
<!--
  To read the data you need to examine each attribute in turn. First check
  whether the field is NULL according to the null bitmap. If it is, go to
  the next. Then make sure you have the right alignment.  If the field is a
  fixed width field, then all the bytes are simply placed. If it's a
  variable length field (attlen = -1) then it's a bit more complicated.
  All variable-length data types share the common header structure
  <type>struct varlena</type>, which includes the total length of the stored
  value and some flag bits.  Depending on the flags, the data can be either
  inline or in a <acronym>TOAST</> table;
  it might be compressed, too (see <xref linkend="storage-toast">).
-->
データを読むためには、それぞれの属性を順番に検査する必要があります。
まず、NULLビットマップに従ってフィールドがNULLかどうかを検査します。
もしNULLであれば、次に進みます。
次に、位置揃えが正しいことを確認してください。
フィールドの幅が固定されていれば、すべてのバイトが単純に配置されます。
可変長のフィールド（attlen == -1）の場合はもう少し複雑です。
可変長のデータ型はすべて、格納する値の長さといくつかのフラグビットを持つ<type>struct varlena</type>という共通ヘッダ構造体を共有します。
フラグによって、データは行内、または別のテーブル（TOAST）のいずれかとなったり、圧縮済みとなったりします
（<xref linkend="storage-toast">を参照してください）。
 </para>
</sect1>

</chapter>
