<!-- doc/src/sgml/spgist.sgml -->

<chapter id="SPGiST">
<!--
<title>SP-GiST Indexes</title>
-->
<title>SP-GiSTインデックス</title>

   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>

<sect1 id="spgist-intro">
<!--
 <title>Introduction</title>
-->
 <title>はじめに</title>

 <para>
<!--
  <acronym>SP-GiST</acronym> is an abbreviation for space-partitioned
  <acronym>GiST</acronym>.  <acronym>SP-GiST</acronym> supports partitioned
  search trees, which facilitate development of a wide range of different
  non-balanced data structures, such as quad-trees, k-d trees, and radix
  trees (tries).  The common feature of these structures is that they
  repeatedly divide the search space into partitions that need not be
  of equal size.  Searches that are well matched to the partitioning rule
  can be very fast.
-->
<acronym>SP-GiST</acronym>は、空間分割された(Space-Partitioned)<acronym>GiST</acronym>を短縮した語です。
<acronym>SP-GiST</acronym>は分割された探索木をサポートし、四分木、kd木、基数木(トライ木)など広範にわたる様々な非平衡データ構造の開発を可能にします。
これらの構造に共通の特徴は、それらが探索空間を繰り返し小さな領域に分割し、その領域の大きさが必ずしも等しくない、ということです。
分割規則によく適合した検索は非常に高速になります。
 </para>

 <para>
<!--
  These popular data structures were originally developed for in-memory
  usage.  In main memory, they are usually designed as a set of dynamically
  allocated nodes linked by pointers.  This is not suitable for direct
  storing on disk, since these chains of pointers can be rather long which
  would require too many disk accesses.  In contrast, disk-based data
  structures should have a high fanout to minimize I/O.  The challenge
  addressed by <acronym>SP-GiST</acronym> is to map search tree nodes to
  disk pages in such a way that a search need access only a few disk pages,
  even if it traverses many nodes.
-->
これらのよく使われるデータ構造は、元々はメモリ内での利用のために開発されたものでした。
主記憶上では、それらは通常、ポインタにより接続され、動的に割り当てられるノードの集合として設計されます。
このようなポインタのチェーンは長くなりがちで、非常に多くのディスクアクセスが必要となるため、ディスク上に直接格納するには適しません。
これとは反対に、ディスクベースのデータ構造は、I/Oを最小化する、大きな論理出力数を持つべきです。
<acronym>SP-GiST</acronym>によって解決される困難とは、探索木のノードをディスクのページにマップするときに、多数のノードを通り抜ける場合であっても、探索ではごく少数のディスクページにしかアクセスしないですむようにすることです。
 </para>

 <para>
<!--
  Like <acronym>GiST</acronym>, <acronym>SP-GiST</acronym> is meant to allow
  the development of custom data types with the appropriate access methods,
  by an expert in the domain of the data type, rather than a database expert.
-->
<acronym>GiST</acronym>と同じく、<acronym>SP-GiST</acronym>は適切なアクセス方法のある独自のデータ型の開発を可能にするためのもので、データベースのエキスパートよりもむしろ、そのデータ型の領域のエキスパートによる開発を可能にします。
 </para>

 <para>
<!--
  Some of the information here is derived from Purdue University's
  SP-GiST Indexing Project
  <ulink url="http://www.cs.purdue.edu/spgist/">web site</ulink>.
  The <acronym>SP-GiST</acronym> implementation in
  <productname>PostgreSQL</productname> is primarily maintained by Teodor
  Sigaev and Oleg Bartunov, and there is more information on their
-->
  <!-- URL will be changed -->
<!--
  <ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">web site</ulink>.
-->
ここで記述する情報の一部はPurdue大学のSP-GiSTインデックスプロジェクト<ulink url="http://www.cs.purdue.edu/spgist/">WEBサイト</ulink>によるものです。
<productname>PostgreSQL</productname>での<acronym>SP-GiST</acronym>の実装は、おもにTeodor SigaevとOleg Bartunovによって保守されており、詳しい情報は彼らの<ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">WEBサイト</ulink>にあります。
 </para>

</sect1>

<sect1 id="spgist-builtin-opclasses">
<!--
 <title>Built-in Operator Classes</title>
-->
 <title>ビルトインの演算子クラス</title>

 <para>
<!--
  The core <productname>PostgreSQL</> distribution
  includes the <acronym>SP-GiST</acronym> operator classes shown in
  <xref linkend="spgist-builtin-opclasses-table">.
-->
<productname>PostgreSQL</>のコアディストリビューションには<xref linkend="spgist-builtin-opclasses-table">に示される<acronym>SP-GiST</acronym>の演算子クラスが含まれます。
 </para>

  <table id="spgist-builtin-opclasses-table">
<!--
   <title>Built-in <acronym>SP-GiST</acronym> Operator Classes</title>
-->
   <title>ビルトインの<acronym>SP-GiST</acronym>の演算子クラス</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Name</entry>
      <entry>Indexed Data Type</entry>
      <entry>Indexable Operators</entry>
-->
      <entry>名前</entry>
      <entry>インデックスされるデータ型</entry>
      <entry>インデックス可能な演算子</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>kd_point_ops</></entry>
      <entry><type>point</></entry>
      <entry>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>&lt;^</>
       <literal>&gt;&gt;</>
       <literal>&gt;^</>
       <literal>~=</>
      </entry>
     </row>
     <row>
      <entry><literal>quad_point_ops</></entry>
      <entry><type>point</></entry>
      <entry>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>&lt;^</>
       <literal>&gt;&gt;</>
       <literal>&gt;^</>
       <literal>~=</>
      </entry>
     </row>
     <row>
      <entry><literal>range_ops</></entry>
<!--
      <entry>any range type</entry>
-->
      <entry>任意の範囲型</entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&amp;&lt;</>
       <literal>&amp;&gt;</>
       <literal>-|-</>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>&gt;&gt;</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>text_ops</></entry>
      <entry><type>text</></entry>
      <entry>
       <literal>&lt;</>
       <literal>&lt;=</>
       <literal>=</>
       <literal>&gt;</>
       <literal>&gt;=</>
       <literal>~&lt;=~</>
       <literal>~&lt;~</>
       <literal>~&gt;=~</>
       <literal>~&gt;~</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 <para>
<!--
  Of the two operator classes for type <type>point</>,
  <literal>quad_point_ops</> is the default.  <literal>kd_point_ops</>
  supports the same operators but uses a different index data structure which
  may offer better performance in some applications.
-->
<type>point</>型の2つの演算子クラスのうち、<literal>quad_point_ops</>がデフォルトです。
<literal>kd_point_ops</>は同じ演算子をサポートしますが、異なるインデックスデータ構造を使うため、アプリケーションによってはより良いパフォーマンスを提供することがあります。
 </para>

</sect1>

<sect1 id="spgist-extensibility">
<!--
 <title>Extensibility</title>
-->
 <title>拡張性</title>

 <para>
<!--
  <acronym>SP-GiST</acronym> offers an interface with a high level of
  abstraction, requiring the access method developer to implement only
  methods specific to a given data type. The <acronym>SP-GiST</acronym> core
  is responsible for efficient disk mapping and searching the tree structure.
  It also takes care of concurrency and logging considerations.
-->
<acronym>SP-GiST</acronym>は高度に抽象化されたインタフェースを提供します。アクセスメソッドの開発者は特定のデータ型専用のメソッドだけを開発する必要があります。
<acronym>SP-GiST</acronym>のコアは効率的なディスクマッピングと木構造の探索を担当します。
また、同時実行制御とログ出力も担当します。
 </para>

 <para>
<!--
  Leaf tuples of an <acronym>SP-GiST</acronym> tree contain values of the
  same data type as the indexed column.  Leaf tuples at the root level will
  always contain the original indexed data value, but leaf tuples at lower
  levels might contain only a compressed representation, such as a suffix.
  In that case the operator class support functions must be able to
  reconstruct the original value using information accumulated from the
  inner tuples that are passed through to reach the leaf level.
-->
<acronym>SP-GiST</acronym>のツリーのリーフタプルは、インデックスの付けられた列と同じデータ型の値を含んでいます。
ルートレベルにあるリーフタプルは、必ずインデックスが付けられた元のデータの値を含んでいますが、より下のレベルのリーフタプルは、接尾辞など、圧縮された表現しか含んでいないかも知れません。
この場合、演算子クラスのサポート関数が、内部タプルをリーフレベルまでたどりながら集める情報を使って元の値を再構築できる必要があります。
 </para>

 <para>
<!--
  Inner tuples are more complex, since they are branching points in the
  search tree.  Each inner tuple contains a set of one or more
  <firstterm>nodes</>, which represent groups of similar leaf values.
  A node contains a downlink that leads to either another, lower-level inner
  tuple, or a short list of leaf tuples that all lie on the same index page.
  Each node has a <firstterm>label</> that describes it; for example,
  in a radix tree the node label could be the next character of the string
  value.  Optionally, an inner tuple can have a <firstterm>prefix</> value
  that describes all its members.  In a radix tree this could be the common
  prefix of the represented strings.  The prefix value is not necessarily
  really a prefix, but can be any data needed by the operator class;
  for example, in a quad-tree it can store the central point that the four
  quadrants are measured with respect to.  A quad-tree inner tuple would
  then also contain four nodes corresponding to the quadrants around this
  central point.
-->
内部タプルは、探索木の分岐点となるため、もっと複雑です。
それぞれの内部タプルは1つ以上の<firstterm>ノード</>の集合を含んでおり、ノードは類似のリーフ値のグループを表現します。
ノードは下向きのリンクを含んでおり、これは下のレベルの別の内部タプルを指すか、あるいはすべて同じインデックスページ上に載っているリーフタプルの短いリストを指しています。
それぞれのノードは、それを記述する<firstterm>label</>を持っています。
例えば、基数木では、ノードのラベルは文字列の値の次の文字にすることができます。
省略可能ですが、内部タプルはそのすべてのメンバーを記述する<firstterm>接頭辞</>の値を持つことができます。
基数木では、これは表現される文字列に共通の接頭辞とすることができます。
接頭辞の値は、必ずしも本当の接頭辞である必要はなく、演算子クラスが必要とする任意の値で良いです。
例えば四分木では、その中心点を保持し、4つの象限をそこから相対的に測るようにできます。
そうすると、四分木の内部タプルはこの中心点の周りの象限に対応する4つのノードも含むことになるでしょう。
 </para>

 <para>
<!--
  Some tree algorithms require knowledge of level (or depth) of the current
  tuple, so the <acronym>SP-GiST</acronym> core provides the possibility for
  operator classes to manage level counting while descending the tree.
  There is also support for incrementally reconstructing the represented
  value when that is needed.
-->
木構造のアルゴリズムには、現在のタプルのレベル(深さ)を知っていることが必要なものがあります。そこで、<acronym>SP-GiST</acronym>のコアは、演算子クラスが木構造をたどって下がるときにレベル数の管理を可能にしています。
また、必要であれば、表現される値を加算的に再構築することもサポートしています。
 </para>

 <note>
  <para>
<!--
   The <acronym>SP-GiST</acronym> core code takes care of null entries.
   Although <acronym>SP-GiST</acronym> indexes do store entries for nulls
   in indexed columns, this is hidden from the index operator class code:
   no null index entries or search conditions will ever be passed to the
   operator class methods.  (It is assumed that <acronym>SP-GiST</acronym>
   operators are strict and so cannot succeed for null values.)  Null values
   are therefore not discussed further here.
-->
<acronym>SP-GiST</acronym>のコアのコードはnullエントリについても対応しています。
<acronym>SP-GiST</acronym>のインデックスはインデックス列がnullのエントリについても格納しますが、これはインデックスの演算子クラスのコードからは隠されているので、nullのインデックスエントリや検索条件が演算子クラスのメソッドに渡されることはありません。
(<acronym>SP-GiST</acronym>の演算子は厳格なのでNULL値について成功を返すことはできないと想定されています。)
従って、ここではこれ以上、NULLについて議論しません。
  </para>
 </note>

 <para>
<!--
  There are five user-defined methods that an index operator class for
  <acronym>SP-GiST</acronym> must provide.  All five follow the convention
  of accepting two <type>internal</> arguments, the first of which is a
  pointer to a C struct containing input values for the support method,
  while the second argument is a pointer to a C struct where output values
  must be placed.  Four of the methods just return <type>void</>, since
  all their results appear in the output struct; but
  <function>leaf_consistent</> additionally returns a <type>boolean</> result.
  The methods must not modify any fields of their input structs.  In all
  cases, the output struct is initialized to zeroes before calling the
  user-defined method.
-->
<acronym>SP-GiST</acronym>のインデックス演算子クラスが提供しなければならないユーザ定義メソッドが5つあります。
5つのメソッドはいずれも2つの<type>internal</>引数をとり、1番目の引数はサポートメソッドの入力値を含むCの構造体へのポインタ、2番目の引数は出力値が置かれるCの構造体へのポインタという形式に従っています。
メソッドのうち4つは、その結果がすべて出力構造体の中にあるので、単に<type>void</>を返しますが、<function>leaf_consistent</>は、さらに<type>boolean</>の結果を返します。
メソッドは、その入力構造体のどのフィールドも変更してはいけません。
どんな場合でも、出力構造体はユーザ定義メソッドを呼び出す前にゼロに初期化されます。
 </para>

 <para>
<!--
  The five user-defined methods are:
-->
5つのユーザ定義メソッドは以下のとおりです。
 </para>

 <variablelist>
    <varlistentry>
     <term><function>config</></term>
     <listitem>
      <para>
<!--
       Returns static information about the index implementation, including
       the data type OIDs of the prefix and node label data types.
-->
接頭辞とノードラベルのデータ型のデータ型OIDを含め、インデックスの実装に関する静的情報を返します。
      </para>
     <para>
<!--
      The <acronym>SQL</> declaration of the function must look like this:
-->
関数の<acronym>SQL</>宣言は以下のようになります。
<programlisting>
CREATE FUNCTION my_config(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgConfigIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgConfigOut</>
      C struct, which the function must fill with result data.
-->
1番目の引数はCの<structname>spgConfigIn</>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<structname>spgConfigOut</>構造体へのポインタで、関数が結果のデータを入れます。
<programlisting>
typedef struct spgConfigIn
{
    Oid         attType;        /* Data type to be indexed */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Data type of inner-tuple prefixes */
    Oid         labelType;      /* Data type of inner-tuple node labels */
    bool        canReturnData;  /* Opclass can reconstruct original data */
    bool        longValuesOK;   /* Opclass can cope with values &gt; 1 page */
} spgConfigOut;
</programlisting>

<!--
      <structfield>attType</> is passed in order to support polymorphic
      index operator classes; for ordinary fixed-data-type operator classes, it
      will always have the same value and so can be ignored.
-->
<structfield>attType</>は多様のインデックス演算子クラスをサポートするために渡されます。
通常の固定データ型の演算子クラスでは、それは常に同じ値を持っているので無視できます。
     </para>

     <para>
<!--
      For operator classes that do not use prefixes,
      <structfield>prefixType</> can be set to <literal>VOIDOID</>.
      Likewise, for operator classes that do not use node labels,
      <structfield>labelType</> can be set to <literal>VOIDOID</>.
      <structfield>canReturnData</> should be set true if the operator class
      is capable of reconstructing the originally-supplied index value.
      <structfield>longValuesOK</> should be set true only when the
      <structfield>attType</> is of variable length and the operator
      class is capable of segmenting long values by repeated suffixing
      (see <xref linkend="spgist-limits">).
-->
接頭辞を使わない演算子クラスでは、<structfield>prefixType</>を<literal>VOIDOID</>に設定することができます。
同様に、ノードラベルを使わない演算子クラスでは、<structfield>labelType</>を<literal>VOIDOID</>に設定することができます。
演算子クラスが、元々提供されていたインデックスの値を再構築できるときは、<structfield>canReturnData</>をtrueにします。
<structfield>attType</>が可変長で、演算子クラスが接尾辞付けの繰り返しによって長い値を分割できるときにのみ、<structfield>longValuesOK</>をtrueにします(<xref linkend="spgist-limits">参照)。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>choose</></term>
     <listitem>
      <para>
<!--
        Chooses a method for inserting a new value into an inner tuple.
-->
内部タプルに新しい値を挿入するときのメソッドを選択します。
      </para>

     <para>
<!--
      The <acronym>SQL</> declaration of the function must look like this:
-->
関数の<acronym>SQL</>宣言は以下のようになります。
<programlisting>
CREATE FUNCTION my_choose(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgChooseIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgChooseOut</>
      C struct, which the function must fill with result data.
-->
1番目の引数はCの<structname>spgChooseIn</>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<structname>spgChooseOut</>構造体へのポインタで、関数が結果のデータを入れます。
<programlisting>
typedef struct spgChooseIn
{
    Datum       datum;          /* original datum to be indexed */
    Datum       leafDatum;      /* current datum to be stored at leaf */
    int         level;          /* current level (counting from zero) */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* descend into existing node */
    spgAddNode,                 /* add a node to the inner tuple */
    spgSplitTuple               /* split inner tuple (change its prefix) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* action code, see above */
    union
    {
        struct                  /* results for spgMatchNode */
        {
            int         nodeN;      /* descend to this node (index from 0) */
            int         levelAdd;   /* increment level by this much */
            Datum       restDatum;  /* new leaf datum */
        }           matchNode;
        struct                  /* results for spgAddNode */
        {
            Datum       nodeLabel;  /* new node's label */
            int         nodeN;      /* where to insert it (index from 0) */
        }           addNode;
        struct                  /* results for spgSplitTuple */
        {
            /* Info to form new inner tuple with one node */
            bool        prefixHasPrefix;    /* tuple should have a prefix? */
            Datum       prefixPrefixDatum;  /* if so, its value */
            Datum       nodeLabel;          /* node's label */

            /* Info to form new lower-level inner tuple with all old nodes */
            bool        postfixHasPrefix;   /* tuple should have a prefix? */
            Datum       postfixPrefixDatum; /* if so, its value */
        }           splitTuple;
    }           result;
} spgChooseOut;
</programlisting>

<!--
       <structfield>datum</> is the original datum that was to be inserted
       into the index.
       <structfield>leafDatum</> is initially the same as
       <structfield>datum</>, but can change at lower levels of the tree
       if the <function>choose</function> or <function>picksplit</function>
       methods change it.  When the insertion search reaches a leaf page,
       the current value of <structfield>leafDatum</> is what will be stored
       in the newly created leaf tuple.
       <structfield>level</> is the current inner tuple's level, starting at
       zero for the root level.
       <structfield>allTheSame</> is true if the current inner tuple is
       marked as containing multiple equivalent nodes
       (see <xref linkend="spgist-all-the-same">).
       <structfield>hasPrefix</> is true if the current inner tuple contains
       a prefix; if so,
       <structfield>prefixDatum</> is its value.
       <structfield>nNodes</> is the number of child nodes contained in the
       inner tuple, and
       <structfield>nodeLabels</> is an array of their label values, or
       NULL if there are no labels.
-->
<structfield>datum</>はインデックスに挿入される元のデータです。
<structfield>leafDatum</>は最初は<structfield>datum</>と同じですが、<function>choose</function>あるいは<function>picksplit</function>メソッドがそれを変更すると、ツリーのより低いレベルで変更されることがあります。
挿入の探索がリーフのページに到達したとき、<structfield>leafDatum</>の現在値が、新しく作成されるリーフタプルに格納される値となります。
<structfield>level</>は、ルートレベルを0として、現在の内部タプルのレベルを示します。
現在の内部タプルが複数の同等なノードを含むとして印を付けられているとき、<structfield>allTheSame</>をtrueにします(<xref linkend="spgist-all-the-same">参照)。
現在の内部タプルが接頭辞を含むとき、<structfield>hasPrefix</>をtrueにします。
このとき、<structfield>prefixDatum</>がその値になります。
<structfield>nNodes</>は内部タプルが含む子ノードの数で、<structfield>nodeLabels</>はそれらのラベル値の配列、あるいはラベルがなければNULLになります。
      </para>

      <para>
<!--
       The <function>choose</function> function can determine either that
       the new value matches one of the existing child nodes, or that a new
       child node must be added, or that the new value is inconsistent with
       the tuple prefix and so the inner tuple must be split to create a
       less restrictive prefix.
-->
<function>choose</function>関数は、新しい値が既存の子ノードの1つとマッチするか、新しい子ノードを追加する必要があるか、あるいは新しい値がタプルの接頭辞と適合しないので内部タプルを分割してより制限のない接頭辞を作成する必要があるか、を決定することができます。
      </para>

      <para>
<!--
       If the new value matches one of the existing child nodes,
       set <structfield>resultType</> to <literal>spgMatchNode</>.
       Set <structfield>nodeN</> to the index (from zero) of that node in
       the node array.
       Set <structfield>levelAdd</> to the increment in
       <structfield>level</> caused by descending through that node,
       or leave it as zero if the operator class does not use levels.
       Set <structfield>restDatum</> to equal <structfield>datum</>
       if the operator class does not modify datums from one level to the
       next, or otherwise set it to the modified value to be used as
       <structfield>leafDatum</> at the next level.
-->
新しい値が既存の子ノードの1つにマッチしたときは、<structfield>resultType</>を<literal>spgMatchNode</>にセットします。
<structfield>nodeN</>はノードの配列中のそのノードの番号(0から)にセットします。
<structfield>levelAdd</>は、そのノードをたどって下がるときに生じた<structfield>level</>の増分にセットします。あるいは演算子クラスがレベルを使っていなければ0のままにします。
<structfield>restDatum</>は、演算子クラスがデータをあるレベルから次のレベルに変更しないのであれば、<structfield>datum</>に等しくセットします。そうでなければ、次のレベルで<structfield>leafDatum</>として使われる修正された値にセットします。
      </para>

      <para>
<!--
       If a new child node must be added,
       set <structfield>resultType</> to <literal>spgAddNode</>.
       Set <structfield>nodeLabel</> to the label to be used for the new
       node, and set <structfield>nodeN</> to the index (from zero) at which
       to insert the node in the node array.
       After the node has been added, the <function>choose</function>
       function will be called again with the modified inner tuple;
       that call should result in an <literal>spgMatchNode</> result.
-->
新しい子ノードを追加しなければならないときは、<structfield>resultType</>を<literal>spgAddNode</>にセットします。
<structfield>nodeLabel</>は、新しいノードで使われるラベルにセットし、<structfield>nodeN</>はノードの配列中の挿入される場所のノードの番号(0から)にセットします。
ノードを追加した後で、<function>choose</function>関数を修正された内部タプルを使って再び呼び出しますが、このときは、<literal>spgMatchNode</>という結果になるはずです。
      </para>

      <para>
<!--
       If the new value is inconsistent with the tuple prefix,
       set <structfield>resultType</> to <literal>spgSplitTuple</>.
       This action moves all the existing nodes into a new lower-level
       inner tuple, and replaces the existing inner tuple with a tuple
       having a single node that links to the new lower-level inner tuple.
       Set <structfield>prefixHasPrefix</> to indicate whether the new
       upper tuple should have a prefix, and if so set
       <structfield>prefixPrefixDatum</> to the prefix value.  This new
       prefix value must be sufficiently less restrictive than the original
       to accept the new value to be indexed, and it should be no longer
       than the original prefix.
       Set <structfield>nodeLabel</> to the label to be used for the
       node that will point to the new lower-level inner tuple.
       Set <structfield>postfixHasPrefix</> to indicate whether the new
       lower-level inner tuple should have a prefix, and if so set
       <structfield>postfixPrefixDatum</> to the prefix value.  The
       combination of these two prefixes and the additional label must
       have the same meaning as the original prefix, because there is
       no opportunity to alter the node labels that are moved to the new
       lower-level tuple, nor to change any child index entries.
       After the node has been split, the <function>choose</function>
       function will be called again with the replacement inner tuple.
       That call will usually result in an <literal>spgAddNode</> result,
       since presumably the node label added in the split step will not
       match the new value; so after that, there will be a third call
       that finally returns <literal>spgMatchNode</> and allows the
       insertion to descend to the leaf level.
-->
新しい値がタプルの接頭辞と適合しないときは、<structfield>resultType</>を<literal>spgSplitTuple</>にセットします。
このアクションは、すべての既存のノードを新しい低位の内部タプルに移動し、新しい低位の内部タプルにリンクする単一のノードを持つ新しいタプルで既存のタプルを置換します。
<structfield>prefixHasPrefix</>は新しい上位のタプルが接頭辞を持つかどうかを示し、持つ場合には<structfield>prefixPrefixDatum</>をその接頭辞の値にセットします。
インデックスに追加される新しい値を受け入れるため、新しい接頭辞の値は元のものよりも制限の緩いものになっている必要があり、また元の接頭辞より長くはなりません。
<structfield>nodeLabel</>は、新しい低位の内部タプルを指し示すノードで使われるラベルにセットします。
<structfield>postfixHasPrefix</>は、新しい低位のタプルが接頭辞を持つかどうかを示し、持つときには<structfield>postfixPrefixDatum</>を接頭辞の値にセットします。
新しい低位に移動したタプルのノードのラベルを変更する機会も、子のインデックスのエントリを変更する機会もありませんから、これら2つの接頭辞と追加のラベルの組み合わせは、元の接頭辞と同じ意味を持つ必要があります。
ノードが分割された後で、<function>choose</function>を置換した内部タプルを使って再び呼び出します。
この呼び出しは、通常は<literal>spgAddNode</>という結果になります。というのは、分割のステップで追加されたノードのラベルは恐らく新しい値とマッチしないからです。
従って、その後、3回目の呼び出しでやっと<literal>spgMatchNode</>が返り、リーフレベルに下がる挿入が可能となります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</></term>
     <listitem>
      <para>
<!--
       Decides how to create a new inner tuple over a set of leaf tuples.
-->
リーフタプルの集合に対し、新しい内部タプルをどうやって作るかを決定します。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
関数の<acronym>SQL</>宣言は以下のようになります。
<programlisting>
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgPickSplitIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgPickSplitOut</>
      C struct, which the function must fill with result data.
-->
1番目の引数はCの<structname>spgPickSplitIn</>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<structname>spgPickSplitOut</>構造体へのポインタで、関数が結果のデータを入れます。
<programlisting>
typedef struct spgPickSplitIn
{
    int         nTuples;        /* number of leaf tuples */
    Datum      *datums;         /* their datums (array of length nTuples) */
    int         level;          /* current level (counting from zero) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* new inner tuple should have a prefix? */
    Datum       prefixDatum;    /* if so, its value */

    int         nNodes;         /* number of nodes for new inner tuple */
    Datum      *nodeLabels;     /* their labels (or NULL for no labels) */

    int        *mapTuplesToNodes;   /* node index for each leaf tuple */
    Datum      *leafTupleDatums;    /* datum to store in each new leaf tuple */
} spgPickSplitOut;
</programlisting>

<!--
       <structfield>nTuples</> is the number of leaf tuples provided.
       <structfield>datums</> is an array of their datum values.
       <structfield>level</> is the current level that all the leaf tuples
       share, which will become the level of the new inner tuple.
-->
<structfield>nTuples</>は入力されるリーフタプルの個数です。
<structfield>datums</>はデータの値の配列です。
<structfield>level</>はすべてのリーフタプルの現在のレベルで、これが新しい内部タプルのレベルになります。
      </para>

      <para>
<!--
       Set <structfield>hasPrefix</> to indicate whether the new inner
       tuple should have a prefix, and if so set
       <structfield>prefixDatum</> to the prefix value.
       Set <structfield>nNodes</> to indicate the number of nodes that
       the new inner tuple will contain, and
       set <structfield>nodeLabels</> to an array of their label values.
       (If the nodes do not require labels, set <structfield>nodeLabels</>
       to NULL; see <xref linkend="spgist-null-labels"> for details.)
       Set <structfield>mapTuplesToNodes</> to an array that gives the index
       (from zero) of the node that each leaf tuple should be assigned to.
       Set <structfield>leafTupleDatums</> to an array of the values to
       be stored in the new leaf tuples (these will be the same as the
       input <structfield>datums</> if the operator class does not modify
       datums from one level to the next).
       Note that the <function>picksplit</> function is
       responsible for palloc'ing the
       <structfield>nodeLabels</>, <structfield>mapTuplesToNodes</> and
       <structfield>leafTupleDatums</> arrays.
-->
<structfield>hasPrefix</>は新しい内部タプルが接頭辞を持つかどうかを示し、持つ場合は<structfield>prefixDatum</>を接頭辞の値にセットします。
<structfield>nNodes</>は新しい内部タプルが含むノードの数を示し、<structfield>nodeLabels</>はそのラベル値の配列にセットします。
(ノードがラベルを必要としないときは、<structfield>nodeLabels</>をNULLにセットします。詳細は<xref linkend="spgist-null-labels">を参照してください。)
<structfield>mapTuplesToNodes</>は、それぞれのリーフタプルが割り当てられるノードの番号(0から)の配列にセットします。
<structfield>leafTupleDatums</>は新しいリーフタプルに格納される値の配列にセットします(演算子クラスがデータをあるレベルから次のレベルに変更しなければこれらは入力の<structfield>datums</>と同じになります)。
<function>picksplit</>関数は、<structfield>nodeLabels</>、<structfield>mapTuplesToNodes</>、<structfield>leafTupleDatums</>の配列についてpallocしなければならないことに注意してください。
      </para>

      <para>
<!--
       If more than one leaf tuple is supplied, it is expected that the
       <function>picksplit</> function will classify them into more than
       one node; otherwise it is not possible to split the leaf tuples
       across multiple pages, which is the ultimate purpose of this
       operation.  Therefore, if the <function>picksplit</> function
       ends up placing all the leaf tuples in the same node, the core
       SP-GiST code will override that decision and generate an inner
       tuple in which the leaf tuples are assigned at random to several
       identically-labeled nodes.  Such a tuple is marked
       <literal>allTheSame</> to signify that this has happened.  The
       <function>choose</> and <function>inner_consistent</> functions
       must take suitable care with such inner tuples.
       See <xref linkend="spgist-all-the-same"> for more information.
-->
2つ以上のリーフタプルを与えた場合、<function>picksplit</>関数はそれらを2つ以上のノードに分類すると予想されます。そうでなければ、リーフタプルを複数のページにまたがって分割するという、この操作の究極の目的を実現できないからです。
従って、<function>picksplit</>がすべてのリーフタプルを同じノードに置くことになった場合には、SP-GiSTのコアのコードがその決定を覆して内部タプルを生成し、その中の複数の同一のラベルが付けられたノードに、リーフタプルが無作為に割り当てられます。
そのようなタプルは、このことが発生したことを明示するため、<literal>allTheSame</>と印がつけられます。
<function>choose</>関数と<function>inner_consistent</>関数は、これらの内部タプルについて、適切な注意をして取り扱わなければなりません。
詳細な情報は<xref linkend="spgist-all-the-same">を参照してください。
      </para>

      <para>
<!--
       <function>picksplit</> can be applied to a single leaf tuple only
       in the case that the <function>config</> function set
       <structfield>longValuesOK</> to true and a larger-than-a-page input
       value has been supplied.  In this case the point of the operation is
       to strip off a prefix and produce a new, shorter leaf datum value.
       The call will be repeated until a leaf datum short enough to fit on
       a page has been produced.  See <xref linkend="spgist-limits"> for
       more information.
-->
<function>config</>関数が<structfield>longValuesOK</>をtrueにセットし、1ページよりも大きな入力値を与える場合にのみ、<function>picksplit</>を1つだけのリーフタプルに適用できます。
この場合の操作の重要な点は、接頭辞をはがして、新しい、より短いリーフデータの値を生成することです。
この呼出は、1ページに収まる短さのリーフデータが生成されるまで繰り返されます。
詳細な情報は<xref linkend="spgist-limits">を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>inner_consistent</></term>
     <listitem>
      <para>
<!--
       Returns set of nodes (branches) to follow during tree search.
-->
ツリーの探索でたどるべきノード(枝)の集合を返します。
      </para>

      <para>
<!--
       The <acronym>SQL</> declaration of the function must look like this:
-->
関数の<acronym>SQL</>宣言は以下のようになります。
<programlisting>
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgInnerConsistentIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgInnerConsistentOut</>
      C struct, which the function must fill with result data.
-->
1番目の引数はCの<structname>spgInnerConsistentIn</>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<structname>spgInnerConsistentOut</>構造体へのポインタで、関数が結果のデータを入れます。

<programlisting>
typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    int         nkeys;          /* length of array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* number of child nodes to be visited */
    int        *nodeNumbers;    /* their indexes in the node array */
    int        *levelAdds;      /* increment level by this much for each */
    Datum      *reconstructedValues;    /* associated reconstructed values */
} spgInnerConsistentOut;
</programlisting>

<!--
       The array <structfield>scankeys</>, of length <structfield>nkeys</>,
       describes the index search condition(s).  These conditions are
       combined with AND &mdash; only index entries that satisfy all of
       them are interesting.  (Note that <structfield>nkeys</> = 0 implies
       that all index entries satisfy the query.)  Usually the consistent
       function only cares about the <structfield>sk_strategy</> and
       <structfield>sk_argument</> fields of each array entry, which
       respectively give the indexable operator and comparison value.
       In particular it is not necessary to check <structfield>sk_flags</> to
       see if the comparison value is NULL, because the SP-GiST core code
       will filter out such conditions.
       <structfield>reconstructedValue</> is the value reconstructed for the
       parent tuple; it is <literal>(Datum) 0</> at the root level or if the
       <function>inner_consistent</> function did not provide a value at the
       parent level.
       <structfield>level</> is the current inner tuple's level, starting at
       zero for the root level.
       <structfield>returnData</> is <literal>true</> if reconstructed data is
       required for this query; this will only be so if the
       <function>config</> function asserted <structfield>canReturnData</>.
       <structfield>allTheSame</> is true if the current inner tuple is
       marked <quote>all-the-same</>; in this case all the nodes have the
       same label (if any) and so either all or none of them match the query
       (see <xref linkend="spgist-all-the-same">).
       <structfield>hasPrefix</> is true if the current inner tuple contains
       a prefix; if so,
       <structfield>prefixDatum</> is its value.
       <structfield>nNodes</> is the number of child nodes contained in the
       inner tuple, and
       <structfield>nodeLabels</> is an array of their label values, or
       NULL if the nodes do not have labels.
-->
配列<structfield>scankeys</>は長さが<structfield>nkeys</>で、インデックス検索の条件を記述します。
複数の条件はANDで結合されます。つまり、条件のすべてを満たすインデックスエントリのみが対象となります。
(<structfield>nkeys</>が0ならば、すべてのエントリが検索条件を満たすことになる、ということに注意してください。)
通常、consistent関数では、配列のそれぞれのエントリの<structfield>sk_strategy</>および<structfield>sk_argument</>フィールドのみが問題となります。これらのフィールドにはそれぞれインデックス付け可能な演算子と比較値が入ります。
なお、比較値がNULLかどうかを確認するために<structfield>sk_flags</>を検査する必要はありません。なぜならSP-GiSTのコアのコードがそのような条件を除外するからです。
<structfield>reconstructedValue</>は親タプルのために再構築された値で、ルートレベルの場合、あるいは親レベルの<function>inner_consistent</>関数が値を返さなかった場合は<literal>(Datum) 0</>となります。
<structfield>level</>は現在の内部タプルのレベルを、ルートレベルを0として数えたものです。
<structfield>returnData</>は、この問い合わせで再構築されたデータが必要な場合に<literal>true</>となりますが、これは<function>config</>関数が<structfield>canReturnData</>を確認した場合にのみ、そうなります。
<structfield>allTheSame</>は、現在の内部タプルに<quote>all-the-same</>の印が付いている場合にtrueになります。この場合、すべてのノードは(ラベルがあれば)同じラベルを持っていますから、そのすべてが問い合わせにマッチするか、いずれもマッチしないかのいずれかになります(<xref linkend="spgist-all-the-same">参照)。
<structfield>hasPrefix</>は現在の内部タプルが接頭辞を持っている場合にtrueとなり、このとき<structfield>prefixDatum</>がその値となります。
<structfield>nNodes</>は内部タプルが含む子ノードの数です。<structfield>nodeLabels</>はそれらのラベル値の配列で、ノードにラベルがないときはNULLになります。
      </para>

      <para>
<!--
       <structfield>nNodes</> must be set to the number of child nodes that
       need to be visited by the search, and
       <structfield>nodeNumbers</> must be set to an array of their indexes.
       If the operator class keeps track of levels, set
       <structfield>levelAdds</> to an array of the level increments
       required when descending to each node to be visited.  (Often these
       increments will be the same for all the nodes, but that's not
       necessarily so, so an array is used.)
       If value reconstruction is needed, set
       <structfield>reconstructedValues</> to an array of the values
       reconstructed for each child node to be visited; otherwise, leave
       <structfield>reconstructedValues</> as NULL.
       Note that the <function>inner_consistent</> function is
       responsible for palloc'ing the
       <structfield>nodeNumbers</>, <structfield>levelAdds</> and
       <structfield>reconstructedValues</> arrays.
-->
<structfield>nNodes</>は探索で訪れる必要のある子ノードの数にセットされなければなりません。また、<structfield>nodeNumbers</>はそれらの番号の配列にセットされなければなりません。
演算子クラスがレベルを監視しているときは、それぞれのノードへと下って訪れるときに必要なレベルの増分の配列を<structfield>levelAdds</>にセットします。
(この増分はすべてのノードについて同じになることも多いですが、必ずしもそうなるとは限らないので配列が使われます。)
値の再構築が必要なときには、訪れるそれぞれの子ノードについて再構築された値の配列を<structfield>reconstructedValues</>にセットします。再構築が必要でなければ、<structfield>reconstructedValues</>をNULLのままにします。
<function>inner_consistent</>関数は、<structfield>nodeNumbers</>、<structfield>levelAdds</>、<structfield>reconstructedValues</>の配列についてpallocしなければならないことに注意してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>leaf_consistent</></term>
     <listitem>
      <para>
<!--
       Returns true if a leaf tuple satisfies a query.
-->
リーフタプルが問い合わせを満たす場合、trueを返します。
      </para>

      <para>
<!--
       The <acronym>SQL</> declaration of the function must look like this:
-->
関数の<acronym>SQL</>宣言は以下のようになります。
<programlisting>
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...
</programlisting>
<!--
      The first argument is a pointer to a <structname>spgLeafConsistentIn</>
      C struct, containing input data for the function.
      The second argument is a pointer to a <structname>spgLeafConsistentOut</>
      C struct, which the function must fill with result data.
-->
1番目の引数はCの<structname>spgLeafConsistentIn</>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<structname>spgLeafConsistentOut</>構造体へのポインタで、関数が結果のデータを入れます。
<programlisting>
typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    int         nkeys;          /* length of array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    Datum       leafDatum;      /* datum in leaf tuple */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* reconstructed original data, if any */
    bool        recheck;        /* set true if operator must be rechecked */
} spgLeafConsistentOut;
</programlisting>

<!--
       The array <structfield>scankeys</>, of length <structfield>nkeys</>,
       describes the index search condition(s).  These conditions are
       combined with AND &mdash; only index entries that satisfy all of
       them satisfy the query.  (Note that <structfield>nkeys</> = 0 implies
       that all index entries satisfy the query.)  Usually the consistent
       function only cares about the <structfield>sk_strategy</> and
       <structfield>sk_argument</> fields of each array entry, which
       respectively give the indexable operator and comparison value.
       In particular it is not necessary to check <structfield>sk_flags</> to
       see if the comparison value is NULL, because the SP-GiST core code
       will filter out such conditions.
       <structfield>reconstructedValue</> is the value reconstructed for the
       parent tuple; it is <literal>(Datum) 0</> at the root level or if the
       <function>inner_consistent</> function did not provide a value at the
       parent level.
       <structfield>level</> is the current leaf tuple's level, starting at
       zero for the root level.
       <structfield>returnData</> is <literal>true</> if reconstructed data is
       required for this query; this will only be so if the
       <function>config</> function asserted <structfield>canReturnData</>.
       <structfield>leafDatum</> is the key value stored in the current
       leaf tuple.
-->
配列<structfield>scankeys</>は長さが<structfield>nkeys</>で、インデックス探索の条件を記述します。
複数の条件はANDで結合されます。つまり、条件のすべてを満たすインデックスエントリのみが対象となります。
(<structfield>nkeys</>が0ならば、すべてのエントリが検索条件を満たすことになる、ということに注意してください。)
通常、consistent関数では、配列のそれぞれのエントリの<structfield>sk_strategy</>および<structfield>sk_argument</>フィールドのみが問題となります。これらのフィールドにはそれぞれインデックス付け可能な演算子と比較値が入ります。
なお、比較値がNULLかどうかを確認するために<structfield>sk_flags</>を検査する必要はありません。なぜならSP-GiSTのコアのコードがそのような条件を除外するからです。
<structfield>reconstructedValue</>は親タプルのために再構築された値で、ルートレベルの場合、あるいは親レベルの<function>inner_consistent</>関数が値を返さなかった場合は<literal>(Datum) 0</>となります。
<structfield>level</>は現在のリーフタプルのレベルを、ルートレベルを0として数えたものです。
<structfield>returnData</>は、この問い合わせで再構築されたデータが必要な場合に<literal>true</>となりますが、これは<function>config</>関数が<structfield>canReturnData</>を確認した場合にのみ、そうなります。
<structfield>leafDatum</>は現在のリーフタプルに格納されている鍵の値です。
      </para>

      <para>
<!--
       The function must return <literal>true</> if the leaf tuple matches the
       query, or <literal>false</> if not.  In the <literal>true</> case,
       if <structfield>returnData</> is <literal>true</> then
       <structfield>leafValue</> must be set to the value originally supplied
       to be indexed for this leaf tuple.  Also,
       <structfield>recheck</> may be set to <literal>true</> if the match
       is uncertain and so the operator(s) must be re-applied to the actual
       heap tuple to verify the match.
-->
この関数は、リーフタプルが問い合わせにマッチすれば<literal>true</>を返し、マッチしなければ<literal>false</>を返します。
<literal>true</>の場合、<structfield>returnData</>が<literal>true</>であれば、<structfield>leafValue</>は、このリーフタプルにインデックス付けするために元々提供された値にセットされなければなりません。
また、マッチするかどうかが不確実で、マッチするかの確認のために実際のヒープタプルに演算子を再適用しなければならないときは、<structfield>recheck</>が<literal>true</>にセットされることがあります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
<!--
   All the SP-GiST support methods are normally called in a short-lived
   memory context; that is, <varname>CurrentMemoryContext</> will be reset
   after processing of each tuple.  It is therefore not very important to
   worry about pfree'ing everything you palloc.  (The <function>config</>
   method is an exception: it should try to avoid leaking memory.  But
   usually the <function>config</> method need do nothing but assign
   constants into the passed parameter struct.)
-->
SP-GiSTのすべてのサポートメソッドは、通常は短期間有効なメモリコンテキスト内で呼び出されます。つまり、それぞれのタプルについて処理した後で<varname>CurrentMemoryContext</>はリセットされます。
したがって、pallocしたものすべてについてpfreeすることを気にかけることはあまり重要ではありません。
(<function>config</>メソッドは例外で、メモリリークを避けるようにする必要があります。
しかし、通常は<function>config</>メソッドは、パラメータとして渡された構造体に定数を代入する以外、何もする必要がありません。)
  </para>

  <para>
<!--
   If the indexed column is of a collatable data type, the index collation
   will be passed to all the support methods, using the standard
   <function>PG_GET_COLLATION()</> mechanism.
-->
インデックス付けされた列が照合可能なデータ型の場合、インデックスの照合は、標準的な<function>PG_GET_COLLATION()</>の仕組みを使ってすべてのサポートメソッドに渡されます。
  </para>

</sect1>

<sect1 id="spgist-implementation">
<!--
 <title>Implementation</title>
-->
 <title>実装</title>

  <para>
<!--
   This section covers implementation details and other tricks that are
   useful for implementers of <acronym>SP-GiST</acronym> operator classes to
   know.
-->
この節では、<acronym>SP-GiST</acronym>の演算子クラスを実装する人にとって知っていると役に立つ、実装についての詳細とその他の秘訣について説明します。
  </para>

 <sect2 id="spgist-limits">
<!--
  <title>SP-GiST Limits</title>
-->
  <title>SP-GiSTの制限</title>

  <para>
<!--
   Individual leaf tuples and inner tuples must fit on a single index page
   (8KB by default).  Therefore, when indexing values of variable-length
   data types, long values can only be supported by methods such as radix
   trees, in which each level of the tree includes a prefix that is short
   enough to fit on a page, and the final leaf level includes a suffix also
   short enough to fit on a page.  The operator class should set
   <structfield>longValuesOK</> to TRUE only if it is prepared to arrange for
   this to happen.  Otherwise, the <acronym>SP-GiST</acronym> core will
   reject any request to index a value that is too large to fit
   on an index page.
-->
それぞれのリーフタプルおよび内部タプルは1つのインデックスページ内(デフォルトで8KB)に収まらなければなりません。
従って、可変長のデータ型の値をインデックス付けするときは、長い値は基数木のようなメソッドによってのみサポートされます。つまり、ツリーのそれぞれのレベルではページに収まる短さの接頭辞を含み、最後のリーフレベルでは、やはりページに収まる短さの接尾辞を含む、というようなものです。
このようなことが発生する場合の対応の準備ができている場合のみ、演算子クラスは<structfield>longValuesOK</>をTRUEにセットするべきです。
そうでなければ、<acronym>SP-GiST</acronym>のコアは、インデックスページに収めるには大きすぎる値についてのインデックス付け要求を拒絶します。
  </para>

  <para>
<!--
   Likewise, it is the operator class's responsibility that inner tuples
   do not grow too large to fit on an index page; this limits the number
   of child nodes that can be used in one inner tuple, as well as the
   maximum size of a prefix value.
-->
同様に、内部タプルが大きくなりすぎてインデックスページに収まらない、ということにならないようにするのは、演算子クラスの責任です。
これにより、1つの内部タプルで使うことができる子ノードの数、および接頭辞の値の最大サイズが制限されます。
  </para>

  <para>
<!--
   Another limitation is that when an inner tuple's node points to a set
   of leaf tuples, those tuples must all be in the same index page.
   (This is a design decision to reduce seeking and save space in the
   links that chain such tuples together.)  If the set of leaf tuples
   grows too large for a page, a split is performed and an intermediate
   inner tuple is inserted.  For this to fix the problem, the new inner
   tuple <emphasis>must</> divide the set of leaf values into more than one
   node group.  If the operator class's <function>picksplit</> function
   fails to do that, the <acronym>SP-GiST</acronym> core resorts to
   extraordinary measures described in <xref linkend="spgist-all-the-same">.
-->
内部タプルのノードがリーフタプルの集合を指しているとき、それらのタプルはすべて同じインデックスページ内になければならない、という制限もあります。
(これは、シークの回数を減らし、そのようなタプルを一つにつなげるリンクに必要なスペースを減らす、という設計上の決定によるものです。)
リーフタプルの集合が大きくなって1ページに収まらなくなると、分割が実行され、中間の内部タプルが挿入されます。
これで問題を解決するためには、新しい内部タプルは、リーフの値の集合を2つ以上のノードのグループに分割し<emphasis>なければなりません</>。
演算子クラスの<function>picksplit</>関数がそれをするのに失敗したときは、<acronym>SP-GiST</acronym>のコアは、<xref linkend="spgist-all-the-same">に記述されている特別な手段に頼ることになります。
  </para>
 </sect2>

 <sect2 id="spgist-null-labels">
<!--
  <title>SP-GiST Without Node Labels</title>
-->
  <title>ノードラベルのないSP-GiST</title>

  <para>
<!--
   Some tree algorithms use a fixed set of nodes for each inner tuple;
   for example, in a quad-tree there are always exactly four nodes
   corresponding to the four quadrants around the inner tuple's centroid
   point.  In such a case the code typically works with the nodes by
   number, and there is no need for explicit node labels.  To suppress
   node labels (and thereby save some space), the <function>picksplit</>
   function can return NULL for the <structfield>nodeLabels</> array.
   This will in turn result in <structfield>nodeLabels</> being NULL during
   subsequent calls to <function>choose</> and <function>inner_consistent</>.
   In principle, node labels could be used for some inner tuples and omitted
   for others in the same index.
-->
木構造のアルゴリズムには、それぞれの内部タプルに対して固定された集合のノードを使うものがあります。
例えば四分木では、内部タプルの中心点の周りの4つの象限に対応するちょうど4つのノードが必ずあります。
このような場合、コードは典型的には数字を使ったノードで動作し、明示的なノードラベルは必要ありません。
ノードラベルを使わない(そしてそれによりいくらかのスペースを節約する)ために、<function>picksplit</>関数は<structfield>nodeLabels</>配列としてNULLを返すことができます。
この結果、その後の<function>choose</>関数および<function>inner_consistent</>関数の呼び出しにおいても<structfield>nodeLabels</>はNULLになります。
原則として、ノードラベルは同じインデックス中の一部の内部タプルに使い、他の内部タプルには省略する、ということができます。
  </para>

  <para>
<!--
   When working with an inner tuple having unlabeled nodes, it is an error
   for <function>choose</> to return <literal>spgAddNode</>, since the set
   of nodes is supposed to be fixed in such cases.  Also, there is no
   provision for generating an unlabeled node in <literal>spgSplitTuple</>
   actions, since it is expected that an <literal>spgAddNode</> action will
   be needed as well.
-->
ラベルのないノードを持つ内部タプルを処理するときに、<function>choose</>が<literal>spgAddNode</>を返すのはエラーです。というのは、この場合、ノードの集合は固定されていると想定されるからです。
また、<literal>spgSplitTuple</>のアクションでラベルのないノードを生成する用意はありません。というのは、<literal>spgAddNode</>のアクションも必要になると考えられるからです。
  </para>
 </sect2>

 <sect2 id="spgist-all-the-same">
<!--
  <title><quote>All-the-same</> Inner Tuples</title>
-->
  <title><quote>All-the-same</>内部タプル</title>

  <para>
<!--
   The <acronym>SP-GiST</acronym> core can override the results of the
   operator class's <function>picksplit</> function when
   <function>picksplit</> fails to divide the supplied leaf values into
   at least two node categories.  When this happens, the new inner tuple
   is created with multiple nodes that each have the same label (if any)
   that <function>picksplit</> gave to the one node it did use, and the
   leaf values are divided at random among these equivalent nodes.
   The <literal>allTheSame</> flag is set on the inner tuple to warn the
   <function>choose</> and <function>inner_consistent</> functions that the
   tuple does not have the node set that they might otherwise expect.
-->
<function>picksplit</>が入力のリーフ値を少なくとも2つのノード分類に分割できなかった場合、<acronym>SP-GiST</acronym>のコアは演算子クラスの<function>picksplit</>関数の結果を無効にすることがあります。
これが起きると、複数のノードを持つ新しい内部タプルが作成されます。それぞれのノードは、<function>picksplit</>が一つのノードに付与したもの(あれば)と同じラベルを持ち、リーフ値はこれらの等価なノード間でランダムに分割されます。
内部タプルには<literal>allTheSame</>のフラグがセットされ、<function>choose</>関数および<function>inner_consistent</>関数に対し、そのタプルが通常期待されるようなノードの集合を持っていないことを警告します。
  </para>

  <para>
<!--
   When dealing with an <literal>allTheSame</> tuple, a <function>choose</>
   result of <literal>spgMatchNode</> is interpreted to mean that the new
   value can be assigned to any of the equivalent nodes; the core code will
   ignore the supplied  <structfield>nodeN</> value and descend into one
   of the nodes at random (so as to keep the tree balanced).  It is an
   error for <function>choose</> to return <literal>spgAddNode</>, since
   that would make the nodes not all equivalent; the
   <literal>spgSplitTuple</> action must be used if the value to be inserted
   doesn't match the existing nodes.
-->
<literal>allTheSame</>の処理において、<function>choose</>の<literal>spgMatchNode</>という結果は、新しい値は等価なノードのどれに割り当てられても良い、という意味に解釈されます。
コアのコードは入力された<structfield>nodeN</>の値を無視し、(ツリーの平衡を保つために)ノードの1つにランダムに降りていきます。
<function>choose</>が<literal>spgAddNode</>を返すのはエラーです。というのは、そうするとすべてのノードが等価ではなくなるからです。
挿入する値が既存のノードとマッチしない時は、<literal>spgSplitTuple</>のアクションを使わなければなりません。
  </para>

  <para>
<!--
   When dealing with an <literal>allTheSame</> tuple, the
   <function>inner_consistent</> function should return either all or none
   of the nodes as targets for continuing the index search, since they are
   all equivalent.  This may or may not require any special-case code,
   depending on how much the <function>inner_consistent</> function normally
   assumes about the meaning of the nodes.
-->
<literal>allTheSame</>のタプルの処理において、すべてのノードは等価なので、<function>inner_consistent</>関数は、インデックス検索を続けるためのターゲットとして、すべてのノードを返すか、ノードを1つも返さないかのいずれかであるべきです。
このために、特殊ケースを扱うコードが必要になるかもしれませんし、必要ないかもしれません。それは、<function>inner_consistent</>関数が、通常、ノードの意味についてどの程度のことを仮定しているかに依存します。
  </para>
 </sect2>

</sect1>

<sect1 id="spgist-examples">
<!--
 <title>Examples</title>
-->
 <title>例</title>

 <para>
<!--
  The <productname>PostgreSQL</productname> source distribution includes
  several examples of index operator classes for
  <acronym>SP-GiST</acronym>.  The core system currently provides radix
  trees over text columns and two types of trees over points: quad-tree and
  k-d tree.  Look into <filename>src/backend/access/spgist/</> to see the
  code.
-->
<productname>PostgreSQL</productname>のソースコードの配布物には<acronym>SP-GiST</acronym>のインデックス演算子クラスの例がいくつか含まれています。
コアのシステムは現在、text列についての基数木と点についての2種類の木(4分木とkd木)を提供しています。
コードを参照するには、<filename>src/backend/access/spgist/</>を調べて下さい。
 </para>

</sect1>

</chapter>
